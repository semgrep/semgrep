(* Type definitions for Semgrep CLI output (the scan default command)
 *
 * Note that the generated code for the types in this file is not yet used
 * in output.py but at least those types serve as a spec.
 *)

(*****************************************************************************)
(* Imports *)
(*****************************************************************************)
type json <ocaml module="Yojson.Safe" t="t"> = abstract

type rule_id <ocaml from="Output_from_core" t="rule_id"> = abstract

(* TODO: can't inherit from abstract type, so had to copy-paste location def *)
type location
  <python decorator="dataclass(frozen=True)"> = {
  path: string (* source file *);
  start: position;
  end <ocaml name="end_">: position;
}
type position <ocaml from="Output_from_core" t="position"> = abstract

(*****************************************************************************)
(* Errors (called SemgrepError in error.py) *)
(*****************************************************************************)

(* TODO: try to make it as close as possible to 'error' above *)
type final_error = {
  code: int;
  (* TODO: use a variant *)
  level: string;
  type_ <json name="type">: string;

  (* TODO: use a variant instead of all those ?xxx types *)

  (* for most parsing errors those are set *)
  ?message: string option; (* contains error location *)
  ?path: string option;

  (* for invalid rules *)
  ?long_msg: string option;
  ?short_msg: string option;
  ?spans: json option; (* TODO: see invalid_rule.json *)
}

(*****************************************************************************)
(* Match result (called RuleMatch in rule_matches.py) *)
(*****************************************************************************)

(* TODO: try to make it as close as possible to 'match_' above *)
type final_match = {
  check_id: rule_id;
  inherit location;
  extra: final_extra;
}

(* TODO: try to make it as close as possible to 'match_extra' above *)
type final_extra = {
  (* TODO: inherit match_extra; but need ?metavars because of dependency_aware code *)
  (* added by the CLI (see formatter/json.py) *)
  fingerprint: string;
  lines: string;
  message: string;
  metadata: json;
  (* TODO: use a variant *)
  severity: string;
  ?fix: string option;
  ?fix_regex: fix_regex option;
  ?is_ignored: bool option;
  (* added by dependency_aware code *)
  ?dependency_match_only: bool option;
  ?dependency_matches: json option;
}

type fix_regex = {
  regex: string;
  replacement: string;
}

(*****************************************************************************)
(* Semgrep CLI final output *)
(*****************************************************************************)

type final_result = {
    errors: final_error list;
    results: final_match list;

    (* TODO: see output.py
       paths: (scanned:, ?skipped:, ?_comment:)
       ?stats: (targets:, loc:, profiler:)
       ?time: ()
       (* only in TEXT *)
       ?color_output, per_finding_max_lines_limit, per_line_max_chars_limit
     *)
}
