(* This module allows the generation of fresh types for unique identifiers.
   Such identifiers generated by `mk` are guaranteed to be distinct from each
   other.*)
module MkId () : sig
  (* abstract type! *)
  type t [@@deriving show, eq, hash, sexp]

  val mk : unit -> t
  val to_int : t -> int
  val compare : t -> t -> int

  (* `unsafe_default` is distinct from all generated IDs, but not from other
     `unsafe_default`s.
  *)
  val unsafe_default : t
  val is_unsafe_default : t -> bool

  (* This will reset the internal counter used by the identifiers, making `mk`
     generate already-generated identifiers.
  *)
  val unsafe_reset_counter : unit -> unit

  type partition = A | B

  (* Defaults to partition A. IDs generated from different partitions are
   * guaranteed to be distinct from each other even across different runs of the
   * binary.
   *
   * This is useful if we want to serialize a data structure that includes IDs,
   * then deserialize it in a different run for use alongside fresh IDs. Using
   * one partition when constructing the serialized data, and another for a
   * normal run ensures that we will avoid collisions.
   * *)
  val set_partition : partition -> unit
end
