name: Update Semgrep Rules
on:
  # Allow for manual triggering in https://github.com/returntocorp/semgrep/actions
  # See https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow
  workflow_dispatch: {}
  # This push-event-trigger is useful to test improvements to the workflow by pushing to this
  # special 'cron' branch. We do that for our parsing-stat crons and it avoids to have
  # to wait for the cron to kick in at the scheduled time.
  # TODO: not sure why, but using 'pull_request' instead of 'push' does not work
  push:
    branches:
      - "cron"
  pull_request: {}
  #TODO: at some point also set up an actual cron like
  #  schedule:
  #  - cron: "43 20 * * *"

jobs:
  update-semgrep-rules-submodule:
    runs-on: ubuntu-latest
    steps:
      # We use the semgrep-ci bot as the auth. The custom (internally-developed) docker image
      # below is used to get a JWT, which is then used by git to fetch the code.
      # Using the built-in secrets.GITHUB_TOKEN won't allow for downstream jobs to fire.
      # See https://docs.github.com/en/enterprise-cloud@latest/actions/using-workflows/triggering-a-workflow#triggering-a-workflow-from-a-workflow for more information
      # TODO: where is stored/configured/built this semgrep-ci github App?
      # TODO: where is configured this docker://public.ecr.aws/... image? How is it built?
      # TODO: if a token is rotated, do we need to update this docker link?
      - name: Get JWT for semgrep-ci GitHub App
        id: jwt
        uses: docker://public.ecr.aws/y9k7q4m1/devops/cicd:latest
        env:
          # This is the shortest expiration setting. It ensures that if an attacker got
          # a hold of these credentials after the job runs, they're expired.
          # TODO: how an attacker can access this credential?
          EXPIRATION: 600 # seconds
          ISSUER: ${{ secrets.SEMGREP_CI_APP_ID }}
          PRIVATE_KEY: ${{ secrets.SEMGREP_CI_APP_KEY }}
      - name: Get token for semgrep-ci GitHub App
        id: token
        # We are using the standard github-recommended method for short-live authentification
        # See https://docs.github.com/en/developers/apps/building-github-apps/authenticating-with-github-apps#authenticating-as-a-github-app
        run: |
          TOKEN="$(curl -X POST \
          -H "Authorization: Bearer ${{ steps.jwt.outputs.jwt }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/app/installations/${{ secrets.SEMGREP_CI_APP_INSTALLATION_ID }}/access_tokens" | \
          jq -r .token)"
          echo "::add-mask::$TOKEN"
          echo "::set-output name=token::$TOKEN"
      # Recursively checkout all submodules
      # ensure that we're on the default branch (develop)
      # Use the token provided by the JWT token getter above
      - name: Checkout
        uses: actions/checkout@v3
        with:
          submodules: "recursive"
          # By default actions/checkout will checkout on the pull_request branch (e.g., 'cron').
          # Here instead we want 'develop' (or whatever the name of the current default branch).
          # Why not simply do 'git checkout develop' in another step after?
          # Because this would require some form of configuring URLs or auth using
          # the token, and so 'ref:' and 'token:' below handles that for us instead.
          ref: "${{ github.event.repository.default_branch }}"
          token: "${{ steps.token.outputs.token }}"
      - name: Update Submodule
        run: cd semgrep-core/tests/semgrep-rules; git checkout develop; git pull
        env:
          GITHUB_TOKEN: "${{ steps.token.outputs.token }}"
        #working-directory: ./semgrep-core/tests/semgrep-rules
        #run: |
        #  git checkout develop
        #  git pull
      # just for debugging
      - run: echo FOO >> README.md
      - run: git status
      - name: Add and Commit New Files
        # We could do the 'git add' ourselves, but we also need to handle the case where
        # nothing is available to commit (semgrep-rules has not been updated) and
        # EndBug/add-and-commit handles that automatically
        # See https://github.com/EndBug/add-and-commit
        uses: EndBug/add-and-commit@v9
        with:
          add: README.md semgrep-core/tests/semgrep-rules
          author_name: ${{ github.actor }}
          author_email: ${{ github.actor }}@users.noreply.github.com
          message: "chore: Bump Semgrep Rules Submodule"
          new_branch: update-semgrep-rules-${{ github.run_id }}-${{ github.run_attempt }}
        env:
          GITHUB_TOKEN: "${{ steps.token.outputs.token }}"
      - name: Open PR
        # Use the token generated from the semgrep-ci Github App - this ensures
        # that PR checks will run on the PR opened by this workflow!
        env:
          GITHUB_TOKEN: "${{ steps.token.outputs.token }}"
        run: |
          gh pr create --title 'Update Semgrep-Rules Submodule' --body 'Please confirm correctness of the changes here and ensure all tests pass' \
            --base develop --head update-semgrep-rules-${{ github.run_id }}-${{ github.run_attempt }} --reviewer aryx
