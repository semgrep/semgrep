rules:
- id: contrib.nodejsscan.eval_yaml_deserialize.yaml_deserialize
  patterns:
  - pattern-inside: |
      require('js-yaml');
      ...
  - pattern: |
      $X.load(...)
  message: User controlled data in 'yaml.load()' function can result in Remote Code
    Injection.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
- id: contrib.nodejsscan.security_electronjs.electron_allow_http
  patterns:
  - pattern-either:
    - pattern: |
        new BrowserWindow({webPreferences: {allowRunningInsecureContent: true}});
    - pattern: |
        var $X = {webPreferences: {allowRunningInsecureContent: true}};
  message: Application can load content over HTTP and that makes the app vulnerable
    to Man in the middle attacks.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
- id: contrib.nodejsscan.security_electronjs.electron_disable_websecurity
  patterns:
  - pattern-either:
    - pattern: |
        new BrowserWindow({webPreferences: {webSecurity: false}});
    - pattern: |
        var $X = {webPreferences: {webSecurity: false}};
  message: Disabling webSecurity will disable the same-origin policy and allows the
    execution of insecure code from any domain.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-346: Origin Validation Error'
- id: contrib.nodejsscan.xss_templates.handlebars_noescape
  patterns:
  - pattern: |
      $X.compile(..., {noEscape: true}, ...)
  message: Disabling Escaping in Handlebars is not a secure behaviour. This can introduce
    XSS vulnerabilties.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page
      (Basic XSS)'
- id: contrib.nodejsscan.xss_templates.squirrelly_autoescape
  pattern: $X.autoEscaping(false)
  message: Handlebars SafeString will not escape the data passed through it. Untrusted
    user input passing through SafeString can cause XSS.
  languages:
  - javascript
  severity: ERROR
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
- id: go.grpc.security.grpc-client-insecure-connection.grpc-client-insecure-connection
  metadata:
    cwe: 'CWE-300: Channel Accessible by Non-Endpoint'
    references:
    - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
  message: 'Found an insecure gRPC connection using ''grpc.WithInsecure()''. This
    creates a connection without encryption to a gRPC server. A malicious attacker
    could tamper with the gRPC message, which could compromise the machine. Instead,
    establish a secure connection with an SSL certificate using the ''grpc.WithTransportCredentials()''
    function. You can create a create credentials using a ''tls.Config{}'' struct
    with ''credentials.NewTLS()''. The final fix looks like this: ''grpc.WithTransportCredentials(credentials.NewTLS(<config>))''.'
  languages:
  - go
  severity: ERROR
  pattern: $GRPC.Dial($ADDR, ..., $GRPC.WithInsecure(...), ...)
  fix-regex:
    regex: (.*)WithInsecure\(.*?\)
    replacement: \1WithTransportCredentials(credentials.NewTLS(<your_tls_config_here>))
- id: go.grpc.security.grpc-server-insecure-connection.grpc-server-insecure-connection
  metadata:
    cwe: 'CWE-300: Channel Accessible by Non-Endpoint'
    references:
    - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
  message: Found an insecure gRPC server without 'grpc.Creds()' or options with credentials.
    This allows for a connection without encryption to this server. A malicious attacker
    could tamper with the gRPC message, which could compromise the machine. Include
    credentials derived from an SSL certificate in order to create a secure gRPC connection.
    You can create credentials using 'credentials.NewServerTLSFromFile("cert.pem",
    "cert.key")'.
  languages:
  - go
  severity: ERROR
  patterns:
  - pattern-not: grpc.NewServer(..., grpc.Creds(...), ...)
  - pattern-not-inside: |
      $OPTS := []grpc.ServerOption{
        ...,
        grpc.Creds(credentials.NewClientTLSFromCert(...)),
        ...,
      }
      grpc.NewServer($OPTS...)
  - pattern-not-inside: |
      $CREDS := credentials.NewClientTLSFromCert(...)
      ...
      $OPTS := []grpc.ServerOption{
        ...,
        $CREDS,
        ...,
      }
      grpc.NewServer($OPTS...)
  - pattern: grpc.NewServer(...)
- id: go.jwt-go.security.jwt.hardcoded-jwt-key
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
  pattern-either:
  - pattern: |
      $X = []byte("...")
      ...
      $Y := $TOKEN.SignedString($X)
  - pattern: |
      $TOKEN.SignedString([]byte("..."))
  message: JWT token is hardcoded
  languages:
  - go
  severity: WARNING
- id: go.lang.correctness.useless-eqeq.hardcoded-eq-true-or-false
  patterns:
  - pattern-either:
    - pattern: if (true) { ... }
    - pattern: if (false) { ... }
  message: useless if statement, always the same behavior
  languages:
  - go
  severity: ERROR
- id: go.lang.maintainability.useless-ifelse.useless-if-conditional
  patterns:
  - pattern-either:
    - pattern: |-
        if ($X) {
            ...
        } else if ($X) {
            ...
        }
  message: |
    Detected an if block that checks for the same condition on both branches (`$X`)
  languages:
  - go
  severity: WARNING
- id: go.lang.maintainability.useless-ifelse.useless-if-body
  patterns:
  - pattern: |-
      if ($X) {
          $S
      } else {
          $S
      }
  message: |
    Detected identical if-statement bodies. Is this intentional?
  languages:
  - go
  severity: WARNING
- id: go.lang.security.audit.crypto.bad_imports.insecure-module-used
  message: Detected use of an insecure cryptographic hashing method. This method is
    known to be broken and easily compromised. Use SHA256 or SHA3 instead.
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://godoc.org/golang.org/x/crypto/sha3
  languages:
  - go
  severity: WARNING
  pattern-either:
  - patterns:
    - pattern-inside: |
        import "crypto/md5"
        ...
    - pattern: |
        md5.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "crypto/des"
        ...
    - pattern: |
        des.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "crypto/sha1"
        ...
    - pattern: |
        sha1.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "crypto/rc4"
        ...
    - pattern: |
        rc4.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "net/http/cgi"
        ...
    - pattern: |
        cgi.$FUNC(...)
- id: go.lang.security.audit.crypto.insecure_ssh.avoid-ssh-insecure-ignore-host-key
  message: |
    Disabled host key verification detected. This allows man-in-the-middle
    attacks. Use the 'golang.org/x/crypto/ssh/knownhosts' package to do
    host key verification.
    See https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
    to learn more about the problem and how to fix it.
  metadata:
    cwe: 'CWE-322: Key Exchange without Entity Authentication'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
    - https://gist.github.com/Skarlso/34321a230cf0245018288686c9e70b2d
  languages:
  - go
  severity: WARNING
  pattern: ssh.InsecureIgnoreHostKey()
- id: go.lang.security.audit.crypto.ssl.ssl-v3-is-insecure
  message: |
    SSLv3 is insecure because it has known vulnerabilities.
    Starting with go1.14, SSLv3 will be removed. Instead, use
    'tls.VersionTLS13'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls_config.go
    references:
    - https://golang.org/doc/go1.14#crypto/tls
    - https://www.us-cert.gov/ncas/alerts/TA14-290A
  languages:
  - go
  severity: ERROR
  patterns:
  - pattern: 'tls.Config{..., MinVersion: $TLS.VersionSSL30, ...}'
  fix-regex:
    regex: VersionSSL30
    replacement: VersionTLS13
- id: go.lang.security.audit.crypto.tls.tls-with-insecure-cipher
  message: |
    Detected an insecure CipherSuite via the 'tls' module. This suite is considered weak.
    Use the function 'tls.CipherSuites()' to get a list of good cipher suites.
    See https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
    for why and what other cipher suites to use.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls.go
    references:
    - https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
  languages:
  - go
  severity: WARNING
  pattern-either:
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.CipherSuite{..., TLS_RSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_RSA_WITH_AES_128_CBC_SHA256 ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 ,...}
  - pattern: tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 ,...}
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-md5
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
  pattern-either:
  - pattern: |
      md5.New()
  - pattern: |
      md5.Sum(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-sha1
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
  pattern-either:
  - pattern: |
      sha1.New()
  - pattern: |
      sha1.Sum(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-DES
  message: |
    Detected DES cipher algorithm which is insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
  pattern-either:
  - pattern: |
      des.NewTripleDESCipher(...)
  - pattern: |
      des.NewCipher(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-rc4
  message: |
    Detected RC4 cipher algorithm which is insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
  pattern: rc4.NewCipher(...)
- id: go.lang.security.audit.net.dynamic-httptrace-clienttrace.dynamic-httptrace-clienttrace
  message: |
    Detected a potentially dynamic ClientTrace. This occurred because semgrep could not
    find a static definition for '$TRACE'. Dynamic ClientTraces are dangerous because
    they deserialize function code to run when certain Request events occur, which could lead
    to code being run without your knowledge. Ensure that your ClientTrace is statically defined.
  metadata:
    cwe: 'CWE-913: Improper Control of Dynamically-Managed Code Resources'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://github.com/returntocorp/semgrep-rules/issues/518
  patterns:
  - pattern-not-inside: |
      ...
      &httptrace.ClientTrace { ... }
      ...
  - pattern: httptrace.WithClientTrace($ANY, $TRACE)
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.net.pprof.pprof-debug-exposure
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/securego/gosec#available-rules
    references:
    - https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
  message: |
    The profiling 'pprof' endpoint is automatically exposed on /debug/pprof.
    This could leak information about the server.
    Instead, use `import "net/http/pprof"`. See
    https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
    for more information and mitigation.
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-inside: |
      import _ "net/http/pprof"
      ...
  - pattern-inside: |
      func $ANY(...) {
        ...
      }
  - pattern-not: http.ListenAndServe("=~/^localhost.*/", ...)
  - pattern-not: http.ListenAndServe("=~/^127[.]0[.]0[.]1.*/", ...)
  - pattern: http.ListenAndServe(...)
- id: go.lang.security.audit.net.wip-xss-using-responsewriter-and-printf.wip-xss-using-responsewriter-and-printf
  patterns:
  - pattern-inside: |
      func $FUNC(..., $W http.ResponseWriter, ...) {
          ...
      }
  - pattern-inside: |
      ...
      var $T = "..."
      ...
      $W.Write([]byte(fmt.$PRINTF($T, ...)), ...)
  - pattern-either:
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $INTERM = $ANYTHING(..., $DATA, ...)
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $INTERM = $DATA[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $DATA, $ERR := r.URL.Query()[...]
        ...
        $INTERM = $DATA[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $DATA, $ERR := r.URL.Query()[...]
        ...
        $INTERM = $ANYTHING(..., $DATA, ...)
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $DATA, ...)))
  message: |
    Found data going from url query parameters into formatted data written to ResponseWriter.
    This could be XSS and should not be done. If you must do this, ensure your data is
    sanitized or escaped.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (''XSS'')'
  severity: WARNING
  languages:
  - go
- id: go.lang.security.decompression_bomb.potential-dos-via-decompression-bomb
  message: Detected a possible denial-of-service via a zip bomb attack. By limiting
    the max bytes read, you can mitigate this attack. `io.CopyN()` can specify a size.
    Refer to https://bomb.codes/ to learn more about this attack and other ways to
    mitigate it.
  severity: WARNING
  languages:
  - go
  patterns:
  - pattern-either:
    - pattern: io.Copy(...)
    - pattern: io.CopyBuffer(...)
  - pattern-either:
    - pattern-inside: |
        gzip.NewReader(...)
        ...
    - pattern-inside: |
        zlib.NewReader(...)
        ...
    - pattern-inside: |
        zlib.NewReaderDict(...)
        ...
    - pattern-inside: |
        bzip2.NewReader(...)
        ...
    - pattern-inside: |
        flate.NewReader(...)
        ...
    - pattern-inside: |
        flate.NewReaderDict(...)
        ...
    - pattern-inside: |
        lzw.NewReader(...)
        ...
    - pattern-inside: |
        tar.NewReader(...)
        ...
    - pattern-inside: |
        zip.NewReader(...)
        ...
    - pattern-inside: |
        zip.OpenReader(...)
        ...
  fix-regex:
    regex: (.*)(Copy|CopyBuffer)\((.*?),(.*?)(\)|,.*\))
    replacement: \1CopyN(\3, \4, 1024*1024*256)
  metadata:
    cwe: 'CWE-400: Uncontrolled Resource Consumption'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://bomb.codes/
    - https://golang.org/pkg/io/#CopyN
    - https://github.com/securego/gosec/blob/master/rules/decompression-bomb.go
- id: go.lang.security.zip.path-traversal-inside-zip-extraction
  message: File traversal when extracting zip archive
  metadata:
    cwe: |
      CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
    source_rule_url: https://github.com/securego/gosec/issues/205
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern: |-
      reader, $ERR := zip.OpenReader($ARCHIVE)
      ...
      for _, $FILE := range reader.File {
        ...
        path := filepath.Join($TARGET, $FILE.Name)
        ...
      }
- id: java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
    references:
    - https://www.owasp.org/index.php/Path_Traversal
  message: |
    Detected a potential path traversal. A malicious actor
    could control the location of this file, to include going backwards
    in the directory with '../'. To address this, ensure that user-controlled
    variables in file paths are sanitized. You may aslso consider using a utility
    method such as org.apache.commons.io.FilenameUtils.getName(...) to only
    retrieve the file name from the path.
  patterns:
  - pattern-either:
    - pattern: |
        $RETURNTYPE $FUNC (..., @PathParam(...) $TYPE $VAR, ...) {
          ...
          new File(..., $VAR, ...);
          ...
        }
    - pattern: |-
        $RETURNTYPE $FUNC (..., @javax.ws.rs.PathParam(...) $TYPE $VAR, ...) {
          ...
          new File(..., $VAR, ...);
          ...
        }
  severity: WARNING
  languages:
  - java
- id: java.lang.correctness.eqeq.eqeq
  patterns:
  - pattern-not-inside: assert $X;
  - pattern-not-inside: |
      assert $X : $Y;
  - pattern-either:
    - pattern: $X == $X
    - pattern: $X != $X
  - pattern-not: 1 == 1
  message: |
    `$X == $X` or `$X != $X` is always true. (Unless the value compared is a float or double).
    To test if `$X` is not-a-number, use `Double.isNaN($X)`.
  languages:
  - java
  severity: ERROR
- id: java.lang.correctness.no-string-eqeq.no-string-eqeq
  languages:
  - java
  equivalences:
  - equivalence: $X == $Y ==> $Y == $X
  patterns:
  - pattern-not: null == (String $Y)
  - pattern: $X == (String $Y)
  message: |
    Strings should not be compared with '=='.
    This is a reference comparison operator.
    Use '.equals()' instead.
  severity: WARNING
- id: java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated
  message: |
    DES is considered deprecated. AES is the recommended cipher.
    Upgrade to use AES.
    See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DES_USAGE
    references:
    - https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard
  severity: WARNING
  pattern: $CIPHER.getInstance("=~/DES/.*/");
  fix: $CIPHER.getInstance("AES/GCM/NoPadding");
  languages:
  - java
- id: java.lang.security.audit.crypto.no-null-cipher.no-null-cipher
  pattern: new NullCipher(...);
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#NULL_CIPHER
  message: |
    NullCipher was detected. This will not encrypt anything;
    the cipher text will be the same as the plain text. Use
    a valid, secure cipher: Cipher.getInstance("AES/CBC/PKCS7PADDING").
    See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions
    for more information.
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector
  message: |
    Initialization Vectors (IVs) for block ciphers should be randomly generated
    each time they are used. Using a static IV means the same plaintext
    encrypts to the same ciphertext every time, weakening the strength
    of the encryption.
  metadata:
    cwe: 'CWE-329: Not Using a Random IV with CBC Mode'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#STATIC_IV
    references:
    - https://cwe.mitre.org/data/definitions/329.html
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern: |
        byte[] $IV = {
            ...
        };
        ...
        new IvParameterSpec($IV, ...);
    - pattern: |
        class $CLASS {
            byte[] $IV = {
                ...
            };
            ...
            $METHOD(...) {
                ...
                new IvParameterSpec($IV, ...);
                ...
            }
        }
- id: java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DEFAULT_HTTP_CLIENT
  message: |
    DefaultHttpClient is deprecated. Further, it does not support connections
    using TLS1.2, which makes using DefaultHttpClient a security hazard.
    Use SystemDefaultHttpClient instead, which supports TLS1.2.
  severity: WARNING
  languages:
  - java
  pattern: new DefaultHttpClient(...);
  fix-regex:
    regex: DefaultHttpClient
    replacement: SystemDefaultHttpClient
- id: java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier
  message: |
    Insecure HostnameVerifier implementation detected. This will accept
    any SSL certificate with any hostname, which creates the possibility
    for man-in-the-middle attacks.
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern: |
        class $CLASS implements HostnameVerifier {
          ...
          public boolean verify(...) { return true; }
        }
    - pattern: |-
        new HostnameVerifier(...){
          public boolean verify(...) {
            return true;
          }
        }
- id: java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER
    references:
    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
  message: |
    Detected empty trust manager implementations. This is dangerous because it accepts any
    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore
    and TrustManagerFactory isntead.
    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
    for more information.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern-inside: |
        class $CLASS implements X509TrustManager {
          ...
        }
    - pattern-inside: |
        new X509TrustManager() {
          ...
        }
    - pattern-inside: |
        class $CLASS implements X509ExtendedTrustManager {
          ...
        }
    - pattern-inside: |
        new X509ExtendedTrustManager() {
          ...
        }
  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }
  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }
  - pattern-either:
    - pattern: public void checkClientTrusted(...) {}
    - pattern: public void checkServerTrusted(...) {}
    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }
- id: java.lang.security.audit.crypto.weak-hash.use-of-md5
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - java
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5
  pattern-either:
  - pattern: |
      MessageDigest $VAR = $MD.getInstance("MD5");
  - pattern: |
      $DU.getMd5Digest().digest(...)
- id: java.lang.security.audit.crypto.weak-hash.use-of-sha1
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - java
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_SHA1
  pattern-either:
  - pattern: |
      MessageDigest $VAR = $MD.getInstance("SHA1");
  - pattern: |
      $DU.getSha1Digest().digest(...)
- id: java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection
  metadata:
    cwe: 'CWE-297: Improper Validation of Certificate with Host Mismatch'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_SMTP_SSL
  message: |
    Insecure SMTP connection detected. This connection will trust any SSL certificate.
    Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'.
  severity: WARNING
  patterns:
  - pattern-not-inside: |
      $EMAIL.setSSLCheckServerIdentity(true);
      ...
  - pattern-inside: |
      $EMAIL = new SimpleEmail(...);
      ...
  - pattern: $EMAIL.send(...);
  languages:
  - java
- id: java.lang.security.audit.permissive-cors.permissive-cors
  message: |
    https://find-sec-bugs.github.io/bugs.htm#PERMISSIVE_CORS
    Permissive CORS policy will allow a malicious application to communicate with the victim application in an inappropriate way, leading to spoofing, data theft, relay and other attacks.
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      HttpServletResponse $RES = ...;
      ...
      $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      HttpServletResponse $RES = ...;
      ...
      $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      ServerHttpResponse $RES = ...;
      ...
      $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      HttpHeaders $HEADERS = ...;
      ...
      $HEADERS.set("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      ServerWebExchange $SWE = ...;
      ...
      $SWE.getResponse().getHeaders().add("Access-Control-Allow-Origin", "*");
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: |
      $X $METHOD(...,ServerHttpResponse $RES,...) {
        ...
        $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: |
      $X $METHOD(...,ServerWebExchange $SWE,...) {
        ...
        $SWE.getResponse().getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: ResponseEntity.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
  - pattern: ServerResponse.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
- id: java.lang.security.audit.weak-ssl-context.weak-ssl-context
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source_rule_url: https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT
    references:
    - https://tools.ietf.org/html/rfc7568
    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
  message: |
    An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions
    are considered weak encryption and are deprecated.
    Use SSLContext.getInstance("TLSv1.2") for the best security.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-not: SSLContext.getInstance("TLS1.3")
  - pattern-not: SSLContext.getInstance("TLS1.2")
  - pattern: SSLContext.getInstance("...")
  fix-regex:
    regex: (.*?)\.getInstance\(.*?\)
    replacement: \1.getInstance("TLS1.2")
- id: java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
    references:
    - https://www.owasp.org/index.php/Path_Traversal
  message: |
    Detected a potential path traversal. A malicious actor
    could control the location of this file, to include going backwards
    in the directory with '../'. To address this, ensure that user-controlled
    variables in file paths are sanitized. You may aslso consider using a utility
    method such as org.apache.commons.io.FilenameUtils.getName(...) to only
    retrieve the file name from the path.
  patterns:
  - pattern-inside: |
      $RETURNTYPE $FUNC (..., HttpServletRequest $REQ, ...) {
        ...
      }
  - pattern-either:
    - pattern: |
        $VAR = ($TYPE)$REQ.getParameter(...);
        ...
        new File(..., $VAR, ...);
    - pattern: |
        $VAR = $REQ.getParameter(...);
        ...
        new File(..., $VAR, ...);
  severity: ERROR
  languages:
  - java
- id: java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss
  message: |
    Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User
    input was detected going directly from the HttpServletRequest into output. Ensure your
    data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (''XSS'')'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET
  severity: ERROR
  patterns:
  - pattern-inside: $TYPE $FUNC(..., HttpServletResponse $RESP, ...) { ... }
  - pattern-inside: $VAR = $REQ.getParameter(...); ...
  - pattern-either:
    - pattern: $RESP.getWriter(...).write(..., $VAR, ...);
    - pattern: |
        $WRITER = $RESP.getWriter(...);
        ...
        $WRITER.write(..., $VAR, ...);
  languages:
  - java
- id: java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled
  severity: ERROR
  metadata:
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    owasp: 'A4: XML External Entities (XXE)'
    references:
    - https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf
  message: |
    XML external entities are enabled for this XMLInputFactory. This is vulnerable to XML external entity
    attacks. Disable external entities by setting "javax.xml.stream.isSupportingExternalEntities" to false.
  pattern: $XMLFACTORY.setProperty("javax.xml.stream.isSupportingExternalEntities",
    true);
  languages:
  - java
- id: java.rmi.security.server-dangerous-object-deserialization.server-dangerous-object-deserialization
  severity: ERROR
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/
    - https://frohoff.github.io/appseccali-marshalling-pickles/
  message: |
    Using an arbitrary object ('Object $PARAM') with Java RMI is an insecure deserialization
    vulnerability. This object can be manipulated by a malicious actor allowing them to execute
    code on your system. Instead, use an integer ID to look up your object, or consider alternative
    serializiation schemes such as JSON.
  patterns:
  - pattern: |
      interface $INTERFACE extends Remote {
        $RETURNTYPE $METHOD(Object $PARAM) throws RemoteException;
      }
  languages:
  - java
- id: java.spring.security.unrestricted-request-mapping.unrestricted-request-mapping
  patterns:
  - pattern: |
      @RequestMapping(...)
      $RETURNTYPE $METHOD(...) { ... }
  - pattern-not-inside: |
      @RequestMapping(..., method = $X)
      $RETURNTYPE $METHOD(...) { ... }
  message: Detected a method annotated with 'RequestMapping' that does not specify
    the HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or OPTIONS,
    and by default all HTTP methods are allowed when the HTTP method is not explicitly
    specified. This means that a method that performs state changes could be vulnerable
    to CSRF attacks. To mitigate, add the 'method' field and specify the HTTP method
    (such as 'RequestMethod.POST').
  severity: WARNING
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
    references:
    - https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
  languages:
  - java
- id: javascript.grpc.security.grpc-nodejs-insecure-connection.grpc-nodejs-insecure-connection
  message: |
    Found an insecure gRPC connection. This creates a connection without encryption to a gRPC client/server. A malicious attacker
    could tamper with the gRPC message, which could compromise the machine.
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
  severity: ERROR
  languages:
  - javascript
  pattern-either:
  - pattern: |
      require('grpc');
      ...
      $GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);
  - pattern: |-
      require('grpc');
      ...
      $CREDS = <... $CREDENTIALS.createInsecure() ...>;
      ...
      $GRPC($ADDR,...,$CREDS,...);
- id: javascript.jose.security.jwt-exposed-credentials.jwt-exposed-credentials
  languages:
  - javascript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  patterns:
  - pattern-either:
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign({password:...},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign({password:...},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {password:...};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {password:...};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {password:...};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {password:...};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.password = ...;
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.password = ...;
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {$U:{password:...}};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {$U:{password:...}};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {$U:{password:...}};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {$U:{password:...}};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.$U.password = ...;
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.$U.password = ...;
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
  severity: ERROR
- id: javascript.jose.security.jwt-hardcode.hardcoded-jwt-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  patterns:
  - pattern-either:
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        JWT.verify($P, "...", ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign($P, "...", ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.verify($P, "...", ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        JWT.verify($P, JWK.asKey("..."), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $KEY = JWK.asKey("...");
        ...
        JWT.verify($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $T = JWT.sign($P, JWK.asKey("..."), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $T = JWT.verify($P, JWK.asKey("..."), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $KEY = JWK.asKey("...");
        ...
        var $T = JWT.sign($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $KEY = JWK.asKey("...");
        ...
        var $T = JWT.verify($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        JWT.verify($P, $SECRET, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.sign($P, $SECRET, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.verify($P, $SECRET, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        JWT.verify($P, JWK.asKey($SECRET), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $KEY = JWK.asKey($SECRET);
        ...
        JWT.verify($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.sign($P, JWK.asKey($SECRET), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $KEY = JWK.asKey($SECRET);
        ...
        var $T = JWT.sign($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.verify($P, JWK.asKey($SECRET), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $KEY = JWK.asKey($SECRET);
        ...
        var $T = JWT.verify($P, $KEY, ...);
  languages:
  - javascript
  severity: ERROR
- id: javascript.jose.security.jwt-none-alg.jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  languages:
  - javascript
  severity: ERROR
  patterns:
  - pattern-either:
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $T = JWT.verify($P, JWK.None,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        $T = JWT.verify($P, JWK.None,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        JWT.verify($P, JWK.None,...);
- id: javascript.jsonwebtoken.security.jwt-exposed-credentials.jwt-exposed-credentials
  languages:
  - javascript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  patterns:
  - pattern-either:
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign({password:...},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign({password:...},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign({password:...},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {password:...};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {password:...};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {password:...};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {password:...};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {password:...};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {password:...};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.password = ...;
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.password = ...;
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.password = ...;
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {$U:{password:...}};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {$U:{password:...}};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {$U:{password:...}};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {$U:{password:...}};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {$U:{password:...}};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {$U:{password:...}};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.$U.password = ...;
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.$U.password = ...;
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.$U.password = ...;
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
  severity: ERROR
- id: javascript.jsonwebtoken.security.jwt-hardcode.hardcoded-jwt-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  patterns:
  - pattern-either:
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.verify($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.verify($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        var $T = $JWT.sign($P, $SECRET, ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        var $T = $JWT.verify($P, $SECRET, ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        $JWT.sign($P, $SECRET, ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        $JWT.verify($P, $SECRET, ...);
  languages:
  - javascript
  severity: ERROR
- id: javascript.jsonwebtoken.security.jwt-none-alg.jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  languages:
  - javascript
  severity: ERROR
  patterns:
  - pattern-either:
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
    - pattern: |-
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
- id: javascript.lang.correctness.useless-eqeq.eqeq-is-bad
  patterns:
  - pattern-not-inside: assert(...)
  - pattern-either:
    - pattern: $X == $X
    - pattern: $X != $X
  - pattern-not: 1 == 1
  message: |
    Detected a useless comparison operation `$X == $X` or `$X != $X`. This
    operation is always true.
    If testing for floating point NaN, use `math.isnan`, or
    `cmath.isnan` if the number is complex.
  languages:
  - javascript
  - typescript
  severity: ERROR
- id: python.boto3.security.hardcoded-token.hardcoded-token
  message: |
    Hardcoded AWS access token detected. Use environment variables
    to access tokens (e.g., os.environ.get(...)) or use non version-controlled
    configuration files.
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://pypi.org/project/flake8-boto3/
    references:
    - https://bento.dev/checks/boto3/hardcoded-access-token/
    - https://aws.amazon.com/blogs/security/what-to-do-if-you-inadvertently-expose-an-aws-access-key/
  patterns:
  - pattern-either:
    - pattern: $W(..., aws_secret_access_key="=~/^[A-Za-z0-9/+=]+$/", ...)
    - pattern: $W(..., aws_access_key_id="=~/^AKI/", ...)
    - pattern: $W(..., aws_session_token="...", ...)
  languages:
  - python
  severity: WARNING
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-blowfish
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.Blowfish(...)
  message: |
    Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L96
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-idea
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.IDEA(...)
  message: |
    Detected IDEA cipher algorithm which is considered insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://tools.ietf.org/html/rfc5469
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-rc4
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.ARC4(...)
  message: |
    Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L94
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
  pattern: cryptography.hazmat.primitives.ciphers.modes.ECB(...)
  message: |
    Detected ECB cipher mode which is considered insecure. The algorithm can
    potentially leak information about the plaintext. Use CBC mode instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L101
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B305
    references:
    - https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  pattern: cryptography.hazmat.primitives.hashes.MD5(...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  pattern: cryptography.hazmat.primitives.hashes.SHA1(...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insufficient-ec-key-size.insufficient-ec-key-size
  patterns:
  - pattern-inside: cryptography.hazmat.primitives.asymmetric.ec.generate_private_key(...)
  - pattern-either:
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECP192R1
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163K1
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163R2
  message: |
    Detected an insufficient curve size for EC. NIST recommends
    a key size of 224 or higher. For example, use 'ec.SECP256R1'.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
    references:
    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
    - https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#elliptic-curves
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references: https://docs.python.org/3/library/pickle.html
  message: Avoid using insecure deserialization library, backed by `pickle`, `_pickle`,
    `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code
    execution vulnerabilities.
  languages:
  - python
  severity: ERROR
  patterns:
  - pattern-inside: |
      def $X(..., request, ...):
        ...
  - pattern-either:
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        pickle.$FUNC(<... $VAR ...>)
    - pattern: pickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        _pickle.$FUNC(<... $VAR ...>)
    - pattern: _pickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        cPickle.$FUNC(<... $VAR ...>)
    - pattern: cPickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        dill.$FUNC(<... $VAR ...>)
    - pattern: dill.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        shelve.$FUNC(<... $VAR ...>)
    - pattern: shelve.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        yaml.$FUNC(<... $VAR ...>)
    - pattern: yaml.$FUNC(<... request.$Y.get(...) ...>)
- id: python.django.security.injection.code.globals-misuse-code-execution.globals-misuse-code-execution
  message: |
    Found request data as an index to 'globals()'. This is extremely
    dangerous because it allows an attacker to execute arbitrary code
    on the system. Refactor your code not to use 'globals()'.
  metadata:
    cwe: 'CWE-96: Improper Neutralization of Directives in Statically Saved Code (''Static
      Code Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://github.com/mpirnat/lets-be-bad-guys/blob/d92768fb3ade32956abd53bd6bb06e19d634a084/badguys/vulnerable/views.py#L181-L186
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
- id: python.django.security.injection.code.user-eval.user-eval
  message: |
    Found user data in a call to 'eval'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: eval(..., request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        eval(..., $V, ...)
    - pattern: eval(..., request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        eval(..., $V, ...)
    - pattern: eval(..., request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        eval(..., $V, ...)
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.code.user-exec.user-exec
  message: |
    Found user data in a call to 'exec'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: exec(..., request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        exec(..., $V, ...)
    - pattern: exec(..., request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        exec(..., $V, ...)
    - pattern: exec(..., request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        exec(..., $V, ...)
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.mass-assignment.mass-assignment
  languages:
  - python
  severity: WARNING
  message: |
    Mass assignment detected. This can result in assignment to
    model fields that are unintended and can be exploited by
    an attacker. Instead of using '**request.$W', assign each field you
    want to edit individually to prevent mass assignment. You can read
    more about mass assignment at
    https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html.
  metadata:
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    owasp: 'A1: Injection'
    owaspapi: 'API6: Mass Assignment'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html
  patterns:
  - pattern-either:
    - pattern: $MODEL.objects.create(**request.$W)
    - pattern: |
        $OBJ.update(**request.$W)
        ...
        $OBJ.save()
- id: python.django.security.injection.email.xss-html-email-body.xss-html-email-body
  message: |
    Found request data in an EmailMessage that is set to use HTML.
    This is dangerous because HTML emails are susceptible to XSS.
    An attacker could inject data into this HTML email, causing XSS.
  metadata:
    cwe: 'CWE-74: Improper Neutralization of Special Elements in Output Used by a
      Downstream Component (''Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://www.damonkohler.com/2008/12/email-injection.html
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
        $EMAIL.content_subtype = "html"
        ...
  - pattern-either:
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W, ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W, ...)
- id: python.django.security.injection.email.xss-send-mail-html-message.xss-send-mail-html-message
  message: |
    Found request data in 'send_mail(...)' that uses 'html_message'.
    This is dangerous because HTML emails are susceptible to XSS.
    An attacker could inject data into this HTML email, causing XSS.
  metadata:
    cwe: 'CWE-74: Improper Neutralization of Special Elements in Output Used by a
      Downstream Component (''Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://www.damonkohler.com/2008/12/email-injection.html
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: django.core.mail.send_mail(..., html_message=request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W.get(...),
        ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W.get(...),
        ...)
    - pattern: django.core.mail.send_mail(..., html_message=request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W(...),
        ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W(...),
        ...)
    - pattern: django.core.mail.send_mail(..., html_message=request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W[...],
        ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W[...],
        ...)
    - pattern: django.core.mail.send_mail(..., html_message=request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W, ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W, ...)
- id: python.django.security.injection.command.command-injection-os-system.command-injection-os-system
  message: Request data detected in os.system. This could be vulnerable to a command
    injection and should be avoided. If this must be done, use the 'subprocess' module
    instead and pass the arguments as a list. See https://owasp.org/www-community/attacks/Command_Injection
    for more information.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Command_Injection
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: os.system(..., request.$W.get(...), ...)
    - pattern: os.system(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: os.system(..., $S % request.$W.get(...), ...)
    - pattern: os.system(..., f"...{request.$W.get(...)}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W.get(...), ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: $A = os.system(..., $S % request.$W.get(...), ...)
    - pattern: $A = os.system(..., f"...{request.$W.get(...)}...", ...)
    - pattern: return os.system(..., request.$W.get(...), ...)
    - pattern: return os.system(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: return os.system(..., $S % request.$W.get(...), ...)
    - pattern: return os.system(..., f"...{request.$W.get(...)}...", ...)
    - pattern: os.system(..., request.$W(...), ...)
    - pattern: os.system(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: os.system(..., $S % request.$W(...), ...)
    - pattern: os.system(..., f"...{request.$W(...)}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W(...), ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: $A = os.system(..., $S % request.$W(...), ...)
    - pattern: $A = os.system(..., f"...{request.$W(...)}...", ...)
    - pattern: return os.system(..., request.$W(...), ...)
    - pattern: return os.system(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: return os.system(..., $S % request.$W(...), ...)
    - pattern: return os.system(..., f"...{request.$W(...)}...", ...)
    - pattern: os.system(..., request.$W[...], ...)
    - pattern: os.system(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: os.system(..., $S % request.$W[...], ...)
    - pattern: os.system(..., f"...{request.$W[...]}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W[...], ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: $A = os.system(..., $S % request.$W[...], ...)
    - pattern: $A = os.system(..., f"...{request.$W[...]}...", ...)
    - pattern: return os.system(..., request.$W[...], ...)
    - pattern: return os.system(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: return os.system(..., $S % request.$W[...], ...)
    - pattern: return os.system(..., f"...{request.$W[...]}...", ...)
    - pattern: os.system(..., request.$W, ...)
    - pattern: os.system(..., $S.format(..., request.$W, ...), ...)
    - pattern: os.system(..., $S % request.$W, ...)
    - pattern: os.system(..., f"...{request.$W}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W, ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W, ...), ...)
    - pattern: $A = os.system(..., $S % request.$W, ...)
    - pattern: $A = os.system(..., f"...{request.$W}...", ...)
    - pattern: return os.system(..., request.$W, ...)
    - pattern: return os.system(..., $S.format(..., request.$W, ...), ...)
    - pattern: return os.system(..., $S % request.$W, ...)
    - pattern: return os.system(..., f"...{request.$W}...", ...)
- id: python.django.security.injection.path-traversal.path-traversal-file-name.path-traversal-file-name
  message: |
    Data from request is passed to a file name `$FILE`.
    This is a path traversal vulnerability: https://owasp.org/www-community/attacks/Path_Traversal
    To mitigate, consider using os.path.abspath or os.path.realpath or Path library.
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Path_Traversal
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-not: |
      ...
      os.path.realpath(...)
      ...
  - pattern-not: |
      ...
      os.path.abspath(...)
      ...
  - pattern-either:
    - pattern: |
        $V = request.$W.get($X)
        ...
        $FILE % ($V)
    - pattern: |
        $V = request.$W[$X]
        ...
        $FILE % ($V)
    - pattern: |
        $V = request.$W($X)
        ...
        $FILE % ($V)
    - pattern: |
        $V = request.$W
        ...
        $FILE % ($V)
        # match format use cases
    - pattern: |
        $V = request.$W.get($X)
        ...
        $FILE.format(..., $V, ...)
    - pattern: |
        $V = request.$W[$X]
        ...
        $FILE.format(..., $V, ...)
    - pattern: |
        $V = request.$W($X)
        ...
        $FILE.format(..., $V, ...)
    - pattern: |
        $V = request.$W
        ...
        $FILE.format(..., $V, ...)
  - metavariable-regex:
      metavariable: $FILE
      regex: .*\.(log|zip|txt|csv|xml|html).*
  languages:
  - python
  severity: WARNING
- id: python.django.security.passwords.use-none-for-password-default.use-none-for-password-default
  message: |
    '$VAR' is using the empty string as its default and is being used to set
    the password on '$MODEL'. If you meant to set an unusable password, set
    the default value to 'None' or call 'set_unusable_password()'.
  metadata:
    cwe: 'CWE-521: Weak Password Requirements'
    owasp: 'A2: Broken Authentication'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/contrib/auth/#django.contrib.auth.models.User.set_password
  patterns:
  - pattern-either:
    - pattern: |
        $VAR = request.$W.get($X, "")
        ...
        $MODEL.set_password($VAR)
        ...
        $MODEL.save(...)
    - pattern: |
        def $F(..., $VAR="", ...):
          ...
          $MODEL.set_password($VAR)
  fix-regex:
    regex: (def.*|request.*)(""|'')
    replacement: \1None
  languages:
  - python
  severity: ERROR
- id: python.flask.security.dangerous-template-string.dangerous-template-string
  patterns:
  - pattern-either:
    - pattern: |
        $V = "...".format(...)
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = "...".format(...)
        ...
        return flask.render_template_string($V, ...), $MORE
    - pattern: |
        $V = "..." % $S
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = "..." % $S
        ...
        return flask.render_template_string($V, ...), $MORE
    - pattern: |
        $V = "..."
        ...
        $V += $O
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = "..."
        ...
        $V += $O
        ...
        return flask.render_template_string($V, ...), $MORE
    - pattern: |
        $V = f"...{$X}..."
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = f"...{$X}..."
        ...
        return flask.render_template_string($V, ...), $CODE
  message: |
    Found a template created with string formatting.
    This is susceptible to server-side template injection
    and cross-site scripting attacks.
  metadata:
    cwe: 'CWE-96: Improper Neutralization of Directives in Statically Saved Code (''Static
      Code Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html
    - https://pequalsnp-team.github.io/cheatsheet/flask-jinja2-ssti
  languages:
  - python
  severity: ERROR
- id: python.flask.security.injection.os-system-injection.os-system-injection
  languages:
  - python
  severity: ERROR
  message: User data detected in os.system. This could be vulnerable to a command
    injection and should be avoided. If this must be done, use the 'subprocess' module
    instead and pass the arguments as a list.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Command_Injection
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: os.system(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            os.system(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: os.system(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: os.system(..., <... flask.request.$W[...] ...>, ...)
        - pattern: os.system(..., <... flask.request.$W(...) ...>, ...)
        - pattern: os.system(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
              os.system(<... $INTERM ...>)
          - pattern: os.system(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
              os.system(<... $INTERM ...>)
          - pattern: os.system(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
              os.system(<... $INTERM ...>)
          - pattern: os.system(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
              os.system(<... $INTERM ...>)
          - pattern: os.system(...)
- id: python.flask.security.injection.path-traversal-open.path-traversal-open
  languages:
  - python
  severity: ERROR
  message: Found request data in a call to 'open'. Ensure the request data is validated
    or sanitized, otherwise it could result in path traversal attacks.
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Path_Traversal
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: open(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            open(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: open(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: open(..., <... flask.request.$W[...] ...>, ...)
        - pattern: open(..., <... flask.request.$W(...) ...>, ...)
        - pattern: open(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
              open(<... $INTERM ...>, ...)
          - pattern: open(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
              open(<... $INTERM ...>, ...)
          - pattern: open(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
              open(<... $INTERM ...>, ...)
          - pattern: open(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
              open(<... $INTERM ...>, ...)
          - pattern: open(...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
              with open(<... $INTERM ...>, ...) as $F:
                ...
          - pattern: open(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
              with open(<... $INTERM ...>, ...) as $F:
                ...
          - pattern: open(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
              with open(<... $INTERM ...>, ...) as $F:
                ...
          - pattern: open(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
              with open(<... $INTERM ...>, ...) as $F:
                ...
          - pattern: open(...)
- id: python.flask.security.injection.ssrf-requests.ssrf-requests
  languages:
  - python
  severity: ERROR
  message: Data from request object is passed to a new server-side request. This could
    lead to a server-side request forgery (SSRF). To mitigate, ensure that schemes
    and hosts are validated against an allowlist, do not forward the response to the
    user, and ensure proper authentication and transport-layer security in the proxied
    request.
  metadata:
    cwe: 'CWE-918: Server-Side Request Forgery (SSRF)'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $ROUTE_FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: requests.$FUNC(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            requests.$FUNC(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: requests.$FUNC(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: requests.$FUNC(..., <... flask.request.$W[...] ...>, ...)
        - pattern: requests.$FUNC(..., <... flask.request.$W(...) ...>, ...)
        - pattern: requests.$FUNC(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
              requests.$FUNC(<... $INTERM ...>, ...)
          - pattern: requests.$FUNC(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
              requests.$FUNC(<... $INTERM ...>, ...)
          - pattern: requests.$FUNC(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
              requests.$FUNC(<... $INTERM ...>, ...)
          - pattern: requests.$FUNC(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
              requests.$FUNC(<... $INTERM ...>, ...)
          - pattern: requests.$FUNC(...)
- id: python.flask.security.injection.user-eval.eval-injection
  languages:
  - python
  severity: ERROR
  message: Detected user data flowing into eval. This is code injection and should
    be avoided.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: eval(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            eval(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: eval(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: eval(..., <... flask.request.$W[...] ...>, ...)
        - pattern: eval(..., <... flask.request.$W(...) ...>, ...)
        - pattern: eval(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
              eval(..., <... $INTERM ...>, ...)
          - pattern: eval(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
              eval(..., <... $INTERM ...>, ...)
          - pattern: eval(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
              eval(..., <... $INTERM ...>, ...)
          - pattern: eval(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
              eval(..., <... $INTERM ...>, ...)
          - pattern: eval(...)
- id: python.flask.security.injection.user-exec.exec-injection
  languages:
  - python
  severity: ERROR
  message: Detected user data flowing into exec. This is code injection and should
    be avoided.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/exec_really_is_dangerous.html
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: exec(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            exec(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: exec(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: exec(..., <... flask.request.$W[...] ...>, ...)
        - pattern: exec(..., <... flask.request.$W(...) ...>, ...)
        - pattern: exec(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
              exec(..., <... $INTERM ...>, ...)
          - pattern: exec(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
              exec(..., <... $INTERM ...>, ...)
          - pattern: exec(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
              exec(..., <... $INTERM ...>, ...)
          - pattern: exec(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
              exec(..., <... $INTERM ...>, ...)
          - pattern: exec(...)
- id: python.flask.security.insecure-deserialization.insecure-deserialization
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
  message: |
    Detected the use of an insecure deserizliation library in a Flask route. These libraries
    are prone to code execution vulnerabilities. Ensure user data does not enter this function.
    To fix this, try to avoid serializing whole objects. Consider instead using a serializer
    such as JSON.
  languages:
  - python
  severity: ERROR
  patterns:
  - pattern-inside: |
      @app.route(...)
      def $X(...):
        ...
  - pattern-not: $MODULE.$FUNC("...")
  - pattern-not: $MODULE.$FUNC(open("...", ...))
  - pattern-either:
    - pattern: pickle.$FUNC(...)
    - pattern: _pickle.$FUNC(...)
    - pattern: cPickle.$FUNC(...)
    - pattern: dill.$FUNC(...)
    - pattern: shelve.$FUNC(...)
    - pattern: yaml.load(...)
- id: python.jinja2.security.audit.autoescape-disabled.autoescape-disabled
  patterns:
  - pattern-not: jinja2.Environment(..., autoescape=True, ...)
  - pattern-not: jinja2.Environment(..., autoescape=jinja2.select_autoescape(...),
      ...)
  - pattern: jinja2.Environment(...)
  fix-regex:
    regex: (.*)\)
    replacement: \1, autoescape=True)
  message: Detected a Jinja2 environment without autoescaping. Jinja2 does not autoescape
    by default. This is dangerous if you are rendering to a browser because this allows
    for cross-site scripting (XSS) attacks. If you are in a web context, enable autoescaping
    by setting 'autoescape=True.' You may also consider using 'jinja2.select_autoescape()'
    to only enable automatic escaping for certain file extensions.
  metadata:
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://jinja.palletsprojects.com/en/2.11.x/api/#basics
  languages:
  - python
  severity: WARNING
- id: python.lang.correctness.common-mistakes.default-mutable-dict.default-mutable-dict
  patterns:
  - pattern-either:
    - patterns:
      - pattern: |
          def $F(..., $D={}, ...):
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {}
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict(...)
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D.copy()
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.copy($D)
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict.copy($D)
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {... for ... in ...}
            ...
            $D[...] = ...
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D or {}
            ...
            $D[...] = ...
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D={}, ...):
              ...
              $D[...] = ...
    - patterns:
      - pattern: |
          def $F(..., $D={}, ...):
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {}
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict(...)
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D.copy()
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.copy($D)
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict.copy($D)
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {... for ... in ...}
            ...
            $D.update(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D or {}
            ...
            $D.update(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D={}, ...):
              ...
              $D.update(...)
    - patterns:
      - pattern: |
          def $F(..., $D={}, ...):
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {}
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict(...)
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D.copy()
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = copy.copy($D)
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = dict.copy($D)
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = {... for ... in ...}
            ...
            $D.setdefault(...)
      - pattern-not: |
          def $F(..., $D={}, ...):
            ...
            $D = $D or {}
            ...
            $D.setdefault(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D={}, ...):
              ...
              $D.setdefault(...)
  message: 'Function $F mutates default dict $D. Python only instantiates default
    function arguments once and shares the instance across the function calls. If
    the default function argument is mutated, that will modify the instance used by
    all future function calls. This can cause unexpected results, or lead to security
    vulnerabilities whereby one function consumer can view or modify the data of another
    function consumer. Instead, use a default argument (like None) to indicate that
    no argument was provided and instantiate a new dictionary at that time. For example:
    `if $D is None: $D = {}`.'
  languages:
  - python
  severity: ERROR
- id: python.lang.correctness.common-mistakes.default-mutable-list.default-mutable-list
  patterns:
  - pattern-either:
    - patterns:
      - pattern: |
          def $F(..., $D=[], ...):
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = []
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [...]
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list(...)
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.copy($D)
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list.copy($D)
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D[:]
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [... for ... in ...]
            ...
            $D.append(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D or []
            ...
            $D.append(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D=[], ...):
              ...
              $D.append(...)
    - patterns:
      - pattern: |
          def $F(..., $D=[], ...):
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = []
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [...]
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list(...)
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.copy($D)
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list.copy($D)
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D[:]
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [... for ... in ...]
            ...
            $D.extend(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D or []
            ...
            $D.extend(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D=[], ...):
              ...
              $D.extend(...)
    - patterns:
      - pattern: |
          def $F(..., $D=[], ...):
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = []
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [...]
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list(...)
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.deepcopy($D)
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = copy.copy($D)
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = list.copy($D)
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D[:]
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = [... for ... in ...]
            ...
            $D.insert(...)
      - pattern-not: |
          def $F(..., $D=[], ...):
            ...
            $D = $D or []
            ...
            $D.insert(...)
      - pattern-not-inside: |
          def $A(...):
            ...
            def $F(..., $D=[], ...):
              ...
              $D.insert(...)
  message: 'Function $F mutates default list $D. Python only instantiates default
    function arguments once and shares the instance across the function calls. If
    the default function argument is mutated, that will modify the instance used by
    all future function calls. This can cause unexpected results, or lead to security
    vulnerabilities whereby one function consumer can view or modify the data of another
    function consumer. Instead, use a default argument (like None) to indicate that
    no argument was provided and instantiate a new list at that time. For example:
    `if $D is None: $D = []`.'
  languages:
  - python
  severity: ERROR
- id: python.lang.correctness.common-mistakes.is-comparison-string.string-is-comparison
  patterns:
  - pattern-not: $S is None
  - pattern-not: type($X) is $T
  - pattern-not: $S is True
  - pattern-not: $S is False
  - pattern-not: $S is ""
  - pattern-either:
    - pattern: $S is "..."
    - pattern: '"..." is $S'
  message: |
    Found string comparison using 'is' operator. The 'is' operator
    is for reference equality, not value equality, and therefore should
    not be used to compare strings. For more information, see
    https://github.com/satwikkansal/wtfpython#-how-not-to-use-is-operator"
  languages:
  - python
  severity: ERROR
- id: python.lang.correctness.common-mistakes.is-not-is-not.is-not-is-not
  patterns:
  - pattern: $S is (not ...)
  message: In python 'X is not ...' is different from 'X is (not ...)'. In the latter
    the 'not' converts the '...' directly to boolean.
  languages:
  - python
  severity: ERROR
- id: python.lang.correctness.dict-modify-iterating.dict-del-while-iterate
  patterns:
  - pattern-either:
    - pattern: |
        for $KEY, $VALUE in $DICT.items():
            ...
            del $DICT[$KEY]
    - pattern: |
        for $KEY in $DICT.keys():
            ...
            del $DICT[$KEY]
  message: 'It appears that `$DICT[$KEY]` is a dict with items being deleted while
    in a for loop. This is usually a bad idea and will likely lead to a RuntimeError:
    dictionary changed size during iteration'
  languages:
  - python
  severity: WARNING
- id: python.lang.correctness.list-modify-iterating.list-modify-while-iterate
  patterns:
  - pattern-either:
    - pattern: |
        for $ELEMENT in $LIST:
          ...
          $LIST.pop(...)
    - pattern: |
        for $ELEMENT in $LIST:
          ...
          $LIST.push(...)
    - pattern: |
        for $ELEMENT in $LIST:
          ...
          $LIST.append(...)
    - pattern: |
        for $ELEMENT in $LIST:
          ...
          $LIST.extend(...)
  message: |
    It appears that `$LIST` is a list that is being modified while in a for loop.
    This will likely cause a runtime error or an infinite loop.
  languages:
  - python
  severity: ERROR
- id: python.lang.correctness.return-in-init.return-in-init
  patterns:
  - pattern-inside: |
      class A(...):
          ...
          def __init__(...):
              ...
  - pattern: return ...
  message: '`return` should never appear inside a class __init__ function. This will
    cause a runtime error.'
  languages:
  - python
  severity: ERROR
- id: python.lang.correctness.return-in-init.yield-in-init
  patterns:
  - pattern-inside: |
      class $A(...):
          ...
  - pattern-inside: |
      def __init__(...):
          ...
  - pattern-either:
    - pattern: |
        yield ...
    - pattern: |
        yield
  message: '`yield` should never appear inside a class __init__ function. This will
    cause a runtime error.'
  languages:
  - python
  severity: ERROR
- id: python.lang.correctness.tempfile.flush.tempfile-without-flush
  pattern-either:
  - patterns:
    - pattern-not-inside: |
        $F = tempfile.NamedTemporaryFile(...)
        ...
        $F.write(...)
        ...
        $F.flush()
        ...
        $F.name
    - pattern-not-inside: |
        $F = tempfile.NamedTemporaryFile(...)
        ...
        $F.write(...)
        ...
        $F.close()
        ...
        $F.name
    - pattern-not-inside: |
        $F = tempfile.NamedTemporaryFile(..., delete=False, ...)
        ...
        $F.close()
        ...
        $F.name
    - pattern-inside: |
        $F = tempfile.NamedTemporaryFile(...)
        ...
    - pattern: |
        $F.name
  - patterns:
    - pattern-not-inside: |
        with tempfile.NamedTemporaryFile(...) as $F:
            ...
            $F.write(...)
            ...
            $F.flush()
            ...
            $F.name
    - pattern-not-inside: |
        with tempfile.NamedTemporaryFile(...) as $F:
            ...
            $F.write(...)
            ...
            $F.close()
            ...
            $F.name
    - pattern-inside: |
        with tempfile.NamedTemporaryFile(...) as $F:
            ...
    - pattern: |
        $F.name
  message: Using '$F.name' without '.flush()' or '.close()' may cause an error because
    the file may not exist when '$F.name' is used. Use '.flush()' or close the file
    before using '$F.name'.
  languages:
  - python
  severity: ERROR
- id: python.lang.correctness.useless-comparison.no-strings-as-booleans
  patterns:
  - pattern-either:
    - pattern: |
        if <... "..." and ... ...>:
            ...
    - pattern: |
        if <... "..." or ... ...>:
            ...
    - patterns:
      - pattern-not: |
          if $X in "...":
            ...
      - pattern: |
          if "...":
              ...
  message: |
    Using strings as booleans in Python has unexpected results.
    `"one" and "two"` will return "two".
    `"one" or "two"` will return "one".
     In Python, strings are truthy, and strings with a non-zero length evaluate to True.
  languages:
  - python
  severity: ERROR
- id: python.lang.correctness.useless-eqeq.useless-eqeq
  patterns:
  - pattern-not-inside: |
      def __eq__(...):
          ...
  - pattern-not-inside: |
      def __cmp__(...):
          ...
  - pattern-not-inside: assert(...)
  - pattern-not-inside: assert ...
  - pattern-not-inside: assert ..., ...
  - pattern-not-inside: assertTrue(...)
  - pattern-not-inside: assertFalse(...)
  - pattern-either:
    - pattern: $X == $X
    - pattern: $X != $X
  - pattern-not: 1 == 1
  message: 'This expression is always True: `$X == $X` or `$X != $X`. If testing for
    floating point NaN, use `math.isnan($X)`, or `cmath.isnan($X)` if the number is
    complex.'
  languages:
  - python
  severity: ERROR
- id: python.lang.maintainability.useless-ifelse.useless-if-conditional
  patterns:
  - pattern-either:
    - pattern: |
        if $X:
            ...
        elif $X:
            ...
  message: if block checks for the same condition on both branches (`$X`)
  languages:
  - python
  severity: WARNING
- id: python.lang.maintainability.useless-literal.useless-literal-dict
  patterns:
  - pattern-either:
    - pattern: |
        {..., $X: $A, ..., $X: $B, ...}
    - pattern: |
        dict(..., ($X, $A), ..., ($X, $B), ...)
  message: key `$X` is uselessly assigned twice
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.weak-ssl-version.weak-ssl-version
  patterns:
  - pattern-either:
    - pattern: ssl.PROTOCOL_SSLv2
    - pattern: ssl.PROTOCOL_SSLv3
    - pattern: ssl.PROTOCOL_TLSv1
    - pattern: ssl.PROTOCOL_TLSv1_1
    - pattern: pyOpenSSL.SSL.SSLv2_METHOD
    - pattern: pyOpenSSL.SSL.SSLv23_METHOD
    - pattern: pyOpenSSL.SSL.SSLv3_METHOD
    - pattern: pyOpenSSL.SSL.TLSv1_METHOD
    - pattern: pyOpenSSL.SSL.TLSv1_1_METHOD
  message: |
    An insecure SSL version was detected. TLS versions 1.0, 1.1, and all SSL versions
    are considered weak encryption and are deprecated.
    Use 'ssl.PROTOCOL_TLSv1_2' or higher.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/insecure_ssl_tls.py#L30
    references:
    - https://tools.ietf.org/html/rfc7568
    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
    - https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLSv1_2
  languages:
  - python
  severity: WARNING
- id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  pattern: hashlib.md5(...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  pattern: hashlib.sha1(...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.lang.security.unquoted-csv-writer.unquoted-csv-writer
  patterns:
  - pattern-not: csv.writer(..., quoting=csv.QUOTE_ALL, ...)
  - pattern: csv.writer(...)
  message: Found an unquoted CSV writer. This is susceptible to injection. Use 'quoting=csv.QUOTE_ALL'.
  metadata:
    cwe: 'CWE-1236: Improper Neutralization of Formula Elements in a CSV File'
    owasp: 'A1: Injection'
    references:
    - https://affinity-it-security.com/how-to-prevent-csv-injection/
  fix-regex:
    regex: (.*)\)
    replacement: \1, quoting=csv.QUOTE_ALL)
  languages:
  - python
  severity: ERROR
- id: python.lang.security.unverified-ssl-context.unverified-ssl-context
  pattern: ssl._create_unverified_context(...)
  message: |
    Unverified SSL context detected. This will permit insecure connections without verifying
    SSL certificates. Use 'ssl.create_default_context()' instead.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-295: Improper Certificate Validation'
    references:
    - https://docs.python.org/3/library/ssl.html#ssl-security
    - https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
  severity: ERROR
  languages:
  - python
- id: python.lang.security.use-defused-xml.use-defused-xml
  pattern-either:
  - pattern: import xml
  fix-regex:
    regex: xml
    replacement: defusedxml
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    references:
    - https://docs.python.org/3/library/xml.html
    - https://github.com/tiran/defusedxml
  message: |
    Found use of the native Python XML libraries, which is vulnerable to XML external entity (XXE)
    attacks. The Python documentation recommends the 'defusedxml' library instead. Use 'defusedxml'.
    See https://github.com/tiran/defusedxml for more information.
  languages:
  - python
  severity: ERROR
- id: python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc
  pattern-either:
  - pattern: import xmlrpclib
  - pattern: import SimpleXMLRPCServer
  - pattern: import xmlrpc
  message: |
    Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities.
    Use defusedxml.xmlrpc instead.
  metadata:
    cwe: 'CWE-776: Improper Restriction of Recursive Entity References in DTDs (''XML
      Entity Expansion'')'
    owasp: 'A4: XML External Entities (XXE)'
    source-rule-url: https://github.com/PyCQA/bandit/blob/07f84cb5f5e7c1055e6feaa0fe93afa471de0ac3/bandit/blacklists/imports.py#L160
    references:
    - https://pypi.org/project/defusedxml/
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities
  severity: ERROR
  languages:
  - python
- id: python.lang.security.audit.logging.listeneval.listen-eval
  languages:
  - python
  message: |
    Because portions of the logging configuration are passed through eval(),
    use of this function may open its users to a security risk. While the
    function only binds to a socket on localhost, and so does not accept
    connections from remote machines, there are scenarios where untrusted
    code could be run under the account of the process which calls listen().
    See more details at https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
  patterns:
  - pattern: logging.config.listen(...)
  severity: WARNING
- id: python.lang.security.audit.logging.logger-credential-leak.python-logger-credential-disclosure
  patterns:
  - pattern: |
      logger.$LOGGER_CALL($FORMAT_STRING,...)
  - metavariable-regex:
      metavariable: $LOGGER_CALL
      regex: (info|error|exception)
  - metavariable-regex:
      metavariable: $FORMAT_STRING
      regex: (?i).*(api.key|secret|credential|token).*\%s.*
  message: |
    Logger call may be exposing a secret credential in $FORMAT_STRING
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-blowfish
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.Blowfish.new(...)
    - pattern: Crypto.Cipher.Blowfish.new(...)
  message: |
    Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-des
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.DES.new(...)
    - pattern: Crypto.Cipher.DES.new(...)
  message: |
    Detected DES cipher algorithm which is considered insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://tools.ietf.org/html/rfc5469
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc2
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.ARC2.new(...)
    - pattern: Crypto.Cipher.ARC2.new
  message: |
    Detected RC2 cipher algorithm which is considered insecure. The algorithm has known vulnerabilities and is difficult to use securely. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://security.stackexchange.com/questions/93924/is-rc2-cbc-at-all-secure
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc4
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.ARC4.new(...)
    - pattern: Crypto.Cipher.ARC4.new(...)
  message: |
    Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-xor
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.XOR.new(...)
    - pattern: Crypto.Cipher.XOR.new(...)
  message: |
    Detected XOR cipher algorithm which is considered insecure. This algorithm
    is not cryptographically secure and can be reversed easily. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md2
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD2.new(...)
    - pattern: Cryptodome.Hash.MD2.new (...)
  message: |
    Detected MD2 hash algorithm which is considered insecure. This algorithm
    has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6149
    - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2409
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md4
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD4.new(...)
    - pattern: Cryptodome.Hash.MD4.new (...)
  message: |
    Detected MD4 hash algorithm which is considered insecure. This algorithm
    has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6150
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md5
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD5.new(...)
    - pattern: Cryptodome.Hash.MD5.new (...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-sha1
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.SHA.new(...)
    - pattern: Cryptodome.Hash.SHA.new (...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.requests.security.disabled-cert-validation.disabled-cert-validation
  patterns:
  - pattern-either:
    - pattern: requests.put(..., verify=False, ...)
    - pattern: requests.patch(..., verify=False, ...)
    - pattern: requests.delete(..., verify=False, ...)
    - pattern: requests.head(..., verify=False, ...)
    - pattern: requests.options(..., verify=False, ...)
    - pattern: requests.request(..., verify=False, ...)
    - pattern: requests.get(..., verify=False, ...)
    - pattern: requests.post(..., verify=False, ...)
  message: |
    Certificate verification has been explicitly disabled. This
    permits insecure connections to insecure servers. Re-enable
    certification validation.
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://stackoverflow.com/questions/41740361/is-it-safe-to-disable-ssl-certificate-verification-in-pythonss-requests-lib
  languages:
  - python
  severity: ERROR
- id: python.requests.security.no-auth-over-http.no-auth-over-http
  patterns:
  - pattern-either:
    - pattern: requests.$W("=~/http:\/\/.*/", ..., auth=$X, ...)
    - pattern: |
        $URL = "=~/http:\/\/.../"
        ...
        requests.$W($URL, ..., auth=$X, ...)
  fix-regex:
    regex: http:\/\/
    replacement: https://
    count: 1
  message: |
    Authentication detected over HTTP. HTTP does not provide any
    encryption or protection for these authentication credentials.
    This may expose these credentials to unauthhorized parties.
    Use 'https://' instead.
  metadata:
    cwe: 'CWE-523: Unprotected Transport of Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://pypi.org/project/flake8-flask/
    references:
    - https://blog.r2c.dev/2020/bento-check-no-auth-over-http/
    - https://bento.dev/checks/requests/no-auth-over-http/
  languages:
  - python
  severity: ERROR
- id: python.sqlalchemy.security.sqlalchemy-sql-injection.sqlalchemy-sql-injection
  patterns:
  - pattern-either:
    - pattern: |
        def $FUNC(...,$VAR,...):
          ...
          $SESSION.query(...).$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
    - pattern: |
        def $FUNC(...,$VAR,...):
          ...
          $SESSION.query.join(...).$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
    - pattern: |
        def $FUNC(...,$VAR,...):
          ...
          $SESSION.query.$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
    - pattern: |
        def $FUNC(...,$VAR,...):
          ...
          query.$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
  - metavariable-regex:
      metavariable: $SQLFUNC
      regex: (group_by|order_by|distinct|having|filter)
  - metavariable-regex:
      metavariable: $FORMATFUNC
      regex: (?!bindparams)
  message: |
    Distinct, Having, Group_by, Order_by, and Filter in SQLAlchemy can cause sql injections
    if the developer inputs raw SQL into the before-mentioned clauses.
    This pattern captures relevant cases in which the developer inputs raw SQL into the distinct, having, group_by, order_by or filter clauses and
    injects user-input into the raw SQL with any function besides "bindparams". Use bindParams to securely bind user-input
    to SQL statements.
  fix-regex:
    regex: format
    replacement: bindparams
  languages:
  - python
  severity: WARNING
- id: ruby.jwt.security.jwt-exposed-credentials.ruby-jwt-exposed-credentials
  languages:
  - ruby
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern: |
      $PAYLOAD = {...,password:...,...}
      ...
      JWT.encode($PAYLOAD,...)
  severity: ERROR
- id: ruby.jwt.security.jwt-none-alg.ruby-jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  languages:
  - ruby
  severity: ERROR
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern: |
      JWT.encode($PAYLOAD, $SECRET, 'none', ...)
- id: ruby.jwt.security.jwt-hardcode.ruby-jwt-hardcoded-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  patterns:
  - pattern-inside: |
      require 'jwt'
      ...
  - pattern-either:
    - pattern: |
        JWT.encode($PAYLOAD,"...",...)
    - pattern: |
        JWT.decode($PAYLOAD,"...",...)
    - pattern: |
        JWT.encode($PAYLOAD,nil,...)
    - pattern: |
        JWT.decode($PAYLOAD,nil,...)
    - pattern: |
        $SECRET = "..."
        ...
        JWT.encode($PAYLOAD,$SECRET,...)
    - pattern: |
        $SECRET = "..."
        ...
        JWT.decode($PAYLOAD,$SECRET,...)
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.ssl-mode-no-verify.ssl-mode-no-verify
  pattern: OpenSSL::SSL::VERIFY_NONE
  message: |
    Detected SSL that will accept an unverified connection.
    This makes the connections susceptible to man-in-the-middle attacks.
    Use 'OpenSSL::SSL::VERIFY_PEER' intead.
  fix-regex:
    regex: VERIFY_NONE
    replacement: VERIFY_PEER
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.hardcoded-http-auth-in-controller.hardcoded-http-auth-in-controller
  pattern: |
    class $CONTROLLER < ApplicationController
      ...
      http_basic_authenticate_with ..., :password => "...", ...
    end
  message: |
    Detected hardcoded password used in basic authentication in a controller
    class. Including this password in version control could expose this
    credential. Consider refactoring to use environment variables or
    configuration files.
  severity: ERROR
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/basic_auth/index.markdown
  languages:
  - ruby
- id: ruby.lang.security.filter-skipping.filter-skipping
  patterns:
  - pattern-not: |
      $CALL "=~/.*(/:action.*).*/", $ACTION
  - pattern: |
      $CALL "=~/.*(/:action.*).*/"
  message: |
    Checks for use of action in Ruby routes. This can cause Rails to render an arbitrary view if an
    attacker creates an URL accurately. Affects 3.0 applications. Can avoid the vulnerability by providing
    additional constraints.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_filter_skipping.rb
    - https://groups.google.com/g/rubyonrails-security/c/NCCsca7TEtY
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.missing-csrf-protection.missing-csrf-protection
  patterns:
  - pattern: |
      class $CONTROLLER < ActionController::Base
        ...
      end
  - pattern-not: |
      class $CONTROLLER < ActionController::Base
        ...
        protect_from_forgery :with => :exception
      end
  - pattern-not: |
      class $CONTROLLER < ActionController::Base
        ...
        protect_from_forgery prepend: true, with: :exception
      end
  message: |
    Detected controller which does not enable cross-site request forgery
    protections using 'protect_from_forgery'. Add
    'protect_from_forgery :with => :exception' to your controller class.
  severity: ERROR
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross-site_request_forgery/index.markdown
  languages:
  - ruby
- id: ruby.lang.security.bad-deserialization.bad-deserialization
  patterns:
  - pattern-either:
    - pattern: |
        YAML.load(...)
    - pattern: |
        CSV.load(...)
    - pattern: |
        Marshal.load(...)
    - pattern: |
        Marshal.restore(...)
    - pattern: |
        $OBJ.object_load(...)
  - pattern-not: |
      YAML.load(..., safe: true, ...)
  message: |
    Checks for unsafe deserialization. Objects in Ruby can be serialized into strings,
    then later loaded from strings. However, uses of load and object_load can cause remote code execution.
    Loading user input with YAML, MARSHAL, or CSV can potentially be dangerous. Use JSON securely instead.
  metadata:
    references:
    - https://groups.google.com/g/rubyonrails-security/c/61bkgvnSGTQ/m/nehwjA8tQ8EJ
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_deserialize.rb
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.force-ssl-false.force-ssl-false
  patterns:
  - pattern: |
      config.force_ssl = false
  message: |
    Checks for configuration setting of force_ssl to false. Force_ssl forces usage of HTTPS, which
    could lead to network interception of unencrypted application traffic. To fix, set config.force_ssl = true.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_force_ssl.rb
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.mass-assignment-protection-disabled.mass-assignment-protection-disabled
  pattern: $MODEL.new(params[...], ..., :without_protection => true, ...)
  message: |
    Mass assignment protection disabled for '$MODEL'. This could
    permit assignment to sensitive model fields without intention. Instead,
    use 'attr_accessible' for the model or disable mass assigment using
    'config.active_record.whitelist_attributes = true'.
    ':without_protection => true' must be removed for this to take effect.
  metadata:
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/mass_assignment/index.markdown
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.file-disclosure.file-disclosure
  patterns:
  - pattern: |
      config.serve_static_assets = true
  message: |
    Special requests can determine whether a file exists on a filesystem that's outside the Ruby app's
    root directory. To fix this, set config.serve_static_assets = false.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_file_disclosure.rb
    - https://groups.google.com/g/rubyonrails-security/c/23fiuwb1NBA/m/MQVM1-5GkPMJ
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.jruby-xml.jruby-xml
  patterns:
  - pattern: |
      XmlMini.backend = $STR
  - pattern-not: |
      XmlMini.backend = "REXML"
  message: |
    The JDOM backend for XmlMini has a vulnerability that lets an attacker perform a denial of service attack
    or gain access to files on the application server. This affects versions 3.0, but is fixed in versions
    3.1.12 and 3.2.13. To fix, either upgrade or use XmlMini.backend="REXML".
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_jruby_xml.rb
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.yaml-parsing.yaml-parsing
  patterns:
  - pattern: ActionController::Base.param_parsers[Mime::YAML] = :yaml
  message: |
    Detected enabled YAML parsing. This is vulnerable to remote code execution in Rails 2.x
    versions up to 2.3.14. To fix, delete this line.
  fix-regex:
    regex: ActionController.*:yaml
    replacement: ' '
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.json-entity-escape.json-entity-escape
  pattern-either:
  - pattern: |
      ActiveSupport.escape_html_entities_in_json = false
  - pattern: |
      config.active_support.escape_html_entities_in_json = false
  message: |
    Checks if HTML escaping is globally disabled for JSON output. This could lead to XSS.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_json_entity_escape.rb
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.divide-by-zero.divide-by-zero
  patterns:
  - pattern-either:
    - pattern: |
        $X / 0
    - pattern: |
        $ZERO = 0
        ...
        $X / $ZERO
  message: |
    Checks for divide by zero. Best practice involves not dividing a variable by zero, as this leads to a Ruby
    ZeroDivisionError.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_divide_by_zero.rb
  languages:
  - ruby
  severity: WARNING
- id: ruby.rails.security.audit.xss.templates.alias-for-html-safe.alias-for-html-safe
  message: ''
  metadata:
    references:
    - https://medium.com/sumone-technical-blog/a-pretty-way-to-unescape-html-in-a-ruby-on-rails-application-efc22b850027
    - https://stackoverflow.com/questions/4251284/raw-vs-html-safe-vs-h-to-unescape-html#:~:text===
  languages:
  - none
  paths:
    include:
    - '*.erb'
  severity: WARNING
  pattern-regex: <%==.*?%>
- id: typescript.react.security.react-controlled-component-password.react-controlled-component-password
  pattern-either:
  - pattern: <$EL type="password" value={this.state.$X} onChange=...  />
  - pattern: |
      React.createElement($EL,{type: 'password', value: this.state.$X, onChange:...},...)
  - pattern: |
      $PARAMS = {type: 'password', value: this.state.$X, onChange:...};
      ...
      React.createElement($EL,$PARAMS,...);
  message: |
    Password can be leaked if CSS injection exists on the page.
  metadata:
    references:
    - https://no-csp-css-keylogger.badsite.io/
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.react-markdown-insecure-html.react-markdown-insecure-html
  patterns:
  - pattern-either:
    - pattern-inside: |
        $X = require('react-markdown/with-html');
        ...
    - pattern-inside: |
        $X = require('react-markdown');
        ...
    - pattern-inside: |
        import 'react-markdown/with-html';
        ...
    - pattern-inside: |
        import 'react-markdown';
        ...
  - pattern-either:
    - pattern: |
        <$EL allowDangerousHtml />
    - pattern: |
        <$EL transformLinkUri=... />
    - pattern: |
        <$EL transformImageUri=... />
  message: |
    Overwriting `transformLinkUri` or `transformImageUri` to something insecure or turning `allowDangerousHtml` on, will open code up to XSS vectors.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://www.npmjs.com/package/react-markdown#security
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-dangerouslysetinnerhtml.react-dangerouslysetinnerhtml
  pattern-either:
  - pattern: |
      <$X dangerouslySetInnerHTML=... />
  - pattern: |
      {dangerouslySetInnerHTML: ...}
  message: "Setting HTML from code is risky because it\u2019s easy to inadvertently
    expose your users to a cross-site scripting (XSS) attack.\n"
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-css-injection.react-css-injection
  patterns:
  - pattern-either:
    - pattern-inside: |
        import $STYLE from "...";
        ...
    - pattern-inside: |
        $STYLE = $METHOD(...);
        ...
    - pattern-inside: |
        function $FUNC(...,{$STYLE},...) {
          ...
        }
    - pattern-inside: |
        function $FUNC(...,$STYLE,...) {
          ...
        }
  - pattern-inside: |
      <$EL style={$STYLE} />
  - pattern-not-inside: |
      <$EL style={{$X:...}} />
  - pattern: $STYLE
  message: |
    User controlled data in a `style` attribute is an anti-pattern than can lead to XSS vulnerabilities
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: generic.dockerfile.correctness.alias-must-be-unique.alias-must-be-unique
  severity: ERROR
  languages:
  - generic
  patterns:
  - pattern-either:
    - pattern: |
        FROM ... as $REF
        ...
        ...
        FROM ... as $REF
    - pattern: |
        FROM ... AS $REF
        ...
        ...
        FROM ... AS $REF
  - pattern-not-inside: |
      FROM ... as $REF
      ...
      ...
      FROM ... as $REF-
  - pattern-not-inside: |
      FROM ... AS $REF
      ...
      ...
      FROM ... AS $REF-
  paths:
    include:
    - '*dockerfile*'
    - '*Dockerfile*'
  message: Image aliases must have a unique name, and '$REF' is used twice. Use another
    name for '$REF'.
  metadata:
    source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3024
    references:
    - https://github.com/hadolint/hadolint/wiki/DL3024
- id: generic.dockerfile.correctness.copy-from-own-alias.copy-from-own-alias
  severity: ERROR
  languages:
  - generic
  patterns:
  - pattern-either:
    - pattern: |
        FROM $IMAGE:$TAG as $REF
        ...
        COPY --from=$REF
        ...
        FROM
    - pattern: |
        FROM $IMAGE:$TAG AS $REF
        ...
        COPY --from=$REF
        ...
        FROM
  message: COPY instructions cannot copy from its own alias. The '$REF' alias is used
    before switching to a new image. If you meant to switch to a new image, include
    a new 'FROM' statement. Otherwise, remove the '--from=$REF' from the COPY statement.
  metadata:
    source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3023
    references:
    - https://github.com/hadolint/hadolint/wiki/DL3023
  paths:
    include:
    - '*dockerfile*'
    - '*Dockerfile*'
- id: generic.dockerfile.correctness.invalid-port.invalid-port
  patterns:
  - pattern-either:
    - patterns:
      - pattern: EXPOSE $PORT
      - metavariable-comparison:
          metavariable: $PORT
          comparison: $PORT > 65535
    - pattern: EXPOSE -$PORT
  message: Detected an invalid port number. Valid ports are 0 through 65535.
  severity: ERROR
  languages:
  - generic
  metadata:
    source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3011
    references:
    - https://github.com/hadolint/hadolint/wiki/DL3011
  paths:
    include:
    - '*dockerfile*'
    - '*Dockerfile*'
- id: generic.dockerfile.correctness.multiple-cmd-instructions.multiple-cmd-instructions
  severity: ERROR
  languages:
  - generic
  pattern: |
    CMD ...
    ...
    CMD ...
  message: |
    Multiple CMD instructions were found. Only the last one will take effect.
  metadata:
    source-rule-url: https://github.com/hadolint/hadolint/wiki/DL4003
    references:
    - https://github.com/hadolint/hadolint/wiki/DL4003
    - https://kapeli.com/cheat_sheets/Dockerfile.docset/Contents/Resources/Documents/index#//dash_ref_Instructions/Entry/CMD/0
  paths:
    include:
    - '*dockerfile*'
    - '*Dockerfile*'
- id: generic.dockerfile.correctness.multiple-entrypoint-instructions.multiple-entrypoint-instructions
  severity: ERROR
  languages:
  - generic
  pattern: |
    ENTRYPOINT ...
    ...
    ENTRYPOINT ...
  message: |
    Multiple ENTRYPOINT instructions were found. Only the last one will take effect.
  metadata:
    source-rule-url: https://github.com/hadolint/hadolint/wiki/DL4004
    references:
    - https://github.com/hadolint/hadolint/wiki/DL4004
    - https://kapeli.com/cheat_sheets/Dockerfile.docset/Contents/Resources/Documents/index#//dash_ref_Instructions/Entry/ENTRYPOINT/0
  paths:
    include:
    - '*dockerfile*'
    - '*Dockerfile*'
