rules:
  - id: contrib.nodejsscan.eval_yaml_deserialize.yaml_deserialize
    patterns:
      - pattern-inside: |
          require('js-yaml');
          ...
      - pattern: |
          $X.load(...)
    message:
      User controlled data in 'yaml.load()' function can result in Remote Code
      Injection.
    languages:
      - javascript
    severity: ERROR
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
  - id: contrib.nodejsscan.security_electronjs.electron_allow_http
    patterns:
      - pattern-either:
          - pattern: |
              new BrowserWindow({webPreferences: {allowRunningInsecureContent: true}});
          - pattern: |
              var $X = {webPreferences: {allowRunningInsecureContent: true}};
    message:
      Application can load content over HTTP and that makes the app vulnerable
      to Man in the middle attacks.
    languages:
      - javascript
    severity: ERROR
    metadata:
      owasp: "A6: Security Misconfiguration"
      cwe: "CWE-319: Cleartext Transmission of Sensitive Information"
  - id: contrib.nodejsscan.security_electronjs.electron_disable_websecurity
    patterns:
      - pattern-either:
          - pattern: |
              new BrowserWindow({webPreferences: {webSecurity: false}});
          - pattern: |
              var $X = {webPreferences: {webSecurity: false}};
    message:
      Disabling webSecurity will disable the same-origin policy and allows the
      execution of insecure code from any domain.
    languages:
      - javascript
    severity: ERROR
    metadata:
      owasp: "A6: Security Misconfiguration"
      cwe: "CWE-346: Origin Validation Error"
  - id: contrib.nodejsscan.xss_templates.handlebars_noescape
    patterns:
      - pattern: |
          $X.compile(..., {noEscape: true}, ...)
    message:
      Disabling Escaping in Handlebars is not a secure behaviour. This can introduce
      XSS vulnerabilties.
    languages:
      - javascript
    severity: ERROR
    metadata:
      owasp: "A1: Injection"
      cwe:
        "CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page
        (Basic XSS)"
  - id: contrib.nodejsscan.xss_templates.squirrelly_autoescape
    pattern: $X.autoEscaping(false)
    message:
      Handlebars SafeString will not escape the data passed through it. Untrusted
      user input passing through SafeString can cause XSS.
    languages:
      - javascript
    severity: ERROR
    metadata:
      owasp: "A1: Injection"
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
  - id: go.grpc.security.grpc-client-insecure-connection.grpc-client-insecure-connection
    metadata:
      cwe: "CWE-300: Channel Accessible by Non-Endpoint"
      references:
        - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
    message:
      "Found an insecure gRPC connection using 'grpc.WithInsecure()'. This
      creates a connection without encryption to a gRPC server. A malicious attacker
      could tamper with the gRPC message, which could compromise the machine. Instead,
      establish a secure connection with an SSL certificate using the 'grpc.WithTransportCredentials()'
      function. You can create a create credentials using a 'tls.Config{}' struct
      with 'credentials.NewTLS()'. The final fix looks like this: 'grpc.WithTransportCredentials(credentials.NewTLS(<config>))'."
    languages:
      - go
    severity: ERROR
    pattern: $GRPC.Dial($ADDR, ..., $GRPC.WithInsecure(...), ...)
    fix-regex:
      regex: (.*)WithInsecure\(.*?\)
      replacement: \1WithTransportCredentials(credentials.NewTLS(<your_tls_config_here>))
  - id: go.grpc.security.grpc-server-insecure-connection.grpc-server-insecure-connection
    metadata:
      cwe: "CWE-300: Channel Accessible by Non-Endpoint"
      references:
        - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
    message:
      Found an insecure gRPC server without 'grpc.Creds()' or options with credentials.
      This allows for a connection without encryption to this server. A malicious attacker
      could tamper with the gRPC message, which could compromise the machine. Include
      credentials derived from an SSL certificate in order to create a secure gRPC connection.
      You can create credentials using 'credentials.NewServerTLSFromFile("cert.pem",
      "cert.key")'.
    languages:
      - go
    severity: ERROR
    patterns:
      - pattern-not: grpc.NewServer(..., grpc.Creds(...), ...)
      - pattern-not-inside: |
          $OPTS := []grpc.ServerOption{
            ...,
            grpc.Creds(credentials.NewClientTLSFromCert(...)),
            ...,
          }
          grpc.NewServer($OPTS...)
      - pattern-not-inside: |
          $CREDS := credentials.NewClientTLSFromCert(...)
          ...
          $OPTS := []grpc.ServerOption{
            ...,
            $CREDS,
            ...,
          }
          grpc.NewServer($OPTS...)
      - pattern: grpc.NewServer(...)
  - id: go.jwt-go.security.jwt.hardcoded-jwt-key
    metadata:
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A2: Broken Authentication"
    pattern-either:
      - pattern: |
          $X = []byte("...")
          ...
          $Y := $TOKEN.SignedString($X)
      - pattern: |
          $TOKEN.SignedString([]byte("..."))
    message: JWT token is hardcoded
    languages:
      - go
    severity: WARNING
  - id: go.lang.correctness.useless-eqeq.hardcoded-eq-true-or-false
    patterns:
      - pattern-either:
          - pattern: if (true) { ... }
          - pattern: if (false) { ... }
    message: useless if statement, always the same behavior
    languages:
      - go
    severity: ERROR
  - id: go.lang.maintainability.useless-ifelse.useless-if-conditional
    patterns:
      - pattern-either:
          - pattern: |-
              if ($X) {
                  ...
              } else if ($X) {
                  ...
              }
    message: |
      Detected an if block that checks for the same condition on both branches (`$X`)
    languages:
      - go
    severity: WARNING
  - id: go.lang.maintainability.useless-ifelse.useless-if-body
    patterns:
      - pattern: |-
          if ($X) {
              $S
          } else {
              $S
          }
    message: |
      Detected identical if-statement bodies. Is this intentional?
    languages:
      - go
    severity: WARNING
  - id: go.lang.security.audit.crypto.bad_imports.insecure-module-used
    message:
      Detected use of an insecure cryptographic hashing method. This method is
      known to be broken and easily compromised. Use SHA256 or SHA3 instead.
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec
      references:
        - https://godoc.org/golang.org/x/crypto/sha3
    languages:
      - go
    severity: WARNING
    pattern-either:
      - patterns:
          - pattern-inside: |
              import "crypto/md5"
              ...
          - pattern: |
              md5.$FUNC(...)
      - patterns:
          - pattern-inside: |
              import "crypto/des"
              ...
          - pattern: |
              des.$FUNC(...)
      - patterns:
          - pattern-inside: |
              import "crypto/sha1"
              ...
          - pattern: |
              sha1.$FUNC(...)
      - patterns:
          - pattern-inside: |
              import "crypto/rc4"
              ...
          - pattern: |
              rc4.$FUNC(...)
      - patterns:
          - pattern-inside: |
              import "net/http/cgi"
              ...
          - pattern: |
              cgi.$FUNC(...)
  - id: go.lang.security.audit.crypto.insecure_ssh.avoid-ssh-insecure-ignore-host-key
    message: |
      Disabled host key verification detected. This allows man-in-the-middle
      attacks. Use the 'golang.org/x/crypto/ssh/knownhosts' package to do
      host key verification.
      See https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
      to learn more about the problem and how to fix it.
    metadata:
      cwe: "CWE-322: Key Exchange without Entity Authentication"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/securego/gosec
      references:
        - https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
        - https://gist.github.com/Skarlso/34321a230cf0245018288686c9e70b2d
    languages:
      - go
    severity: WARNING
    pattern: ssh.InsecureIgnoreHostKey()
  - id: go.lang.security.audit.crypto.ssl.ssl-v3-is-insecure
    message: |
      SSLv3 is insecure because it has known vulnerabilities.
      Starting with go1.14, SSLv3 will be removed. Instead, use
      'tls.VersionTLS13'.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A9: Using Components with Known Vulnerabilities"
      source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls_config.go
      references:
        - https://golang.org/doc/go1.14#crypto/tls
        - https://www.us-cert.gov/ncas/alerts/TA14-290A
    languages:
      - go
    severity: ERROR
    patterns:
      - pattern: "tls.Config{..., MinVersion: $TLS.VersionSSL30, ...}"
    fix-regex:
      regex: VersionSSL30
      replacement: VersionTLS13
  - id: go.lang.security.audit.crypto.tls.tls-with-insecure-cipher
    message: |
      Detected an insecure CipherSuite via the 'tls' module. This suite is considered weak.
      Use the function 'tls.CipherSuites()' to get a list of good cipher suites.
      See https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
      for why and what other cipher suites to use.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A9: Using Components with Known Vulnerabilities"
      source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls.go
      references:
        - https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
    languages:
      - go
    severity: WARNING
    pattern-either:
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_RC4_128_SHA,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_AES_128_CBC_SHA256,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,...}}
      - pattern: |
          tls.CipherSuite{..., TLS_RSA_WITH_RC4_128_SHA ,...}
      - pattern: |
          tls.CipherSuite{..., TLS_RSA_WITH_AES_128_CBC_SHA256 ,...}
      - pattern: |
          tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_RC4_128_SHA ,...}
      - pattern: |
          tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_RC4_128_SHA ,...}
      - pattern: |
          tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 ,...}
      - pattern: tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 ,...}
  - id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-md5
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    languages:
      - go
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec#available-rules
    pattern-either:
      - pattern: |
          md5.New()
      - pattern: |
          md5.Sum(...)
  - id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-sha1
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    languages:
      - go
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec#available-rules
    pattern-either:
      - pattern: |
          sha1.New()
      - pattern: |
          sha1.Sum(...)
  - id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-DES
    message: |
      Detected DES cipher algorithm which is insecure. The algorithm is
      considered weak and has been deprecated. Use AES instead.
    languages:
      - go
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec#available-rules
    pattern-either:
      - pattern: |
          des.NewTripleDESCipher(...)
      - pattern: |
          des.NewCipher(...)
  - id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-rc4
    message: |
      Detected RC4 cipher algorithm which is insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    languages:
      - go
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec#available-rules
    pattern: rc4.NewCipher(...)
  - id: go.lang.security.audit.net.dynamic-httptrace-clienttrace.dynamic-httptrace-clienttrace
    message: |
      Detected a potentially dynamic ClientTrace. This occurred because semgrep could not
      find a static definition for '$TRACE'. Dynamic ClientTraces are dangerous because
      they deserialize function code to run when certain Request events occur, which could lead
      to code being run without your knowledge. Ensure that your ClientTrace is statically defined.
    metadata:
      cwe: "CWE-913: Improper Control of Dynamically-Managed Code Resources"
      owasp: "A8: Insecure Deserialization"
      references:
        - https://github.com/returntocorp/semgrep-rules/issues/518
    patterns:
      - pattern-not-inside: |
          ...
          &httptrace.ClientTrace { ... }
          ...
      - pattern: httptrace.WithClientTrace($ANY, $TRACE)
    severity: WARNING
    languages:
      - go
  - id: go.lang.security.audit.net.pprof.pprof-debug-exposure
    metadata:
      cwe: "CWE-489: Active Debug Code"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://github.com/securego/gosec#available-rules
      references:
        - https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
    message: |
      The profiling 'pprof' endpoint is automatically exposed on /debug/pprof.
      This could leak information about the server.
      Instead, use `import "net/http/pprof"`. See
      https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
      for more information and mitigation.
    languages:
      - go
    severity: WARNING
    patterns:
      - pattern-inside: |
          import _ "net/http/pprof"
          ...
      - pattern-inside: |
          func $ANY(...) {
            ...
          }
      - pattern-not: http.ListenAndServe("=~/^localhost.*/", ...)
      - pattern-not: http.ListenAndServe("=~/^127[.]0[.]0[.]1.*/", ...)
      - pattern: http.ListenAndServe(...)
  - id: go.lang.security.audit.net.wip-xss-using-responsewriter-and-printf.wip-xss-using-responsewriter-and-printf
    patterns:
      - pattern-inside: |
          func $FUNC(..., $W http.ResponseWriter, ...) {
              ...
          }
      - pattern-inside: |
          ...
          var $T = "..."
          ...
          $W.Write([]byte(fmt.$PRINTF($T, ...)), ...)
      - pattern-either:
          - pattern: |
              $PARAMS = r.URL.Query()
              ...
              $DATA, $ERR := $PARAMS[...]
              ...
              $INTERM = $ANYTHING(..., $DATA, ...)
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
          - pattern: |
              $PARAMS = r.URL.Query()
              ...
              $DATA, $ERR := $PARAMS[...]
              ...
              $INTERM = $DATA[...]
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
          - pattern: |
              $DATA, $ERR := r.URL.Query()[...]
              ...
              $INTERM = $DATA[...]
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
          - pattern: |
              $DATA, $ERR := r.URL.Query()[...]
              ...
              $INTERM = $ANYTHING(..., $DATA, ...)
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
          - pattern: |
              $PARAMS = r.URL.Query()
              ...
              $DATA, $ERR := $PARAMS[...]
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $DATA, ...)))
    message: |
      Found data going from url query parameters into formatted data written to ResponseWriter.
      This could be XSS and should not be done. If you must do this, ensure your data is
      sanitized or escaped.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-Site Scripting ('XSS')"
    severity: WARNING
    languages:
      - go
  - id: go.lang.security.decompression_bomb.potential-dos-via-decompression-bomb
    message:
      Detected a possible denial-of-service via a zip bomb attack. By limiting
      the max bytes read, you can mitigate this attack. `io.CopyN()` can specify a size.
      Refer to https://bomb.codes/ to learn more about this attack and other ways to
      mitigate it.
    severity: WARNING
    languages:
      - go
    patterns:
      - pattern-either:
          - pattern: io.Copy(...)
          - pattern: io.CopyBuffer(...)
      - pattern-either:
          - pattern-inside: |
              gzip.NewReader(...)
              ...
          - pattern-inside: |
              zlib.NewReader(...)
              ...
          - pattern-inside: |
              zlib.NewReaderDict(...)
              ...
          - pattern-inside: |
              bzip2.NewReader(...)
              ...
          - pattern-inside: |
              flate.NewReader(...)
              ...
          - pattern-inside: |
              flate.NewReaderDict(...)
              ...
          - pattern-inside: |
              lzw.NewReader(...)
              ...
          - pattern-inside: |
              tar.NewReader(...)
              ...
          - pattern-inside: |
              zip.NewReader(...)
              ...
          - pattern-inside: |
              zip.OpenReader(...)
              ...
    fix-regex:
      regex: (.*)(Copy|CopyBuffer)\((.*?),(.*?)(\)|,.*\))
      replacement: \1CopyN(\3, \4, 1024*1024*256)
    metadata:
      cwe: "CWE-400: Uncontrolled Resource Consumption"
      source-rule-url: https://github.com/securego/gosec
      references:
        - https://bomb.codes/
        - https://golang.org/pkg/io/#CopyN
        - https://github.com/securego/gosec/blob/master/rules/decompression-bomb.go
  - id: go.lang.security.zip.path-traversal-inside-zip-extraction
    message: File traversal when extracting zip archive
    metadata:
      cwe: |
        CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
      source_rule_url: https://github.com/securego/gosec/issues/205
    languages:
      - go
    severity: WARNING
    patterns:
      - pattern: |-
          reader, $ERR := zip.OpenReader($ARCHIVE)
          ...
          for _, $FILE := range reader.File {
            ...
            path := filepath.Join($TARGET, $FILE.Name)
            ...
          }
  - id: java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal
    metadata:
      owasp: "A1: Injection"
      cwe:
        "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path
        Traversal')"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
      references:
        - https://www.owasp.org/index.php/Path_Traversal
    message: |
      Detected a potential path traversal. A malicious actor
      could control the location of this file, to include going backwards
      in the directory with '../'. To address this, ensure that user-controlled
      variables in file paths are sanitized. You may aslso consider using a utility
      method such as org.apache.commons.io.FilenameUtils.getName(...) to only
      retrieve the file name from the path.
    patterns:
      - pattern-either:
          - pattern: |
              $RETURNTYPE $FUNC (..., @PathParam(...) $TYPE $VAR, ...) {
                ...
                new File(..., $VAR, ...);
                ...
              }
          - pattern: |-
              $RETURNTYPE $FUNC (..., @javax.ws.rs.PathParam(...) $TYPE $VAR, ...) {
                ...
                new File(..., $VAR, ...);
                ...
              }
    severity: WARNING
    languages:
      - java
  - id: java.lang.correctness.eqeq.eqeq
    patterns:
      - pattern-not-inside: assert $X;
      - pattern-not-inside: |
          assert $X : $Y;
      - pattern-either:
          - pattern: $X == $X
          - pattern: $X != $X
      - pattern-not: 1 == 1
    message: |
      `$X == $X` or `$X != $X` is always true. (Unless the value compared is a float or double).
      To test if `$X` is not-a-number, use `Double.isNaN($X)`.
    languages:
      - java
    severity: ERROR
  - id: java.lang.correctness.no-string-eqeq.no-string-eqeq
    languages:
      - java
    patterns:
      - pattern-not: null == (String $Y)
      - pattern: $X == (String $Y)
    message: |
      Strings should not be compared with '=='.
      This is a reference comparison operator.
      Use '.equals()' instead.
    severity: WARNING
  - id: java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated
    message: |
      DES is considered deprecated. AES is the recommended cipher.
      Upgrade to use AES.
      See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information.
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DES_USAGE
      references:
        - https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard
    severity: WARNING
    pattern: $CIPHER.getInstance("=~/DES/.*/");
    fix: $CIPHER.getInstance("AES/GCM/NoPadding");
    languages:
      - java
  - id: java.lang.security.audit.crypto.no-null-cipher.no-null-cipher
    pattern: new NullCipher(...);
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#NULL_CIPHER
    message: |
      NullCipher was detected. This will not encrypt anything;
      the cipher text will be the same as the plain text. Use
      a valid, secure cipher: Cipher.getInstance("AES/CBC/PKCS7PADDING").
      See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions
      for more information.
    severity: WARNING
    languages:
      - java
  - id: java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector
    message: |
      Initialization Vectors (IVs) for block ciphers should be randomly generated
      each time they are used. Using a static IV means the same plaintext
      encrypts to the same ciphertext every time, weakening the strength
      of the encryption.
    metadata:
      cwe: "CWE-329: Not Using a Random IV with CBC Mode"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#STATIC_IV
      references:
        - https://cwe.mitre.org/data/definitions/329.html
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: |
              byte[] $IV = {
                  ...
              };
              ...
              new IvParameterSpec($IV, ...);
          - pattern: |
              class $CLASS {
                  byte[] $IV = {
                      ...
                  };
                  ...
                  $METHOD(...) {
                      ...
                      new IvParameterSpec($IV, ...);
                      ...
                  }
              }
  - id: java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DEFAULT_HTTP_CLIENT
    message: |
      DefaultHttpClient is deprecated. Further, it does not support connections
      using TLS1.2, which makes using DefaultHttpClient a security hazard.
      Use SystemDefaultHttpClient instead, which supports TLS1.2.
    severity: WARNING
    languages:
      - java
    pattern: new DefaultHttpClient(...);
    fix-regex:
      regex: DefaultHttpClient
      replacement: SystemDefaultHttpClient
  - id: java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier
    message: |
      Insecure HostnameVerifier implementation detected. This will accept
      any SSL certificate with any hostname, which creates the possibility
      for man-in-the-middle attacks.
    metadata:
      cwe: "CWE-295: Improper Certificate Validation"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: |
              class $CLASS implements HostnameVerifier {
                ...
                public boolean verify(...) { return true; }
              }
          - pattern: |-
              new HostnameVerifier(...){
                public boolean verify(...) {
                  return true;
                }
              }
  - id: java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager
    metadata:
      cwe: "CWE-295: Improper Certificate Validation"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER
      references:
        - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
    message: |
      Detected empty trust manager implementations. This is dangerous because it accepts any
      certificate, enabling man-in-the-middle attacks. Consider using a KeyStore
      and TrustManagerFactory isntead.
      See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
      for more information.
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern-inside: |
              class $CLASS implements X509TrustManager {
                ...
              }
          - pattern-inside: |
              new X509TrustManager() {
                ...
              }
          - pattern-inside: |
              class $CLASS implements X509ExtendedTrustManager {
                ...
              }
          - pattern-inside: |
              new X509ExtendedTrustManager() {
                ...
              }
      - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }
      - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }
      - pattern-either:
          - pattern: public void checkClientTrusted(...) {}
          - pattern: public void checkServerTrusted(...) {}
          - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }
  - id: java.lang.security.audit.crypto.weak-hash.use-of-md5
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    languages:
      - java
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5
    pattern-either:
      - pattern: |
          MessageDigest $VAR = $MD.getInstance("MD5");
      - pattern: |
          $DU.getMd5Digest().digest(...)
  - id: java.lang.security.audit.crypto.weak-hash.use-of-sha1
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    languages:
      - java
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_SHA1
    pattern-either:
      - pattern: |
          MessageDigest $VAR = $MD.getInstance("SHA1");
      - pattern: |
          $DU.getSha1Digest().digest(...)
  - id: java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection
    metadata:
      cwe: "CWE-297: Improper Validation of Certificate with Host Mismatch"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_SMTP_SSL
    message: |
      Insecure SMTP connection detected. This connection will trust any SSL certificate.
      Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'.
    severity: WARNING
    patterns:
      - pattern-not-inside: |
          $EMAIL.setSSLCheckServerIdentity(true);
          ...
      - pattern-inside: |
          $EMAIL = new SimpleEmail(...);
          ...
      - pattern: $EMAIL.send(...);
    languages:
      - java
  - id: java.lang.security.audit.permissive-cors.permissive-cors
    message: |
      https://find-sec-bugs.github.io/bugs.htm#PERMISSIVE_CORS
      Permissive CORS policy will allow a malicious application to communicate with the victim application in an inappropriate way, leading to spoofing, data theft, relay and other attacks.
    severity: WARNING
    languages:
      - java
    pattern-either:
      - pattern: |
          HttpServletResponse $RES = ...;
          ...
          $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
      - pattern: |
          HttpServletResponse $RES = ...;
          ...
          $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
      - pattern: |
          ServerHttpResponse $RES = ...;
          ...
          $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
      - pattern: |
          HttpHeaders $HEADERS = ...;
          ...
          $HEADERS.set("=~/access-control-allow-origin/i", "=~/^*|null$/i");
      - pattern: |
          ServerWebExchange $SWE = ...;
          ...
          $SWE.getResponse().getHeaders().add("Access-Control-Allow-Origin", "*");
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...) {
            ...
            $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...) {
            ...
            $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
            ...
          }
      - pattern: |
          $X $METHOD(...,ServerHttpResponse $RES,...) {
            ...
            $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
            ...
          }
      - pattern: |
          $X $METHOD(...,ServerWebExchange $SWE,...) {
            ...
            $SWE.getResponse().getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
            ...
          }
      - pattern: ResponseEntity.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
      - pattern: ServerResponse.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
  - id: java.lang.security.audit.weak-ssl-context.weak-ssl-context
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source_rule_url: https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT
      references:
        - https://tools.ietf.org/html/rfc7568
        - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
    message: |
      An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions
      are considered weak encryption and are deprecated.
      Use SSLContext.getInstance("TLSv1.2") for the best security.
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-not: SSLContext.getInstance("TLS1.3")
      - pattern-not: SSLContext.getInstance("TLS1.2")
      - pattern: SSLContext.getInstance("...")
    fix-regex:
      regex: (.*?)\.getInstance\(.*?\)
      replacement: \1.getInstance("TLS1.2")
  - id: java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
    metadata:
      cwe:
        "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path
        Traversal')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
      references:
        - https://www.owasp.org/index.php/Path_Traversal
    message: |
      Detected a potential path traversal. A malicious actor
      could control the location of this file, to include going backwards
      in the directory with '../'. To address this, ensure that user-controlled
      variables in file paths are sanitized. You may aslso consider using a utility
      method such as org.apache.commons.io.FilenameUtils.getName(...) to only
      retrieve the file name from the path.
    patterns:
      - pattern-inside: |
          $RETURNTYPE $FUNC (..., HttpServletRequest $REQ, ...) {
            ...
          }
      - pattern-either:
          - pattern: |
              $VAR = ($TYPE)$REQ.getParameter(...);
              ...
              new File(..., $VAR, ...);
          - pattern: |
              $VAR = $REQ.getParameter(...);
              ...
              new File(..., $VAR, ...);
    severity: ERROR
    languages:
      - java
  - id: java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss
    message: |
      Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User
      input was detected going directly from the HttpServletRequest into output. Ensure your
      data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-Site Scripting ('XSS')"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET
    severity: ERROR
    patterns:
      - pattern-inside: $TYPE $FUNC(..., HttpServletResponse $RESP, ...) { ... }
      - pattern-inside: $VAR = $REQ.getParameter(...); ...
      - pattern-either:
          - pattern: $RESP.getWriter(...).write(..., $VAR, ...);
          - pattern: |
              $WRITER = $RESP.getWriter(...);
              ...
              $WRITER.write(..., $VAR, ...);
    languages:
      - java
  - id: java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled
    severity: ERROR
    metadata:
      cwe: "CWE-611: Improper Restriction of XML External Entity Reference"
      owasp: "A4: XML External Entities (XXE)"
      references:
        - https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf
    message: |
      XML external entities are enabled for this XMLInputFactory. This is vulnerable to XML external entity
      attacks. Disable external entities by setting "javax.xml.stream.isSupportingExternalEntities" to false.
    pattern:
      $XMLFACTORY.setProperty("javax.xml.stream.isSupportingExternalEntities",
      true);
    languages:
      - java
  - id: java.rmi.security.server-dangerous-object-deserialization.server-dangerous-object-deserialization
    severity: ERROR
    metadata:
      cwe: "CWE-502: Deserialization of Untrusted Data"
      owasp: "A8: Insecure Deserialization"
      references:
        - https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/
        - https://frohoff.github.io/appseccali-marshalling-pickles/
    message: |
      Using an arbitrary object ('Object $PARAM') with Java RMI is an insecure deserialization
      vulnerability. This object can be manipulated by a malicious actor allowing them to execute
      code on your system. Instead, use an integer ID to look up your object, or consider alternative
      serializiation schemes such as JSON.
    patterns:
      - pattern: |
          interface $INTERFACE extends Remote {
            $RETURNTYPE $METHOD(Object $PARAM) throws RemoteException;
          }
    languages:
      - java
  - id: java.spring.security.unrestricted-request-mapping.unrestricted-request-mapping
    patterns:
      - pattern: |
          @RequestMapping(...)
          $RETURNTYPE $METHOD(...) { ... }
      - pattern-not-inside: |
          @RequestMapping(..., method = $X)
          $RETURNTYPE $METHOD(...) { ... }
    message:
      Detected a method annotated with 'RequestMapping' that does not specify
      the HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or OPTIONS,
      and by default all HTTP methods are allowed when the HTTP method is not explicitly
      specified. This means that a method that performs state changes could be vulnerable
      to CSRF attacks. To mitigate, add the 'method' field and specify the HTTP method
      (such as 'RequestMethod.POST').
    severity: WARNING
    metadata:
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
      references:
        - https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
    languages:
      - java
  - id: javascript.grpc.security.grpc-nodejs-insecure-connection.grpc-nodejs-insecure-connection
    message: |
      Found an insecure gRPC connection. This creates a connection without encryption to a gRPC client/server. A malicious attacker
      could tamper with the gRPC message, which could compromise the machine.
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
    severity: ERROR
    languages:
      - javascript
    pattern-either:
      - pattern: |
          require('grpc');
          ...
          $GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);
      - pattern: |-
          require('grpc');
          ...
          $CREDS = <... $CREDENTIALS.createInsecure() ...>;
          ...
          $GRPC($ADDR,...,$CREDS,...);
  - id: javascript.jose.security.jwt-exposed-credentials.jwt-exposed-credentials
    languages:
      - javascript
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      references:
        - https://cwe.mitre.org/data/definitions/522.html
    message: |
      Password is exposed through JWT token payload. This is not encrypted and
      the password could be compromised. Do not store passwords in JWT tokens.
    patterns:
      - pattern-either:
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign({password:...},...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $T = JWT.sign({password:...},...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = {password:...};
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = {password:...};
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = {password:...};
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = {password:...};
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P.password = ...;
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P.password = ...;
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $T = JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $T = JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = {$U:{password:...}};
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = {$U:{password:...}};
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = {$U:{password:...}};
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = {$U:{password:...}};
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P.$U.password = ...;
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P.$U.password = ...;
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    severity: ERROR
  - id: javascript.jose.security.jwt-hardcode.hardcoded-jwt-secret
    message: |
      Hardcoded JWT secret or private key is used.
      This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
      Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    patterns:
      - pattern-either:
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              JWT.verify($P, "...", ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign($P, "...", ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.verify($P, "...", ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              JWT.verify($P, JWK.asKey("..."), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $KEY = JWK.asKey("...");
              ...
              JWT.verify($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $T = JWT.sign($P, JWK.asKey("..."), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $T = JWT.verify($P, JWK.asKey("..."), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $KEY = JWK.asKey("...");
              ...
              var $T = JWT.sign($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $KEY = JWK.asKey("...");
              ...
              var $T = JWT.verify($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              JWT.verify($P, $SECRET, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $T = JWT.sign($P, $SECRET, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $T = JWT.verify($P, $SECRET, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              JWT.verify($P, JWK.asKey($SECRET), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $KEY = JWK.asKey($SECRET);
              ...
              JWT.verify($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $T = JWT.sign($P, JWK.asKey($SECRET), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $KEY = JWK.asKey($SECRET);
              ...
              var $T = JWT.sign($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $T = JWT.verify($P, JWK.asKey($SECRET), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $KEY = JWK.asKey($SECRET);
              ...
              var $T = JWT.verify($P, $KEY, ...);
    languages:
      - javascript
    severity: ERROR
  - id: javascript.jose.security.jwt-none-alg.jwt-none-alg
    message: |
      Detected use of the 'none' algorithm in a JWT token.
      The 'none' algorithm assumes the integrity of the token has already
      been verified. This would allow a malicious actor to forge a JWT token
      that will automatically be verified. Do not explicitly use the 'none'
      algorithm. Instead, use an algorithm such as 'HS256'.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    languages:
      - javascript
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $T = JWT.verify($P, JWK.None,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              $T = JWT.verify($P, JWK.None,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              JWT.verify($P, JWK.None,...);
  - id: javascript.jsonwebtoken.security.jwt-exposed-credentials.jwt-exposed-credentials
    languages:
      - javascript
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      references:
        - https://cwe.mitre.org/data/definitions/522.html
    message: |
      Password is exposed through JWT token payload. This is not encrypted and
      the password could be compromised. Do not store passwords in JWT tokens.
    patterns:
      - pattern-either:
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign({password:...},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.sign({password:...},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign({password:...},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {password:...};
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {password:...};
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {password:...};
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {password:...};
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {password:...};
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {password:...};
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.password = ...;
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.password = ...;
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.password = ...;
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {$U:{password:...}};
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {$U:{password:...}};
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {$U:{password:...}};
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {$U:{password:...}};
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {$U:{password:...}};
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {$U:{password:...}};
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.$U.password = ...;
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.$U.password = ...;
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.$U.password = ...;
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    severity: ERROR
  - id: javascript.jsonwebtoken.security.jwt-hardcode.hardcoded-jwt-secret
    message: |
      Hardcoded JWT secret or private key is used.
      This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
      Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    patterns:
      - pattern-either:
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign($P, "...", ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.verify($P, "...", ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign($P, "...", ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.verify($P, "...", ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $SECRET = "...";
              ...
              var $T = $JWT.sign($P, $SECRET, ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $SECRET = "...";
              ...
              var $T = $JWT.verify($P, $SECRET, ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $SECRET = "...";
              ...
              $JWT.sign($P, $SECRET, ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $SECRET = "...";
              ...
              $JWT.verify($P, $SECRET, ...);
    languages:
      - javascript
    severity: ERROR
  - id: javascript.jsonwebtoken.security.jwt-none-alg.jwt-none-alg
    message: |
      Detected use of the 'none' algorithm in a JWT token.
      The 'none' algorithm assumes the integrity of the token has already
      been verified. This would allow a malicious actor to forge a JWT token
      that will automatically be verified. Do not explicitly use the 'none'
      algorithm. Instead, use an algorithm such as 'HS256'.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    languages:
      - javascript
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
          - pattern: |-
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
  - id: javascript.lang.correctness.useless-eqeq.eqeq-is-bad
    patterns:
      - pattern-not-inside: assert(...)
      - pattern-either:
          - pattern: $X == $X
          - pattern: $X != $X
      - pattern-not: 1 == 1
    message: |
      Detected a useless comparison operation `$X == $X` or `$X != $X`. This
      operation is always true.
      If testing for floating point NaN, use `math.isnan`, or
      `cmath.isnan` if the number is complex.
    languages:
      - javascript
      - typescript
    severity: ERROR
  - id: python.boto3.security.hardcoded-token.hardcoded-token
    message: |
      Hardcoded AWS access token detected. Use environment variables
      to access tokens (e.g., os.environ.get(...)) or use non version-controlled
      configuration files.
    metadata:
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://pypi.org/project/flake8-boto3/
      references:
        - https://bento.dev/checks/boto3/hardcoded-access-token/
        - https://aws.amazon.com/blogs/security/what-to-do-if-you-inadvertently-expose-an-aws-access-key/
    patterns:
      - pattern-either:
          - pattern: $W(..., aws_secret_access_key="=~/^[A-Za-z0-9/+=]+$/", ...)
          - pattern: $W(..., aws_access_key_id="=~/^AKI/", ...)
          - pattern: $W(..., aws_session_token="...", ...)
    languages:
      - python
    severity: WARNING
  - id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-blowfish
    pattern: cryptography.hazmat.primitives.ciphers.algorithms.Blowfish(...)
    message: |
      Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L96
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-idea
    pattern: cryptography.hazmat.primitives.ciphers.algorithms.IDEA(...)
    message: |
      Detected IDEA cipher algorithm which is considered insecure. The algorithm is
      considered weak and has been deprecated. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://tools.ietf.org/html/rfc5469
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-rc4
    pattern: cryptography.hazmat.primitives.ciphers.algorithms.ARC4(...)
    message: |
      Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L94
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
    pattern: cryptography.hazmat.primitives.ciphers.modes.ECB(...)
    message: |
      Detected ECB cipher mode which is considered insecure. The algorithm can
      potentially leak information about the plaintext. Use CBC mode instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L101
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B305
      references:
        - https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
    pattern: cryptography.hazmat.primitives.hashes.MD5(...)
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B303
      references:
        - https://tools.ietf.org/html/rfc6151
        - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
    pattern: cryptography.hazmat.primitives.hashes.SHA1(...)
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B303
      references:
        - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
        - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
        - http://2012.sharcs.org/slides/stevens.pdf
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insufficient-ec-key-size.insufficient-ec-key-size
    patterns:
      - pattern-inside: cryptography.hazmat.primitives.asymmetric.ec.generate_private_key(...)
      - pattern-either:
          - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECP192R1
          - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163K1
          - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163R2
    message: |
      Detected an insufficient curve size for EC. NIST recommends
      a key size of 224 or higher. For example, use 'ec.SECP256R1'.
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
      references:
        - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
        - https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#elliptic-curves
    languages:
      - python
    severity: WARNING
  - id: python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
      references: https://docs.python.org/3/library/pickle.html
    message:
      Avoid using insecure deserialization library, backed by `pickle`, `_pickle`,
      `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code
      execution vulnerabilities.
    languages:
      - python
    severity: ERROR
    patterns:
      - pattern-inside: |
          def $X(..., request, ...):
            ...
      - pattern-either:
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              pickle.$FUNC(<... $VAR ...>)
          - pattern: pickle.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              _pickle.$FUNC(<... $VAR ...>)
          - pattern: _pickle.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              cPickle.$FUNC(<... $VAR ...>)
          - pattern: cPickle.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              dill.$FUNC(<... $VAR ...>)
          - pattern: dill.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              shelve.$FUNC(<... $VAR ...>)
          - pattern: shelve.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              yaml.$FUNC(<... $VAR ...>)
          - pattern: yaml.$FUNC(<... request.$Y.get(...) ...>)
  - id: python.django.security.injection.code.globals-misuse-code-execution.globals-misuse-code-execution
    message: |
      Found request data as an index to 'globals()'. This is extremely
      dangerous because it allows an attacker to execute arbitrary code
      on the system. Refactor your code not to use 'globals()'.
    metadata:
      cwe:
        "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static
        Code Injection')"
      owasp: "A1: Injection"
      references:
        - https://github.com/mpirnat/lets-be-bad-guys/blob/d92768fb3ade32956abd53bd6bb06e19d634a084/badguys/vulnerable/views.py#L181-L186
    languages:
      - python
    severity: WARNING
    patterns:
      - pattern-inside: |
          def $FUNC(...):
            ...
      - pattern-either:
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals().get($DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals().get("..." % $DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals().get(f"...{$DATA}...", ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals().get("...".format(..., $DATA, ...), ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals()[$DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals()["..." % $DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals()[f"...{$DATA}..."]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals()["...".format(..., $DATA, ...)]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals().get($DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals().get("..." % $DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals().get(f"...{$DATA}...", ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals().get("...".format(..., $DATA, ...), ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals()[$DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals()["..." % $DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals()[f"...{$DATA}..."]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals()["...".format(..., $DATA, ...)]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals().get($DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals().get("..." % $DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals().get(f"...{$DATA}...", ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals().get("...".format(..., $DATA, ...), ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals()[$DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals()["..." % $DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals()[f"...{$DATA}..."]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals()["...".format(..., $DATA, ...)]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals().get($DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals().get("..." % $DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals().get(f"...{$DATA}...", ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals().get("...".format(..., $DATA, ...), ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals()[$DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals()["..." % $DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals()[f"...{$DATA}..."]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals()["...".format(..., $DATA, ...)]
              ...
              $INTERM(...)
  - id: python.django.security.injection.code.user-eval.user-eval
    message: |
      Found user data in a call to 'eval'. This is extremely dangerous because
      it can enable an attacker to execute remote code. See
      https://owasp.org/www-community/attacks/Code_Injection for more information
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
      references:
        - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
    patterns:
      - pattern-inside: |
          def $F(...):
            ...
      - pattern-either:
          - pattern: eval(..., request.$W.get(...), ...)
          - pattern: |
              $V = request.$W.get(...)
              ...
              eval(..., $V, ...)
          - pattern: eval(..., request.$W(...), ...)
          - pattern: |
              $V = request.$W(...)
              ...
              eval(..., $V, ...)
          - pattern: eval(..., request.$W[...], ...)
          - pattern: |
              $V = request.$W[...]
              ...
              eval(..., $V, ...)
    languages:
      - python
    severity: WARNING
  - id: python.django.security.injection.code.user-exec.user-exec
    message: |
      Found user data in a call to 'exec'. This is extremely dangerous because
      it can enable an attacker to execute remote code. See
      https://owasp.org/www-community/attacks/Code_Injection for more information.
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
    patterns:
      - pattern-inside: |
          def $F(...):
            ...
      - pattern-either:
          - pattern: exec(..., request.$W.get(...), ...)
          - pattern: |
              $V = request.$W.get(...)
              ...
              exec(..., $V, ...)
          - pattern: exec(..., request.$W(...), ...)
          - pattern: |
              $V = request.$W(...)
              ...
              exec(..., $V, ...)
          - pattern: exec(..., request.$W[...], ...)
          - pattern: |
              $V = request.$W[...]
              ...
              exec(..., $V, ...)
    languages:
      - python
    severity: WARNING
  - id: python.django.security.injection.mass-assignment.mass-assignment
    languages:
      - python
    severity: WARNING
    message: |
      Mass assignment detected. This can result in assignment to
      model fields that are unintended and can be exploited by
      an attacker. Instead of using '**request.$W', assign each field you
      want to edit individually to prevent mass assignment. You can read
      more about mass assignment at
      https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html.
    metadata:
      cwe:
        "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
        Attributes"
      owasp: "A1: Injection"
      owaspapi: "API6: Mass Assignment"
      references:
        - https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html
    patterns:
      - pattern-either:
          - pattern: $MODEL.objects.create(**request.$W)
          - pattern: |
              $OBJ.update(**request.$W)
              ...
              $OBJ.save()
  - id: python.django.security.injection.email.xss-html-email-body.xss-html-email-body
    message: |
      Found request data in an EmailMessage that is set to use HTML.
      This is dangerous because HTML emails are susceptible to XSS.
      An attacker could inject data into this HTML email, causing XSS.
    metadata:
      cwe:
        "CWE-74: Improper Neutralization of Special Elements in Output Used by a
        Downstream Component ('Injection')"
      owasp: "A1: Injection"
      references:
        - https://www.damonkohler.com/2008/12/email-injection.html
    languages:
      - python
    severity: WARNING
    patterns:
      - pattern-inside: |
          def $FUNC(...):
            ...
            $EMAIL.content_subtype = "html"
            ...
      - pattern-either:
          - pattern: django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $B.$C(..., $DATA, ...)
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
          - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
          - pattern: django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $B.$C(..., $DATA, ...)
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
          - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
          - pattern: django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.EmailMessage($SUBJ, $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $B.$C(..., $DATA, ...)
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
          - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
          - pattern: django.core.mail.EmailMessage($SUBJ, request.$W, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.EmailMessage($SUBJ, $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $B.$C(..., $DATA, ...)
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W, ...)
          - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W, ...)
  - id: python.django.security.injection.email.xss-send-mail-html-message.xss-send-mail-html-message
    message: |
      Found request data in 'send_mail(...)' that uses 'html_message'.
      This is dangerous because HTML emails are susceptible to XSS.
      An attacker could inject data into this HTML email, causing XSS.
    metadata:
      cwe:
        "CWE-74: Improper Neutralization of Special Elements in Output Used by a
        Downstream Component ('Injection')"
      owasp: "A1: Injection"
      references:
        - https://www.damonkohler.com/2008/12/email-injection.html
    languages:
      - python
    severity: WARNING
    patterns:
      - pattern-inside: |
          def $FUNC(...):
            ...
      - pattern-either:
          - pattern: django.core.mail.send_mail(..., html_message=request.$W.get(...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=$DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR + $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern:
              $A = django.core.mail.send_mail(..., html_message=request.$W.get(...),
              ...)
          - pattern:
              return django.core.mail.send_mail(..., html_message=request.$W.get(...),
              ...)
          - pattern: django.core.mail.send_mail(..., html_message=request.$W(...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=$DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR + $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern:
              $A = django.core.mail.send_mail(..., html_message=request.$W(...),
              ...)
          - pattern:
              return django.core.mail.send_mail(..., html_message=request.$W(...),
              ...)
          - pattern: django.core.mail.send_mail(..., html_message=request.$W[...], ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=$DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR + $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern:
              $A = django.core.mail.send_mail(..., html_message=request.$W[...],
              ...)
          - pattern:
              return django.core.mail.send_mail(..., html_message=request.$W[...],
              ...)
          - pattern: django.core.mail.send_mail(..., html_message=request.$W, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=$DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR + $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W, ...)
          - pattern: return django.core.mail.send_mail(..., html_message=request.$W, ...)
  - id: python.django.security.injection.command.command-injection-os-system.command-injection-os-system
    message:
      Request data detected in os.system. This could be vulnerable to a command
      injection and should be avoided. If this must be done, use the 'subprocess' module
      instead and pass the arguments as a list. See https://owasp.org/www-community/attacks/Command_Injection
      for more information.
    metadata:
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
      references:
        - https://owasp.org/www-community/attacks/Command_Injection
    languages:
      - python
    severity: WARNING
    patterns:
      - pattern-inside: |
          def $FUNC(...):
            ...
      - pattern-either:
          - pattern: os.system(..., request.$W.get(...), ...)
          - pattern: os.system(..., $S.format(..., request.$W.get(...), ...), ...)
          - pattern: os.system(..., $S % request.$W.get(...), ...)
          - pattern: os.system(..., f"...{request.$W.get(...)}...", ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., $STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR % $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., $STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR + $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: $A = os.system(..., request.$W.get(...), ...)
          - pattern: $A = os.system(..., $S.format(..., request.$W.get(...), ...), ...)
          - pattern: $A = os.system(..., $S % request.$W.get(...), ...)
          - pattern: $A = os.system(..., f"...{request.$W.get(...)}...", ...)
          - pattern: return os.system(..., request.$W.get(...), ...)
          - pattern: return os.system(..., $S.format(..., request.$W.get(...), ...), ...)
          - pattern: return os.system(..., $S % request.$W.get(...), ...)
          - pattern: return os.system(..., f"...{request.$W.get(...)}...", ...)
          - pattern: os.system(..., request.$W(...), ...)
          - pattern: os.system(..., $S.format(..., request.$W(...), ...), ...)
          - pattern: os.system(..., $S % request.$W(...), ...)
          - pattern: os.system(..., f"...{request.$W(...)}...", ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., $STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR % $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., $STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR + $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: $A = os.system(..., request.$W(...), ...)
          - pattern: $A = os.system(..., $S.format(..., request.$W(...), ...), ...)
          - pattern: $A = os.system(..., $S % request.$W(...), ...)
          - pattern: $A = os.system(..., f"...{request.$W(...)}...", ...)
          - pattern: return os.system(..., request.$W(...), ...)
          - pattern: return os.system(..., $S.format(..., request.$W(...), ...), ...)
          - pattern: return os.system(..., $S % request.$W(...), ...)
          - pattern: return os.system(..., f"...{request.$W(...)}...", ...)
          - pattern: os.system(..., request.$W[...], ...)
          - pattern: os.system(..., $S.format(..., request.$W[...], ...), ...)
          - pattern: os.system(..., $S % request.$W[...], ...)
          - pattern: os.system(..., f"...{request.$W[...]}...", ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., $STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR % $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = f"...{$DATA}..."
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., $STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR + $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: $A = os.system(..., request.$W[...], ...)
          - pattern: $A = os.system(..., $S.format(..., request.$W[...], ...), ...)
          - pattern: $A = os.system(..., $S % request.$W[...], ...)
          - pattern: $A = os.system(..., f"...{request.$W[...]}...", ...)
          - pattern: return os.system(..., request.$W[...], ...)
          - pattern: return os.system(..., $S.format(..., request.$W[...], ...), ...)
          - pattern: return os.system(..., $S % request.$W[...], ...)
          - pattern: return os.system(..., f"...{request.$W[...]}...", ...)
          - pattern: os.system(..., request.$W, ...)
          - pattern: os.system(..., $S.format(..., request.$W, ...), ...)
          - pattern: os.system(..., $S % request.$W, ...)
          - pattern: os.system(..., f"...{request.$W}...", ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., $STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR % $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = f"...{$DATA}..."
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., $STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR + $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: $A = os.system(..., request.$W, ...)
          - pattern: $A = os.system(..., $S.format(..., request.$W, ...), ...)
          - pattern: $A = os.system(..., $S % request.$W, ...)
          - pattern: $A = os.system(..., f"...{request.$W}...", ...)
          - pattern: return os.system(..., request.$W, ...)
          - pattern: return os.system(..., $S.format(..., request.$W, ...), ...)
          - pattern: return os.system(..., $S % request.$W, ...)
          - pattern: return os.system(..., f"...{request.$W}...", ...)
  - id: python.django.security.injection.path-traversal.path-traversal-file-name.path-traversal-file-name
    message: |
      Data from request is passed to a file name `$FILE`.
      This is a path traversal vulnerability: https://owasp.org/www-community/attacks/Path_Traversal
      To mitigate, consider using os.path.abspath or os.path.realpath or Path library.
    metadata:
      cwe:
        "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path
        Traversal')"
      owasp: "A1: Injection"
      references:
        - https://owasp.org/www-community/attacks/Path_Traversal
    patterns:
      - pattern-inside: |
          def $F(...):
            ...
      - pattern-not: |
          ...
          os.path.realpath(...)
          ...
      - pattern-not: |
          ...
          os.path.abspath(...)
          ...
      - pattern-either:
          - pattern: |
              $V = request.$W.get($X)
              ...
              $FILE % ($V)
          - pattern: |
              $V = request.$W[$X]
              ...
              $FILE % ($V)
          - pattern: |
              $V = request.$W($X)
              ...
              $FILE % ($V)
          - pattern: |
              $V = request.$W
              ...
              $FILE % ($V)
              # match format use cases
          - pattern: |
              $V = request.$W.get($X)
              ...
              $FILE.format(..., $V, ...)
          - pattern: |
              $V = request.$W[$X]
              ...
              $FILE.format(..., $V, ...)
          - pattern: |
              $V = request.$W($X)
              ...
              $FILE.format(..., $V, ...)
          - pattern: |
              $V = request.$W
              ...
              $FILE.format(..., $V, ...)
      - metavariable-regex:
          metavariable: $FILE
          regex: .*\.(log|zip|txt|csv|xml|html).*
    languages:
      - python
    severity: WARNING
  - id: python.django.security.passwords.use-none-for-password-default.use-none-for-password-default
    message: |
      '$VAR' is using the empty string as its default and is being used to set
      the password on '$MODEL'. If you meant to set an unusable password, set
      the default value to 'None' or call 'set_unusable_password()'.
    metadata:
      cwe: "CWE-521: Weak Password Requirements"
      owasp: "A2: Broken Authentication"
      references:
        - https://docs.djangoproject.com/en/3.0/ref/contrib/auth/#django.contrib.auth.models.User.set_password
    patterns:
      - pattern-either:
          - pattern: |
              $VAR = request.$W.get($X, "")
              ...
              $MODEL.set_password($VAR)
              ...
              $MODEL.save(...)
          - pattern: |
              def $F(..., $VAR="", ...):
                ...
                $MODEL.set_password($VAR)
    fix-regex:
      regex: (def.*|request.*)(""|'')
      replacement: \1None
    languages:
      - python
    severity: ERROR
  - id: python.flask.security.dangerous-template-string.dangerous-template-string
    patterns:
      - pattern-either:
          - pattern: |
              $V = "...".format(...)
              ...
              flask.render_template_string($V, ...)
          - pattern: |
              $V = "...".format(...)
              ...
              return flask.render_template_string($V, ...), $MORE
          - pattern: |
              $V = "..." % $S
              ...
              flask.render_template_string($V, ...)
          - pattern: |
              $V = "..." % $S
              ...
              return flask.render_template_string($V, ...), $MORE
          - pattern: |
              $V = "..."
              ...
              $V += $O
              ...
              flask.render_template_string($V, ...)
          - pattern: |
              $V = "..."
              ...
              $V += $O
              ...
              return flask.render_template_string($V, ...), $MORE
          - pattern: |
              $V = f"...{$X}..."
              ...
              flask.render_template_string($V, ...)
          - pattern: |
              $V = f"...{$X}..."
              ...
              return flask.render_template_string($V, ...), $CODE
    message: |
      Found a template created with string formatting.
      This is susceptible to server-side template injection
      and cross-site scripting attacks.
    metadata:
      cwe:
        "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static
        Code Injection')"
      owasp: "A1: Injection"
      references:
        - https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html
        - https://pequalsnp-team.github.io/cheatsheet/flask-jinja2-ssti
    languages:
      - python
    severity: ERROR
  - id: python.flask.security.injection.os-system-injection.os-system-injection
    languages:
      - python
    severity: ERROR
    message:
      User data detected in os.system. This could be vulnerable to a command
      injection and should be avoided. If this must be done, use the 'subprocess' module
      instead and pass the arguments as a list.
    metadata:
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
      references:
        - https://owasp.org/www-community/attacks/Command_Injection
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  @$APP.route($ROUTE, ...)
                  def $FUNC(..., $ROUTEVAR, ...):
                    ...
              - pattern-either:
                  - pattern: os.system(..., <... $ROUTEVAR ...>, ...)
                  - pattern: |
                      $INTERM = <... $ROUTEVAR ...>
                      ...
                      os.system(..., <... $INTERM ...>, ...)
          - patterns:
              - pattern-either:
                  - pattern: os.system(..., <... flask.request.$W.get(...) ...>, ...)
                  - pattern: os.system(..., <... flask.request.$W[...] ...>, ...)
                  - pattern: os.system(..., <... flask.request.$W(...) ...>, ...)
                  - pattern: os.system(..., <... flask.request.$W ...>, ...)
          - patterns:
              - pattern-either:
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W.get(...) ...>
                          ...
                          os.system(<... $INTERM ...>)
                      - pattern: os.system(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W[...] ...>
                          ...
                          os.system(<... $INTERM ...>)
                      - pattern: os.system(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W(...) ...>
                          ...
                          os.system(<... $INTERM ...>)
                      - pattern: os.system(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W ...>
                          ...
                          os.system(<... $INTERM ...>)
                      - pattern: os.system(...)
  - id: python.flask.security.injection.path-traversal-open.path-traversal-open
    languages:
      - python
    severity: ERROR
    message:
      Found request data in a call to 'open'. Ensure the request data is validated
      or sanitized, otherwise it could result in path traversal attacks.
    metadata:
      cwe:
        "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path
        Traversal')"
      owasp: "A1: Injection"
      references:
        - https://owasp.org/www-community/attacks/Path_Traversal
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  @$APP.route($ROUTE, ...)
                  def $FUNC(..., $ROUTEVAR, ...):
                    ...
              - pattern-either:
                  - pattern: open(..., <... $ROUTEVAR ...>, ...)
                  - pattern: |
                      $INTERM = <... $ROUTEVAR ...>
                      ...
                      open(..., <... $INTERM ...>, ...)
          - patterns:
              - pattern-either:
                  - pattern: open(..., <... flask.request.$W.get(...) ...>, ...)
                  - pattern: open(..., <... flask.request.$W[...] ...>, ...)
                  - pattern: open(..., <... flask.request.$W(...) ...>, ...)
                  - pattern: open(..., <... flask.request.$W ...>, ...)
          - patterns:
              - pattern-either:
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W.get(...) ...>
                          ...
                          open(<... $INTERM ...>, ...)
                      - pattern: open(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W[...] ...>
                          ...
                          open(<... $INTERM ...>, ...)
                      - pattern: open(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W(...) ...>
                          ...
                          open(<... $INTERM ...>, ...)
                      - pattern: open(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W ...>
                          ...
                          open(<... $INTERM ...>, ...)
                      - pattern: open(...)
          - patterns:
              - pattern-either:
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W.get(...) ...>
                          ...
                          with open(<... $INTERM ...>, ...) as $F:
                            ...
                      - pattern: open(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W[...] ...>
                          ...
                          with open(<... $INTERM ...>, ...) as $F:
                            ...
                      - pattern: open(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W(...) ...>
                          ...
                          with open(<... $INTERM ...>, ...) as $F:
                            ...
                      - pattern: open(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W ...>
                          ...
                          with open(<... $INTERM ...>, ...) as $F:
                            ...
                      - pattern: open(...)
  - id: python.flask.security.injection.ssrf-requests.ssrf-requests
    languages:
      - python
    severity: ERROR
    message:
      Data from request object is passed to a new server-side request. This could
      lead to a server-side request forgery (SSRF). To mitigate, ensure that schemes
      and hosts are validated against an allowlist, do not forward the response to the
      user, and ensure proper authentication and transport-layer security in the proxied
      request.
    metadata:
      cwe: "CWE-918: Server-Side Request Forgery (SSRF)"
      owasp: "A1: Injection"
      references:
        - https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  @$APP.route($ROUTE, ...)
                  def $ROUTE_FUNC(..., $ROUTEVAR, ...):
                    ...
              - pattern-either:
                  - pattern: requests.$FUNC(..., <... $ROUTEVAR ...>, ...)
                  - pattern: |
                      $INTERM = <... $ROUTEVAR ...>
                      ...
                      requests.$FUNC(..., <... $INTERM ...>, ...)
          - patterns:
              - pattern-either:
                  - pattern: requests.$FUNC(..., <... flask.request.$W.get(...) ...>, ...)
                  - pattern: requests.$FUNC(..., <... flask.request.$W[...] ...>, ...)
                  - pattern: requests.$FUNC(..., <... flask.request.$W(...) ...>, ...)
                  - pattern: requests.$FUNC(..., <... flask.request.$W ...>, ...)
          - patterns:
              - pattern-either:
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W.get(...) ...>
                          ...
                          requests.$FUNC(<... $INTERM ...>, ...)
                      - pattern: requests.$FUNC(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W[...] ...>
                          ...
                          requests.$FUNC(<... $INTERM ...>, ...)
                      - pattern: requests.$FUNC(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W(...) ...>
                          ...
                          requests.$FUNC(<... $INTERM ...>, ...)
                      - pattern: requests.$FUNC(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W ...>
                          ...
                          requests.$FUNC(<... $INTERM ...>, ...)
                      - pattern: requests.$FUNC(...)
  - id: python.flask.security.injection.user-eval.eval-injection
    languages:
      - python
    severity: ERROR
    message:
      Detected user data flowing into eval. This is code injection and should
      be avoided.
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
      references:
        - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  @$APP.route($ROUTE, ...)
                  def $FUNC(..., $ROUTEVAR, ...):
                    ...
              - pattern-either:
                  - pattern: eval(..., <... $ROUTEVAR ...>, ...)
                  - pattern: |
                      $INTERM = <... $ROUTEVAR ...>
                      ...
                      eval(..., <... $INTERM ...>, ...)
          - patterns:
              - pattern-either:
                  - pattern: eval(..., <... flask.request.$W.get(...) ...>, ...)
                  - pattern: eval(..., <... flask.request.$W[...] ...>, ...)
                  - pattern: eval(..., <... flask.request.$W(...) ...>, ...)
                  - pattern: eval(..., <... flask.request.$W ...>, ...)
          - patterns:
              - pattern-either:
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W.get(...) ...>
                          ...
                          eval(..., <... $INTERM ...>, ...)
                      - pattern: eval(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W[...] ...>
                          ...
                          eval(..., <... $INTERM ...>, ...)
                      - pattern: eval(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W(...) ...>
                          ...
                          eval(..., <... $INTERM ...>, ...)
                      - pattern: eval(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W ...>
                          ...
                          eval(..., <... $INTERM ...>, ...)
                      - pattern: eval(...)
  - id: python.flask.security.injection.user-exec.exec-injection
    languages:
      - python
    severity: ERROR
    message:
      Detected user data flowing into exec. This is code injection and should
      be avoided.
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
      references:
        - https://nedbatchelder.com/blog/201206/exec_really_is_dangerous.html
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  @$APP.route($ROUTE, ...)
                  def $FUNC(..., $ROUTEVAR, ...):
                    ...
              - pattern-either:
                  - pattern: exec(..., <... $ROUTEVAR ...>, ...)
                  - pattern: |
                      $INTERM = <... $ROUTEVAR ...>
                      ...
                      exec(..., <... $INTERM ...>, ...)
          - patterns:
              - pattern-either:
                  - pattern: exec(..., <... flask.request.$W.get(...) ...>, ...)
                  - pattern: exec(..., <... flask.request.$W[...] ...>, ...)
                  - pattern: exec(..., <... flask.request.$W(...) ...>, ...)
                  - pattern: exec(..., <... flask.request.$W ...>, ...)
          - patterns:
              - pattern-either:
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W.get(...) ...>
                          ...
                          exec(..., <... $INTERM ...>, ...)
                      - pattern: exec(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W[...] ...>
                          ...
                          exec(..., <... $INTERM ...>, ...)
                      - pattern: exec(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W(...) ...>
                          ...
                          exec(..., <... $INTERM ...>, ...)
                      - pattern: exec(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W ...>
                          ...
                          exec(..., <... $INTERM ...>, ...)
                      - pattern: exec(...)
  - id: python.flask.security.insecure-deserialization.insecure-deserialization
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
      references:
        - https://docs.python.org/3/library/pickle.html
    message: |
      Detected the use of an insecure deserizliation library in a Flask route. These libraries
      are prone to code execution vulnerabilities. Ensure user data does not enter this function.
      To fix this, try to avoid serializing whole objects. Consider instead using a serializer
      such as JSON.
    languages:
      - python
    severity: ERROR
    patterns:
      - pattern-inside: |
          @app.route(...)
          def $X(...):
            ...
      - pattern-not: $MODULE.$FUNC("...")
      - pattern-not: $MODULE.$FUNC(open("...", ...))
      - pattern-either:
          - pattern: pickle.$FUNC(...)
          - pattern: _pickle.$FUNC(...)
          - pattern: cPickle.$FUNC(...)
          - pattern: dill.$FUNC(...)
          - pattern: shelve.$FUNC(...)
          - pattern: yaml.load(...)
  - id: python.jinja2.security.audit.autoescape-disabled.autoescape-disabled
    patterns:
      - pattern-not: jinja2.Environment(..., autoescape=True, ...)
      - pattern-not:
          jinja2.Environment(..., autoescape=jinja2.select_autoescape(...),
          ...)
      - pattern: jinja2.Environment(...)
    fix-regex:
      regex: (.*)\)
      replacement: \1, autoescape=True)
    message:
      Detected a Jinja2 environment without autoescaping. Jinja2 does not autoescape
      by default. This is dangerous if you are rendering to a browser because this allows
      for cross-site scripting (XSS) attacks. If you are in a web context, enable autoescaping
      by setting 'autoescape=True.' You may also consider using 'jinja2.select_autoescape()'
      to only enable automatic escaping for certain file extensions.
    metadata:
      cwe: "CWE-116: Improper Encoding or Escaping of Output"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://jinja.palletsprojects.com/en/2.11.x/api/#basics
    languages:
      - python
    severity: WARNING
  - id: python.lang.correctness.common-mistakes.default-mutable-dict.default-mutable-dict
    patterns:
      - pattern-either:
          - patterns:
              - pattern: |
                  def $F(..., $D={}, ...):
                    ...
                    $D[...] = ...
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = {}
                    ...
                    $D[...] = ...
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = dict(...)
                    ...
                    $D[...] = ...
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = $D.copy()
                    ...
                    $D[...] = ...
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = copy.deepcopy($D)
                    ...
                    $D[...] = ...
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = copy.copy($D)
                    ...
                    $D[...] = ...
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = dict.copy($D)
                    ...
                    $D[...] = ...
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = {... for ... in ...}
                    ...
                    $D[...] = ...
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = $D or {}
                    ...
                    $D[...] = ...
              - pattern-not-inside: |
                  def $A(...):
                    ...
                    def $F(..., $D={}, ...):
                      ...
                      $D[...] = ...
          - patterns:
              - pattern: |
                  def $F(..., $D={}, ...):
                    ...
                    $D.update(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = {}
                    ...
                    $D.update(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = dict(...)
                    ...
                    $D.update(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = $D.copy()
                    ...
                    $D.update(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = copy.deepcopy($D)
                    ...
                    $D.update(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = copy.copy($D)
                    ...
                    $D.update(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = dict.copy($D)
                    ...
                    $D.update(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = {... for ... in ...}
                    ...
                    $D.update(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = $D or {}
                    ...
                    $D.update(...)
              - pattern-not-inside: |
                  def $A(...):
                    ...
                    def $F(..., $D={}, ...):
                      ...
                      $D.update(...)
          - patterns:
              - pattern: |
                  def $F(..., $D={}, ...):
                    ...
                    $D.setdefault(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = {}
                    ...
                    $D.setdefault(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = dict(...)
                    ...
                    $D.setdefault(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = $D.copy()
                    ...
                    $D.setdefault(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = copy.deepcopy($D)
                    ...
                    $D.setdefault(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = copy.copy($D)
                    ...
                    $D.setdefault(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = dict.copy($D)
                    ...
                    $D.setdefault(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = {... for ... in ...}
                    ...
                    $D.setdefault(...)
              - pattern-not: |
                  def $F(..., $D={}, ...):
                    ...
                    $D = $D or {}
                    ...
                    $D.setdefault(...)
              - pattern-not-inside: |
                  def $A(...):
                    ...
                    def $F(..., $D={}, ...):
                      ...
                      $D.setdefault(...)
    message:
      "Function $F mutates default dict $D. Python only instantiates default
      function arguments once and shares the instance across the function calls. If
      the default function argument is mutated, that will modify the instance used by
      all future function calls. This can cause unexpected results, or lead to security
      vulnerabilities whereby one function consumer can view or modify the data of another
      function consumer. Instead, use a default argument (like None) to indicate that
      no argument was provided and instantiate a new dictionary at that time. For example:
      `if $D is None: $D = {}`."
    languages:
      - python
    severity: ERROR
  - id: python.lang.correctness.common-mistakes.default-mutable-list.default-mutable-list
    patterns:
      - pattern-either:
          - patterns:
              - pattern: |
                  def $F(..., $D=[], ...):
                    ...
                    $D.append(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = []
                    ...
                    $D.append(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = [...]
                    ...
                    $D.append(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = list(...)
                    ...
                    $D.append(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = copy.deepcopy($D)
                    ...
                    $D.append(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = copy.copy($D)
                    ...
                    $D.append(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = list.copy($D)
                    ...
                    $D.append(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = $D[:]
                    ...
                    $D.append(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = [... for ... in ...]
                    ...
                    $D.append(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = $D or []
                    ...
                    $D.append(...)
              - pattern-not-inside: |
                  def $A(...):
                    ...
                    def $F(..., $D=[], ...):
                      ...
                      $D.append(...)
          - patterns:
              - pattern: |
                  def $F(..., $D=[], ...):
                    ...
                    $D.extend(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = []
                    ...
                    $D.extend(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = [...]
                    ...
                    $D.extend(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = list(...)
                    ...
                    $D.extend(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = copy.deepcopy($D)
                    ...
                    $D.extend(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = copy.copy($D)
                    ...
                    $D.extend(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = list.copy($D)
                    ...
                    $D.extend(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = $D[:]
                    ...
                    $D.extend(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = [... for ... in ...]
                    ...
                    $D.extend(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = $D or []
                    ...
                    $D.extend(...)
              - pattern-not-inside: |
                  def $A(...):
                    ...
                    def $F(..., $D=[], ...):
                      ...
                      $D.extend(...)
          - patterns:
              - pattern: |
                  def $F(..., $D=[], ...):
                    ...
                    $D.insert(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = []
                    ...
                    $D.insert(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = [...]
                    ...
                    $D.insert(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = list(...)
                    ...
                    $D.insert(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = copy.deepcopy($D)
                    ...
                    $D.insert(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = copy.copy($D)
                    ...
                    $D.insert(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = list.copy($D)
                    ...
                    $D.insert(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = $D[:]
                    ...
                    $D.insert(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = [... for ... in ...]
                    ...
                    $D.insert(...)
              - pattern-not: |
                  def $F(..., $D=[], ...):
                    ...
                    $D = $D or []
                    ...
                    $D.insert(...)
              - pattern-not-inside: |
                  def $A(...):
                    ...
                    def $F(..., $D=[], ...):
                      ...
                      $D.insert(...)
    message:
      "Function $F mutates default list $D. Python only instantiates default
      function arguments once and shares the instance across the function calls. If
      the default function argument is mutated, that will modify the instance used by
      all future function calls. This can cause unexpected results, or lead to security
      vulnerabilities whereby one function consumer can view or modify the data of another
      function consumer. Instead, use a default argument (like None) to indicate that
      no argument was provided and instantiate a new list at that time. For example:
      `if $D is None: $D = []`."
    languages:
      - python
    severity: ERROR
  - id: python.lang.correctness.common-mistakes.is-comparison-string.string-is-comparison
    patterns:
      - pattern-not: $S is None
      - pattern-not: type($X) is $T
      - pattern-not: $S is True
      - pattern-not: $S is False
      - pattern-not: $S is ""
      - pattern-either:
          - pattern: $S is "..."
          - pattern: '"..." is $S'
    message: |
      Found string comparison using 'is' operator. The 'is' operator
      is for reference equality, not value equality, and therefore should
      not be used to compare strings. For more information, see
      https://github.com/satwikkansal/wtfpython#-how-not-to-use-is-operator"
    languages:
      - python
    severity: ERROR
  - id: python.lang.correctness.common-mistakes.is-not-is-not.is-not-is-not
    patterns:
      - pattern: $S is (not ...)
    message:
      In python 'X is not ...' is different from 'X is (not ...)'. In the latter
      the 'not' converts the '...' directly to boolean.
    languages:
      - python
    severity: ERROR
  - id: python.lang.correctness.dict-modify-iterating.dict-del-while-iterate
    patterns:
      - pattern-either:
          - pattern: |
              for $KEY, $VALUE in $DICT.items():
                  ...
                  del $DICT[$KEY]
          - pattern: |
              for $KEY in $DICT.keys():
                  ...
                  del $DICT[$KEY]
    message:
      "It appears that `$DICT[$KEY]` is a dict with items being deleted while
      in a for loop. This is usually a bad idea and will likely lead to a RuntimeError:
      dictionary changed size during iteration"
    languages:
      - python
    severity: WARNING
  - id: python.lang.correctness.list-modify-iterating.list-modify-while-iterate
    patterns:
      - pattern-either:
          - pattern: |
              for $ELEMENT in $LIST:
                ...
                $LIST.pop(...)
          - pattern: |
              for $ELEMENT in $LIST:
                ...
                $LIST.push(...)
          - pattern: |
              for $ELEMENT in $LIST:
                ...
                $LIST.append(...)
          - pattern: |
              for $ELEMENT in $LIST:
                ...
                $LIST.extend(...)
    message: |
      It appears that `$LIST` is a list that is being modified while in a for loop.
      This will likely cause a runtime error or an infinite loop.
    languages:
      - python
    severity: ERROR
  - id: python.lang.correctness.return-in-init.return-in-init
    patterns:
      - pattern-inside: |
          class A(...):
              ...
              def __init__(...):
                  ...
      - pattern: return ...
    message:
      "`return` should never appear inside a class __init__ function. This will
      cause a runtime error."
    languages:
      - python
    severity: ERROR
  - id: python.lang.correctness.return-in-init.yield-in-init
    patterns:
      - pattern-inside: |
          class $A(...):
              ...
      - pattern-inside: |
          def __init__(...):
              ...
      - pattern-either:
          - pattern: |
              yield ...
          - pattern: |
              yield
    message:
      "`yield` should never appear inside a class __init__ function. This will
      cause a runtime error."
    languages:
      - python
    severity: ERROR
  - id: python.lang.correctness.tempfile.flush.tempfile-without-flush
    pattern-either:
      - patterns:
          - pattern-not-inside: |
              $F = tempfile.NamedTemporaryFile(...)
              ...
              $F.write(...)
              ...
              $F.flush()
              ...
              $F.name
          - pattern-not-inside: |
              $F = tempfile.NamedTemporaryFile(...)
              ...
              $F.write(...)
              ...
              $F.close()
              ...
              $F.name
          - pattern-not-inside: |
              $F = tempfile.NamedTemporaryFile(..., delete=False, ...)
              ...
              $F.close()
              ...
              $F.name
          - pattern-inside: |
              $F = tempfile.NamedTemporaryFile(...)
              ...
          - pattern: |
              $F.name
      - patterns:
          - pattern-not-inside: |
              with tempfile.NamedTemporaryFile(...) as $F:
                  ...
                  $F.write(...)
                  ...
                  $F.flush()
                  ...
                  $F.name
          - pattern-not-inside: |
              with tempfile.NamedTemporaryFile(...) as $F:
                  ...
                  $F.write(...)
                  ...
                  $F.close()
                  ...
                  $F.name
          - pattern-inside: |
              with tempfile.NamedTemporaryFile(...) as $F:
                  ...
          - pattern: |
              $F.name
    message:
      Using '$F.name' without '.flush()' or '.close()' may cause an error because
      the file may not exist when '$F.name' is used. Use '.flush()' or close the file
      before using '$F.name'.
    languages:
      - python
    severity: ERROR
  - id: python.lang.correctness.useless-comparison.no-strings-as-booleans
    patterns:
      - pattern-either:
          - pattern: |
              if <... "..." and ... ...>:
                  ...
          - pattern: |
              if <... "..." or ... ...>:
                  ...
          - patterns:
              - pattern-not: |
                  if $X in "...":
                    ...
              - pattern: |
                  if "...":
                      ...
    message: |
      Using strings as booleans in Python has unexpected results.
      `"one" and "two"` will return "two".
      `"one" or "two"` will return "one".
       In Python, strings are truthy, and strings with a non-zero length evaluate to True.
    languages:
      - python
    severity: ERROR
  - id: python.lang.correctness.useless-eqeq.useless-eqeq
    patterns:
      - pattern-not-inside: |
          def __eq__(...):
              ...
      - pattern-not-inside: |
          def __cmp__(...):
              ...
      - pattern-not-inside: assert(...)
      - pattern-not-inside: assert ...
      - pattern-not-inside: assert ..., ...
      - pattern-not-inside: assertTrue(...)
      - pattern-not-inside: assertFalse(...)
      - pattern-either:
          - pattern: $X == $X
          - pattern: $X != $X
      - pattern-not: 1 == 1
    message:
      "This expression is always True: `$X == $X` or `$X != $X`. If testing for
      floating point NaN, use `math.isnan($X)`, or `cmath.isnan($X)` if the number is
      complex."
    languages:
      - python
    severity: ERROR
  - id: python.lang.maintainability.useless-ifelse.useless-if-conditional
    patterns:
      - pattern-either:
          - pattern: |
              if $X:
                  ...
              elif $X:
                  ...
    message: if block checks for the same condition on both branches (`$X`)
    languages:
      - python
    severity: WARNING
  - id: python.lang.maintainability.useless-literal.useless-literal-dict
    patterns:
      - pattern-either:
          - pattern: |
              {..., $X: $A, ..., $X: $B, ...}
          - pattern: |
              dict(..., ($X, $A), ..., ($X, $B), ...)
    message: key `$X` is uselessly assigned twice
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.weak-ssl-version.weak-ssl-version
    patterns:
      - pattern-either:
          - pattern: ssl.PROTOCOL_SSLv2
          - pattern: ssl.PROTOCOL_SSLv3
          - pattern: ssl.PROTOCOL_TLSv1
          - pattern: ssl.PROTOCOL_TLSv1_1
          - pattern: pyOpenSSL.SSL.SSLv2_METHOD
          - pattern: pyOpenSSL.SSL.SSLv23_METHOD
          - pattern: pyOpenSSL.SSL.SSLv3_METHOD
          - pattern: pyOpenSSL.SSL.TLSv1_METHOD
          - pattern: pyOpenSSL.SSL.TLSv1_1_METHOD
    message: |
      An insecure SSL version was detected. TLS versions 1.0, 1.1, and all SSL versions
      are considered weak encryption and are deprecated.
      Use 'ssl.PROTOCOL_TLSv1_2' or higher.
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/insecure_ssl_tls.py#L30
      references:
        - https://tools.ietf.org/html/rfc7568
        - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
        - https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLSv1_2
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
    pattern: hashlib.md5(...)
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B303
      references:
        - https://tools.ietf.org/html/rfc6151
        - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
    pattern: hashlib.sha1(...)
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B303
      references:
        - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
        - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
        - http://2012.sharcs.org/slides/stevens.pdf
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.lang.security.unquoted-csv-writer.unquoted-csv-writer
    patterns:
      - pattern-not: csv.writer(..., quoting=csv.QUOTE_ALL, ...)
      - pattern: csv.writer(...)
    message: Found an unquoted CSV writer. This is susceptible to injection. Use 'quoting=csv.QUOTE_ALL'.
    metadata:
      cwe: "CWE-1236: Improper Neutralization of Formula Elements in a CSV File"
      owasp: "A1: Injection"
      references:
        - https://affinity-it-security.com/how-to-prevent-csv-injection/
    fix-regex:
      regex: (.*)\)
      replacement: \1, quoting=csv.QUOTE_ALL)
    languages:
      - python
    severity: ERROR
  - id: python.lang.security.unverified-ssl-context.unverified-ssl-context
    pattern: ssl._create_unverified_context(...)
    message: |
      Unverified SSL context detected. This will permit insecure connections without verifying
      SSL certificates. Use 'ssl.create_default_context()' instead.
    metadata:
      owasp: "A6: Security Misconfiguration"
      cwe: "CWE-295: Improper Certificate Validation"
      references:
        - https://docs.python.org/3/library/ssl.html#ssl-security
        - https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    severity: ERROR
    languages:
      - python
  - id: python.lang.security.use-defused-xml.use-defused-xml
    pattern-either:
      - pattern: import xml
    fix-regex:
      regex: xml
      replacement: defusedxml
    metadata:
      owasp: "A4: XML External Entities (XXE)"
      cwe: "CWE-611: Improper Restriction of XML External Entity Reference"
      references:
        - https://docs.python.org/3/library/xml.html
        - https://github.com/tiran/defusedxml
    message: |
      Found use of the native Python XML libraries, which is vulnerable to XML external entity (XXE)
      attacks. The Python documentation recommends the 'defusedxml' library instead. Use 'defusedxml'.
      See https://github.com/tiran/defusedxml for more information.
    languages:
      - python
    severity: ERROR
  - id: python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc
    pattern-either:
      - pattern: import xmlrpclib
      - pattern: import SimpleXMLRPCServer
      - pattern: import xmlrpc
    message: |
      Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities.
      Use defusedxml.xmlrpc instead.
    metadata:
      cwe:
        "CWE-776: Improper Restriction of Recursive Entity References in DTDs ('XML
        Entity Expansion')"
      owasp: "A4: XML External Entities (XXE)"
      source-rule-url: https://github.com/PyCQA/bandit/blob/07f84cb5f5e7c1055e6feaa0fe93afa471de0ac3/bandit/blacklists/imports.py#L160
      references:
        - https://pypi.org/project/defusedxml/
        - https://docs.python.org/3/library/xml.html#xml-vulnerabilities
    severity: ERROR
    languages:
      - python
  - id: python.lang.security.audit.logging.listeneval.listen-eval
    languages:
      - python
    message: |
      Because portions of the logging configuration are passed through eval(),
      use of this function may open its users to a security risk. While the
      function only binds to a socket on localhost, and so does not accept
      connections from remote machines, there are scenarios where untrusted
      code could be run under the account of the process which calls listen().
      See more details at https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
    patterns:
      - pattern: logging.config.listen(...)
    severity: WARNING
  - id: python.lang.security.audit.logging.logger-credential-leak.python-logger-credential-disclosure
    patterns:
      - pattern: |
          logger.$LOGGER_CALL($FORMAT_STRING,...)
      - metavariable-regex:
          metavariable: $LOGGER_CALL
          regex: (info|error|exception)
      - metavariable-regex:
          metavariable: $FORMAT_STRING
          regex: (?i).*(api.key|secret|credential|token).*\%s.*
    message: |
      Logger call may be exposing a secret credential in $FORMAT_STRING
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-blowfish
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.Blowfish.new(...)
          - pattern: Crypto.Cipher.Blowfish.new(...)
    message: |
      Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-des
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.DES.new(...)
          - pattern: Crypto.Cipher.DES.new(...)
    message: |
      Detected DES cipher algorithm which is considered insecure. The algorithm is
      considered weak and has been deprecated. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://tools.ietf.org/html/rfc5469
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc2
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.ARC2.new(...)
          - pattern: Crypto.Cipher.ARC2.new
    message: |
      Detected RC2 cipher algorithm which is considered insecure. The algorithm has known vulnerabilities and is difficult to use securely. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://security.stackexchange.com/questions/93924/is-rc2-cbc-at-all-secure
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc4
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.ARC4.new(...)
          - pattern: Crypto.Cipher.ARC4.new(...)
    message: |
      Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-xor
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.XOR.new(...)
          - pattern: Crypto.Cipher.XOR.new(...)
    message: |
      Detected XOR cipher algorithm which is considered insecure. This algorithm
      is not cryptographically secure and can be reversed easily. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md2
    patterns:
      - pattern-either:
          - pattern: Crypto.Hash.MD2.new(...)
          - pattern: Cryptodome.Hash.MD2.new (...)
    message: |
      Detected MD2 hash algorithm which is considered insecure. This algorithm
      has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://tools.ietf.org/html/rfc6149
        - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2409
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md4
    patterns:
      - pattern-either:
          - pattern: Crypto.Hash.MD4.new(...)
          - pattern: Cryptodome.Hash.MD4.new (...)
    message: |
      Detected MD4 hash algorithm which is considered insecure. This algorithm
      has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://tools.ietf.org/html/rfc6150
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md5
    patterns:
      - pattern-either:
          - pattern: Crypto.Hash.MD5.new(...)
          - pattern: Cryptodome.Hash.MD5.new (...)
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://tools.ietf.org/html/rfc6151
        - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-sha1
    patterns:
      - pattern-either:
          - pattern: Crypto.Hash.SHA.new(...)
          - pattern: Cryptodome.Hash.SHA.new (...)
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
        - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
        - http://2012.sharcs.org/slides/stevens.pdf
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.requests.security.disabled-cert-validation.disabled-cert-validation
    patterns:
      - pattern-either:
          - pattern: requests.put(..., verify=False, ...)
          - pattern: requests.patch(..., verify=False, ...)
          - pattern: requests.delete(..., verify=False, ...)
          - pattern: requests.head(..., verify=False, ...)
          - pattern: requests.options(..., verify=False, ...)
          - pattern: requests.request(..., verify=False, ...)
          - pattern: requests.get(..., verify=False, ...)
          - pattern: requests.post(..., verify=False, ...)
    message: |
      Certificate verification has been explicitly disabled. This
      permits insecure connections to insecure servers. Re-enable
      certification validation.
    metadata:
      cwe: "CWE-295: Improper Certificate Validation"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://stackoverflow.com/questions/41740361/is-it-safe-to-disable-ssl-certificate-verification-in-pythonss-requests-lib
    languages:
      - python
    severity: ERROR
  - id: python.requests.security.no-auth-over-http.no-auth-over-http
    patterns:
      - pattern-either:
          - pattern: requests.$W("=~/http:\/\/.*/", ..., auth=$X, ...)
          - pattern: |
              $URL = "=~/http:\/\/.../"
              ...
              requests.$W($URL, ..., auth=$X, ...)
    fix-regex:
      regex: http:\/\/
      replacement: https://
      count: 1
    message: |
      Authentication detected over HTTP. HTTP does not provide any
      encryption or protection for these authentication credentials.
      This may expose these credentials to unauthhorized parties.
      Use 'https://' instead.
    metadata:
      cwe: "CWE-523: Unprotected Transport of Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://pypi.org/project/flake8-flask/
      references:
        - https://blog.r2c.dev/2020/bento-check-no-auth-over-http/
        - https://bento.dev/checks/requests/no-auth-over-http/
    languages:
      - python
    severity: ERROR
  - id: python.sqlalchemy.security.sqlalchemy-sql-injection.sqlalchemy-sql-injection
    patterns:
      - pattern-either:
          - pattern: |
              def $FUNC(...,$VAR,...):
                ...
                $SESSION.query(...).$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
          - pattern: |
              def $FUNC(...,$VAR,...):
                ...
                $SESSION.query.join(...).$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
          - pattern: |
              def $FUNC(...,$VAR,...):
                ...
                $SESSION.query.$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
          - pattern: |
              def $FUNC(...,$VAR,...):
                ...
                query.$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
      - metavariable-regex:
          metavariable: $SQLFUNC
          regex: (group_by|order_by|distinct|having|filter)
      - metavariable-regex:
          metavariable: $FORMATFUNC
          regex: (?!bindparams)
    message: |
      Distinct, Having, Group_by, Order_by, and Filter in SQLAlchemy can cause sql injections
      if the developer inputs raw SQL into the before-mentioned clauses.
      This pattern captures relevant cases in which the developer inputs raw SQL into the distinct, having, group_by, order_by or filter clauses and
      injects user-input into the raw SQL with any function besides "bindparams". Use bindParams to securely bind user-input
      to SQL statements.
    fix-regex:
      regex: format
      replacement: bindparams
    languages:
      - python
    severity: WARNING
  - id: ruby.jwt.security.jwt-exposed-credentials.ruby-jwt-exposed-credentials
    languages:
      - ruby
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      references:
        - https://cwe.mitre.org/data/definitions/522.html
    message: |
      Password is exposed through JWT token payload. This is not encrypted and
      the password could be compromised. Do not store passwords in JWT tokens.
    patterns:
      - pattern-inside: |
          require 'jwt'
          ...
      - pattern: |
          $PAYLOAD = {...,password:...,...}
          ...
          JWT.encode($PAYLOAD,...)
    severity: ERROR
  - id: ruby.jwt.security.jwt-none-alg.ruby-jwt-none-alg
    message: |
      Detected use of the 'none' algorithm in a JWT token.
      The 'none' algorithm assumes the integrity of the token has already
      been verified. This would allow a malicious actor to forge a JWT token
      that will automatically be verified. Do not explicitly use the 'none'
      algorithm. Instead, use an algorithm such as 'HS256'.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    languages:
      - ruby
    severity: ERROR
    patterns:
      - pattern-inside: |
          require 'jwt'
          ...
      - pattern: |
          JWT.encode($PAYLOAD, $SECRET, 'none', ...)
  - id: ruby.jwt.security.jwt-hardcode.ruby-jwt-hardcoded-secret
    message: |
      Hardcoded JWT secret or private key is used.
      This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
      Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables)
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    patterns:
      - pattern-inside: |
          require 'jwt'
          ...
      - pattern-either:
          - pattern: |
              JWT.encode($PAYLOAD,"...",...)
          - pattern: |
              JWT.decode($PAYLOAD,"...",...)
          - pattern: |
              JWT.encode($PAYLOAD,nil,...)
          - pattern: |
              JWT.decode($PAYLOAD,nil,...)
          - pattern: |
              $SECRET = "..."
              ...
              JWT.encode($PAYLOAD,$SECRET,...)
          - pattern: |
              $SECRET = "..."
              ...
              JWT.decode($PAYLOAD,$SECRET,...)
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.ssl-mode-no-verify.ssl-mode-no-verify
    pattern: OpenSSL::SSL::VERIFY_NONE
    message: |
      Detected SSL that will accept an unverified connection.
      This makes the connections susceptible to man-in-the-middle attacks.
      Use 'OpenSSL::SSL::VERIFY_PEER' intead.
    fix-regex:
      regex: VERIFY_NONE
      replacement: VERIFY_PEER
    severity: WARNING
    languages:
      - ruby
  - id: ruby.lang.security.hardcoded-http-auth-in-controller.hardcoded-http-auth-in-controller
    pattern: |
      class $CONTROLLER < ApplicationController
        ...
        http_basic_authenticate_with ..., :password => "...", ...
      end
    message: |
      Detected hardcoded password used in basic authentication in a controller
      class. Including this password in version control could expose this
      credential. Consider refactoring to use environment variables or
      configuration files.
    severity: ERROR
    metadata:
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/basic_auth/index.markdown
    languages:
      - ruby
  - id: ruby.lang.security.filter-skipping.filter-skipping
    patterns:
      - pattern-not: |
          $CALL "=~/.*(/:action.*).*/", $ACTION
      - pattern: |
          $CALL "=~/.*(/:action.*).*/"
    message: |
      Checks for use of action in Ruby routes. This can cause Rails to render an arbitrary view if an
      attacker creates an URL accurately. Affects 3.0 applications. Can avoid the vulnerability by providing
      additional constraints.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_filter_skipping.rb
        - https://groups.google.com/g/rubyonrails-security/c/NCCsca7TEtY
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.missing-csrf-protection.missing-csrf-protection
    patterns:
      - pattern: |
          class $CONTROLLER < ActionController::Base
            ...
          end
      - pattern-not: |
          class $CONTROLLER < ActionController::Base
            ...
            protect_from_forgery :with => :exception
          end
      - pattern-not: |
          class $CONTROLLER < ActionController::Base
            ...
            protect_from_forgery prepend: true, with: :exception
          end
    message: |
      Detected controller which does not enable cross-site request forgery
      protections using 'protect_from_forgery'. Add
      'protect_from_forgery :with => :exception' to your controller class.
    severity: ERROR
    metadata:
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross-site_request_forgery/index.markdown
    languages:
      - ruby
  - id: ruby.lang.security.bad-deserialization.bad-deserialization
    patterns:
      - pattern-either:
          - pattern: |
              YAML.load(...)
          - pattern: |
              CSV.load(...)
          - pattern: |
              Marshal.load(...)
          - pattern: |
              Marshal.restore(...)
          - pattern: |
              $OBJ.object_load(...)
      - pattern-not: |
          YAML.load(..., safe: true, ...)
    message: |
      Checks for unsafe deserialization. Objects in Ruby can be serialized into strings,
      then later loaded from strings. However, uses of load and object_load can cause remote code execution.
      Loading user input with YAML, MARSHAL, or CSV can potentially be dangerous. Use JSON securely instead.
    metadata:
      references:
        - https://groups.google.com/g/rubyonrails-security/c/61bkgvnSGTQ/m/nehwjA8tQ8EJ
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_deserialize.rb
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.force-ssl-false.force-ssl-false
    patterns:
      - pattern: |
          config.force_ssl = false
    message: |
      Checks for configuration setting of force_ssl to false. Force_ssl forces usage of HTTPS, which
      could lead to network interception of unencrypted application traffic. To fix, set config.force_ssl = true.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_force_ssl.rb
    languages:
      - ruby
    severity: WARNING
  - id: ruby.lang.security.mass-assignment-protection-disabled.mass-assignment-protection-disabled
    pattern: $MODEL.new(params[...], ..., :without_protection => true, ...)
    message: |
      Mass assignment protection disabled for '$MODEL'. This could
      permit assignment to sensitive model fields without intention. Instead,
      use 'attr_accessible' for the model or disable mass assigment using
      'config.active_record.whitelist_attributes = true'.
      ':without_protection => true' must be removed for this to take effect.
    metadata:
      cwe:
        "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
        Attributes"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/mass_assignment/index.markdown
    severity: WARNING
    languages:
      - ruby
  - id: ruby.lang.security.file-disclosure.file-disclosure
    patterns:
      - pattern: |
          config.serve_static_assets = true
    message: |
      Special requests can determine whether a file exists on a filesystem that's outside the Ruby app's
      root directory. To fix this, set config.serve_static_assets = false.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_file_disclosure.rb
        - https://groups.google.com/g/rubyonrails-security/c/23fiuwb1NBA/m/MQVM1-5GkPMJ
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.jruby-xml.jruby-xml
    patterns:
      - pattern: |
          XmlMini.backend = $STR
      - pattern-not: |
          XmlMini.backend = "REXML"
    message: |
      The JDOM backend for XmlMini has a vulnerability that lets an attacker perform a denial of service attack
      or gain access to files on the application server. This affects versions 3.0, but is fixed in versions
      3.1.12 and 3.2.13. To fix, either upgrade or use XmlMini.backend="REXML".
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_jruby_xml.rb
    languages:
      - ruby
    severity: WARNING
  - id: ruby.lang.security.yaml-parsing.yaml-parsing
    patterns:
      - pattern: ActionController::Base.param_parsers[Mime::YAML] = :yaml
    message: |
      Detected enabled YAML parsing. This is vulnerable to remote code execution in Rails 2.x
      versions up to 2.3.14. To fix, delete this line.
    fix-regex:
      regex: ActionController.*:yaml
      replacement: " "
    severity: WARNING
    languages:
      - ruby
  - id: ruby.lang.security.json-entity-escape.json-entity-escape
    pattern-either:
      - pattern: |
          ActiveSupport.escape_html_entities_in_json = false
      - pattern: |
          config.active_support.escape_html_entities_in_json = false
    message: |
      Checks if HTML escaping is globally disabled for JSON output. This could lead to XSS.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_json_entity_escape.rb
    languages:
      - ruby
    severity: WARNING
  - id: ruby.lang.security.divide-by-zero.divide-by-zero
    patterns:
      - pattern-either:
          - pattern: |
              $X / 0
          - pattern: |
              $ZERO = 0
              ...
              $X / $ZERO
    message: |
      Checks for divide by zero. Best practice involves not dividing a variable by zero, as this leads to a Ruby
      ZeroDivisionError.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_divide_by_zero.rb
    languages:
      - ruby
    severity: WARNING
  - id: ruby.rails.security.audit.xss.templates.alias-for-html-safe.alias-for-html-safe
    message: ""
    metadata:
      references:
        - https://medium.com/sumone-technical-blog/a-pretty-way-to-unescape-html-in-a-ruby-on-rails-application-efc22b850027
        - https://stackoverflow.com/questions/4251284/raw-vs-html-safe-vs-h-to-unescape-html#:~:text===
    languages:
      - none
    paths:
      include:
        - "*.erb"
    severity: WARNING
    pattern-regex: <%==.*?%>
  - id: typescript.react.security.react-controlled-component-password.react-controlled-component-password
    pattern-either:
      - pattern: <$EL type="password" value={this.state.$X} onChange=...  />
      - pattern: |
          React.createElement($EL,{type: 'password', value: this.state.$X, onChange:...},...)
      - pattern: |
          $PARAMS = {type: 'password', value: this.state.$X, onChange:...};
          ...
          React.createElement($EL,$PARAMS,...);
    message: |
      Password can be leaked if CSS injection exists on the page.
    metadata:
      references:
        - https://no-csp-css-keylogger.badsite.io/
    languages:
      - typescript
      - javascript
    severity: WARNING
  - id: typescript.react.security.react-markdown-insecure-html.react-markdown-insecure-html
    patterns:
      - pattern-either:
          - pattern-inside: |
              $X = require('react-markdown/with-html');
              ...
          - pattern-inside: |
              $X = require('react-markdown');
              ...
          - pattern-inside: |
              import 'react-markdown/with-html';
              ...
          - pattern-inside: |
              import 'react-markdown';
              ...
      - pattern-either:
          - pattern: |
              <$EL allowDangerousHtml />
          - pattern: |
              <$EL transformLinkUri=... />
          - pattern: |
              <$EL transformImageUri=... />
    message: |
      Overwriting `transformLinkUri` or `transformImageUri` to something insecure or turning `allowDangerousHtml` on, will open code up to XSS vectors.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://www.npmjs.com/package/react-markdown#security
    languages:
      - typescript
      - javascript
    severity: WARNING
  - id: typescript.react.security.audit.react-dangerouslysetinnerhtml.react-dangerouslysetinnerhtml
    pattern-either:
      - pattern: |
          <$X dangerouslySetInnerHTML=... />
      - pattern: |
          {dangerouslySetInnerHTML: ...}
    message:
      "Setting HTML from code is risky because it\u2019s easy to inadvertently
      expose your users to a cross-site scripting (XSS) attack.\n"
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml
    languages:
      - typescript
      - javascript
    severity: WARNING
  #- id: typescript.react.security.audit.react-css-injection.react-css-injection
  #  patterns:
  #  - pattern-either:
  #    - pattern-inside: |
  #        import $STYLE from "...";
  #        ...
  #    - pattern-inside: |
  #        $STYLE = $METHOD(...);
  #        ...
  #    - pattern-inside: |
  #        function $FUNC(...,{$STYLE},...) {
  #          ...
  #        }
  #    - pattern-inside: |
  #        function $FUNC(...,$STYLE,...) {
  #          ...
  #        }
  #  - pattern-inside: |
  #      <$EL style={$STYLE} />
  #  - pattern-not-inside: |
  #      <$EL style={{$X:...}} />
  #  - pattern: $STYLE
  #  message: |
  #    User controlled data in a `style` attribute is an anti-pattern than can lead to XSS vulnerabilities
  #  metadata:
  #    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
  #      Scripting'')'
  #    owasp: 'A7: Cross-site Scripting (XSS)'
  #  languages:
  #  - typescript
  #  - javascript
  #  severity: WARNING
  - id: generic.dockerfile.correctness.alias-must-be-unique.alias-must-be-unique
    severity: ERROR
    languages:
      - generic
    patterns:
      - pattern-either:
          - pattern: |
              FROM ... as $REF
              ...
              ...
              FROM ... as $REF
          - pattern: |
              FROM ... AS $REF
              ...
              ...
              FROM ... AS $REF
      - pattern-not-inside: |
          FROM ... as $REF
          ...
          ...
          FROM ... as $REF-
      - pattern-not-inside: |
          FROM ... AS $REF
          ...
          ...
          FROM ... AS $REF-
    paths:
      include:
        - "*dockerfile*"
        - "*Dockerfile*"
    message:
      Image aliases must have a unique name, and '$REF' is used twice. Use another
      name for '$REF'.
    metadata:
      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3024
      references:
        - https://github.com/hadolint/hadolint/wiki/DL3024
  - id: generic.dockerfile.correctness.copy-from-own-alias.copy-from-own-alias
    severity: ERROR
    languages:
      - generic
    patterns:
      - pattern-either:
          - pattern: |
              FROM $IMAGE:$TAG as $REF
              ...
              COPY --from=$REF
              ...
              FROM
          - pattern: |
              FROM $IMAGE:$TAG AS $REF
              ...
              COPY --from=$REF
              ...
              FROM
    message:
      COPY instructions cannot copy from its own alias. The '$REF' alias is used
      before switching to a new image. If you meant to switch to a new image, include
      a new 'FROM' statement. Otherwise, remove the '--from=$REF' from the COPY statement.
    metadata:
      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3023
      references:
        - https://github.com/hadolint/hadolint/wiki/DL3023
    paths:
      include:
        - "*dockerfile*"
        - "*Dockerfile*"
  - id: generic.dockerfile.correctness.invalid-port.invalid-port
    patterns:
      - pattern-either:
          - patterns:
              - pattern: EXPOSE $PORT
              - metavariable-comparison:
                  metavariable: $PORT
                  comparison: $PORT > 65535
          - pattern: EXPOSE -$PORT
    message: Detected an invalid port number. Valid ports are 0 through 65535.
    severity: ERROR
    languages:
      - generic
    metadata:
      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3011
      references:
        - https://github.com/hadolint/hadolint/wiki/DL3011
    paths:
      include:
        - "*dockerfile*"
        - "*Dockerfile*"
  - id: generic.dockerfile.correctness.multiple-cmd-instructions.multiple-cmd-instructions
    severity: ERROR
    languages:
      - generic
    pattern: |
      CMD ...
      ...
      CMD ...
    message: |
      Multiple CMD instructions were found. Only the last one will take effect.
    metadata:
      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL4003
      references:
        - https://github.com/hadolint/hadolint/wiki/DL4003
        - https://kapeli.com/cheat_sheets/Dockerfile.docset/Contents/Resources/Documents/index#//dash_ref_Instructions/Entry/CMD/0
    paths:
      include:
        - "*dockerfile*"
        - "*Dockerfile*"
  - id: generic.dockerfile.correctness.multiple-entrypoint-instructions.multiple-entrypoint-instructions
    severity: ERROR
    languages:
      - generic
    pattern: |
      ENTRYPOINT ...
      ...
      ENTRYPOINT ...
    message: |
      Multiple ENTRYPOINT instructions were found. Only the last one will take effect.
    metadata:
      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL4004
      references:
        - https://github.com/hadolint/hadolint/wiki/DL4004
        - https://kapeli.com/cheat_sheets/Dockerfile.docset/Contents/Resources/Documents/index#//dash_ref_Instructions/Entry/ENTRYPOINT/0
    paths:
      include:
        - "*dockerfile*"
        - "*Dockerfile*"
