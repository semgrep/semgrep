rules:
  - id: c.lang.security.insecure-use-gets-fn.insecure-use-gets-fn
    pattern: gets(...)
    message: |
      Avoid 'gets()'. This function does not consider buffer boundaries and can lead
      to buffer overflows. Use 'fgets()' or 'gets_s()' instead.
    metadata:
      references:
        - https://us-cert.cisa.gov/bsi/articles/knowledge/coding-practices/fgets-and-gets_s
    languages:
      - c
    severity: ERROR
  - id: c.lang.security.insecure-use-printf-fn.insecure-use-printf-fn
    patterns:
      - pattern-either:
          - pattern: |
              $FUNC($BUFFER, argv[$NUM], ...);
              ...
              vsprintf(..., $BUFFER, ...);
          - pattern: vsprintf(..., argv[$NUM], ...)
          - pattern: |
              $FUNC($BUFFER, argv[$NUM], ...);
              ...
              sprintf(..., $BUFFER, ...);
          - pattern: sprintf(...,argv[$NUM],...)
          - pattern: |
              $FUNC($BUFFER, argv[$NUM], ...);
              ...
              printf(..., $BUFFER, ...);
          - pattern: printf(...,argv[$NUM],...)
    message: |
      Avoid using user-controlled format strings passed into 'sprintf', 'printf' and 'vsprintf'.
      These functions put you at risk of buffer overflow vulnerabilities through the use of format string exploits.
      Instead, use 'snprintf' and 'vsnprintf'.
    metadata:
      references:
        - https://doc.castsoftware.com/display/SBX/Never+use+sprintf%28%29+or+vsprintf%28%29+functions
        - https://www.cvedetails.com/cwe-details/134/Uncontrolled-Format-String.html
    languages:
      - c
    severity: WARNING
  - id: c.lang.security.insecure-use-scanf-fn.insecure-use-scanf-fn
    pattern: scanf(...)
    message: |
      Avoid using 'scanf()'. This function, when used improperly, does not consider
      buffer boundaries and can lead to buffer overflows. Use 'fgets()' instead
      for reading input.
    metadata:
      references:
        - http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html
    languages:
      - c
    severity: ERROR
  - id: c.lang.security.insecure-use-strcat-fn.insecure-use-strcat-fn
    pattern-either:
      - pattern: strcat(...)
      - pattern: strncat(...)
    message: |
      Finding triggers whenever there is a strcat or strncat used.
      This is an issue because strcat or strncat can lead to buffer overflow vulns.
      Fix this by using strcat_s instead.
    metadata:
      references:
        - https://nvd.nist.gov/vuln/detail/CVE-2019-12553
        - https://techblog.mediaservice.net/2020/04/cve-2020-2851-stack-based-buffer-overflow-in-cde-libdtsvc/
    languages:
      - c
    severity: WARNING
  - id: c.lang.security.insecure-use-string-copy-fn.insecure-use-string-copy-fn
    pattern-either:
      - pattern: strcpy(...)
      - pattern: strncpy(...)
    message: |
      Finding triggers whenever there is a strcpy or strncpy used.
      This is an issue because strcpy or strncpy can lead to buffer overflow vulns.
      Fix this by using strcpy_s instead.
    metadata:
      references:
        - https://cwe.mitre.org/data/definitions/676
        - https://nvd.nist.gov/vuln/detail/CVE-2019-11365
    languages:
      - c
    severity: WARNING
  - id: c.lang.security.insecure-use-strtok-fn.insecure-use-strtok-fn
    pattern: strtok(...)
    message: |
      Avoid using 'strtok()'. This function directly modifies the first argument buffer, permanently erasing the
      delimiter character. Use 'strtok_r()' instead.
    metadata:
      references:
        - https://wiki.sei.cmu.edu/confluence/display/c/STR06-C.+Do+not+assume+that+strtok%28%29+leaves+the+parse+string+unchanged
        - https://man7.org/linux/man-pages/man3/strtok.3.html#BUGS
        - https://stackoverflow.com/a/40335556
    languages:
      - c
    severity: ERROR
  - id: c.lang.security.double-free.double-free
    patterns:
      - pattern: |
          free($VAR);
          ...
          free($VAR);
      - pattern-not: |
          free($VAR);
          ...
          $VAR = NULL;
          ...
          free($VAR);
      - pattern-not: |
          free($VAR);
          ...
          $VAR = malloc(...);
          ...
          free($VAR);
    message: |
      Variable '$VAR' was freed twice. This can lead to undefined behavior.
    metadata:
      references:
        - https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory
    languages:
      - c
    severity: ERROR
  - id: c.lang.security.use-after-free.use-after-free
    pattern-either:
      - patterns:
          - pattern: |
              free($VAR);
              ...
              $VAR->$FUNC(...);
          - pattern-not: |
              free($VAR);
              ...
              $VAR = NULL;
              ...
              $VAR->$FUNC(...);
      - patterns:
          - pattern: |
              free($VAR);
              ...
              $FUNC(..., $VAR->$MEMBER, ...);
          - pattern-not: |
              free($VAR);
              ...
              $VAR = NULL;
              ...
              $FUNC(..., $VAR->$MEMBER, ...);
    message: |
      Variable '$VAR' was used after being freed. This can lead to undefined behavior.
    metadata:
      references:
        - https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free/
    languages:
      - c
    severity: ERROR
  - id: c.lang.security.random-fd-exhaustion.random-fd-exhaustion
    pattern-either:
      - patterns:
          - pattern: |
              $FD = open("/dev/urandom", ...);
              ...
              read($FD, ...);
          - pattern-not: |
              $FD = open("/dev/urandom", ...);
              ...
              $BYTES_READ = read($FD, ...);
      - patterns:
          - pattern: |
              $FD = open("/dev/random", ...);
              ...
              read($FD, ...);
          - pattern-not: |
              $FD = open("/dev/random", ...);
              ...
              $BYTES_READ = read($FD, ...);
    message: |
      Call to 'read()' without error checking is susceptible to file descriptor
      exhaustion. Consider using the 'getrandom()' function.
    metadata:
      references:
        - https://lwn.net/Articles/606141/
    languages:
      - c
    severity: ERROR
  - id: go.grpc.security.grpc-client-insecure-connection.grpc-client-insecure-connection
    metadata:
      cwe: "CWE-300: Channel Accessible by Non-Endpoint"
      references:
        - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
    message:
      "Found an insecure gRPC connection using 'grpc.WithInsecure()'. This
      creates a connection without encryption to a gRPC server. A malicious attacker
      could tamper with the gRPC message, which could compromise the machine. Instead,
      establish a secure connection with an SSL certificate using the 'grpc.WithTransportCredentials()'
      function. You can create a create credentials using a 'tls.Config{}' struct
      with 'credentials.NewTLS()'. The final fix looks like this: 'grpc.WithTransportCredentials(credentials.NewTLS(<config>))'."
    languages:
      - go
    severity: ERROR
    pattern: $GRPC.Dial($ADDR, ..., $GRPC.WithInsecure(...), ...)
    fix-regex:
      regex: (.*)WithInsecure\(.*?\)
      replacement: \1WithTransportCredentials(credentials.NewTLS(<your_tls_config_here>))
  - id: go.grpc.security.grpc-server-insecure-connection.grpc-server-insecure-connection
    metadata:
      cwe: "CWE-300: Channel Accessible by Non-Endpoint"
      references:
        - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
    message:
      Found an insecure gRPC server without 'grpc.Creds()' or options with credentials.
      This allows for a connection without encryption to this server. A malicious attacker
      could tamper with the gRPC message, which could compromise the machine. Include
      credentials derived from an SSL certificate in order to create a secure gRPC connection.
      You can create credentials using 'credentials.NewServerTLSFromFile("cert.pem",
      "cert.key")'.
    languages:
      - go
    severity: ERROR
    patterns:
      - pattern-not: grpc.NewServer(..., grpc.Creds(...), ...)
      - pattern-not-inside: |
          $OPTS := []grpc.ServerOption{
            ...,
            grpc.Creds(credentials.NewClientTLSFromCert(...)),
            ...,
          }
          grpc.NewServer($OPTS...)
      - pattern-not-inside: |
          $CREDS := credentials.NewClientTLSFromCert(...)
          ...
          $OPTS := []grpc.ServerOption{
            ...,
            $CREDS,
            ...,
          }
          grpc.NewServer($OPTS...)
      - pattern: grpc.NewServer(...)
  - id: go.jwt-go.security.jwt.hardcoded-jwt-key
    metadata:
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A2: Broken Authentication"
    pattern-either:
      - pattern: |
          $X = []byte("...")
          ...
          $Y := $TOKEN.SignedString($X)
      - pattern: |
          $TOKEN.SignedString([]byte("..."))
    message: JWT token is hardcoded
    languages:
      - go
    severity: WARNING
  - id: go.lang.security.audit.crypto.bad_imports.insecure-module-used
    message:
      Detected use of an insecure cryptographic hashing method. This method is
      known to be broken and easily compromised. Use SHA256 or SHA3 instead.
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec
      references:
        - https://godoc.org/golang.org/x/crypto/sha3
    languages:
      - go
    severity: WARNING
    pattern-either:
      - patterns:
          - pattern-inside: |
              import "crypto/md5"
              ...
          - pattern: |
              md5.$FUNC(...)
      - patterns:
          - pattern-inside: |
              import "crypto/des"
              ...
          - pattern: |
              des.$FUNC(...)
      - patterns:
          - pattern-inside: |
              import "crypto/sha1"
              ...
          - pattern: |
              sha1.$FUNC(...)
      - patterns:
          - pattern-inside: |
              import "crypto/rc4"
              ...
          - pattern: |
              rc4.$FUNC(...)
      - patterns:
          - pattern-inside: |
              import "net/http/cgi"
              ...
          - pattern: |
              cgi.$FUNC(...)
  - id: go.lang.security.audit.crypto.insecure_ssh.avoid-ssh-insecure-ignore-host-key
    message: |
      Disabled host key verification detected. This allows man-in-the-middle
      attacks. Use the 'golang.org/x/crypto/ssh/knownhosts' package to do
      host key verification.
      See https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
      to learn more about the problem and how to fix it.
    metadata:
      cwe: "CWE-322: Key Exchange without Entity Authentication"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/securego/gosec
      references:
        - https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
        - https://gist.github.com/Skarlso/34321a230cf0245018288686c9e70b2d
    languages:
      - go
    severity: WARNING
    pattern: ssh.InsecureIgnoreHostKey()
  - id: go.lang.security.audit.crypto.math_random.math-random-used
    metadata:
      cwe: "CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation
    message: Do not use `math/rand`. Use `crypto/rand` instead.
    languages:
      - go
    severity: WARNING
    pattern-either:
      - patterns:
          - pattern-inside: |
              import mrand "math/rand"
              ...
          - pattern-either:
              - pattern: mrand.Int()
              - pattern: mrand.Read(...)
      - patterns:
          - pattern-inside: |
              import "math/rand"
              ...
          - pattern-not-inside: |
              import "crypto/rand"
              ...
          - pattern-either:
              - pattern: rand.Int()
              - pattern: rand.Read(...)
  - id: go.lang.security.audit.crypto.ssl.ssl-v3-is-insecure
    message: |
      SSLv3 is insecure because it has known vulnerabilities.
      Starting with go1.14, SSLv3 will be removed. Instead, use
      'tls.VersionTLS13'.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A9: Using Components with Known Vulnerabilities"
      source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls_config.go
      references:
        - https://golang.org/doc/go1.14#crypto/tls
        - https://www.us-cert.gov/ncas/alerts/TA14-290A
    languages:
      - go
    severity: ERROR
    patterns:
      - pattern: "tls.Config{..., MinVersion: $TLS.VersionSSL30, ...}"
    fix-regex:
      regex: VersionSSL30
      replacement: VersionTLS13
  - id: go.lang.security.audit.crypto.tls.tls-with-insecure-cipher
    message: |
      Detected an insecure CipherSuite via the 'tls' module. This suite is considered weak.
      Use the function 'tls.CipherSuites()' to get a list of good cipher suites.
      See https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
      for why and what other cipher suites to use.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A9: Using Components with Known Vulnerabilities"
      source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls.go
      references:
        - https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
    languages:
      - go
    severity: WARNING
    pattern-either:
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_RC4_128_SHA,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_AES_128_CBC_SHA256,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,...}}
      - pattern: |
          tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,...}}
      - pattern: |
          tls.CipherSuite{..., TLS_RSA_WITH_RC4_128_SHA ,...}
      - pattern: |
          tls.CipherSuite{..., TLS_RSA_WITH_AES_128_CBC_SHA256 ,...}
      - pattern: |
          tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_RC4_128_SHA ,...}
      - pattern: |
          tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_RC4_128_SHA ,...}
      - pattern: |
          tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 ,...}
      - pattern: tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 ,...}
  - id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-DES
    message: |
      Detected DES cipher algorithm which is insecure. The algorithm is
      considered weak and has been deprecated. Use AES instead.
    languages:
      - go
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec#available-rules
    pattern-either:
      - pattern: |
          des.NewTripleDESCipher(...)
      - pattern: |
          des.NewCipher(...)
  - id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-md5
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    languages:
      - go
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec#available-rules
    pattern-either:
      - pattern: |
          md5.New()
      - pattern: |
          md5.Sum(...)
  - id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-rc4
    message: |
      Detected RC4 cipher algorithm which is insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    languages:
      - go
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec#available-rules
    pattern: rc4.NewCipher(...)
  - id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-sha1
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    languages:
      - go
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://github.com/securego/gosec#available-rules
    pattern-either:
      - pattern: |
          sha1.New()
      - pattern: |
          sha1.Sum(...)
  - id: go.lang.security.audit.database.string-formatted-query.string-formatted-query
    languages:
      - go
    message: |
      String-formatted SQL query detected. This could lead to SQL injection if
      the string is not sanitized properly. Audit this call to ensure the
      SQL is not manipulatable by external data.
    severity: WARNING
    metadata:
      owasp: "A1: Injection"
      cwe:
        "CWE-89: Improper Neutralization of Special Elements used in an SQL Command
        ('SQL Injection')"
      source-rule-url: https://github.com/securego/gosec
    patterns:
      - pattern-either:
          - pattern: $OBJ.Exec("..." + $X)
          - pattern: $OBJ.ExecContext($CTX, "..." + $X)
          - pattern: $OBJ.Query("..." + $X)
          - pattern: $OBJ.QueryContext($CTX, "..." + $X)
          - pattern: $OBJ.QueryRow("..." + $X)
          - pattern: $OBJ.QueryRow($CTX, "..." + $X)
          - pattern: $OBJ.QueryRowContext($CTX, "..." + $X)
          - pattern: $OBJ.Exec(fmt.$P("...", ...))
          - pattern: $OBJ.ExecContext($CTX, fmt.$P("...", ...))
          - pattern: $OBJ.Query(fmt.$P("...", ...))
          - pattern: $OBJ.QueryContext($CTX, fmt.$P("...", ...))
          - pattern: $OBJ.QueryRow(fmt.$P("...", ...))
          - pattern: $OBJ.QueryRow($CTX, fmt.$P("...", ...))
          - pattern: $OBJ.QueryRowContext($CTX, fmt.$P("...", ...))
          - pattern: |
              $QUERY = "..."
              ...
              $QUERY = $FXN(..., $QUERY, ...)
              ...
              $OBJ.Exec($QUERY, ...)
          - pattern: |
              $QUERY = "..."
              ...
              $QUERY = $FXN(..., $QUERY, ...)
              ...
              $OBJ.Query($QUERY, ...)
          - pattern: |
              $QUERY = "..."
              ...
              $QUERY = $FXN(..., $QUERY, ...)
              ...
              $OBJ.ExecContext($CTX, $QUERY, ...)
          - pattern: |
              $QUERY = "..."
              ...
              $QUERY = $FXN(..., $QUERY, ...)
              ...
              $OBJ.QueryContext($CTX, $QUERY, ...)
          - pattern: |
              $QUERY = "..."
              ...
              $QUERY = $FXN(..., $QUERY, ...)
              ...
              $OBJ.QueryRow($QUERY)
          - pattern: |
              $QUERY = "..."
              ...
              $QUERY = $FXN(..., $QUERY, ...)
              ...
              $OBJ.QueryRow($CTX, $QUERY)
          - pattern: |
              $QUERY = "..."
              ...
              $QUERY = $FXN(..., $QUERY, ...)
              ...
              $OBJ.QueryRowContext($CTX, $QUERY, ...)
          - pattern: |
              $QUERY = "..."
              ...
              $OTHER = $FXN(..., $QUERY, ...)
              ...
              $OBJ.Exec($OTHER, ...)
          - pattern: |
              $QUERY = "..."
              ...
              $OTHER = $FXN(..., $QUERY, ...)
              ...
              $OBJ.Query($OTHER, ...)
          - pattern: |
              $QUERY = "..."
              ...
              $OTHER = $FXN(..., $QUERY, ...)
              ...
              $OBJ.ExecContext($CTX, $OTHER, ...)
          - pattern: |
              $QUERY = "..."
              ...
              $OTHER = $FXN(..., $QUERY, ...)
              ...
              $OBJ.QueryContext($CTX, $OTHER, ...)
          - pattern: |
              $QUERY = "..."
              ...
              $OTHER = $FXN(..., $QUERY, ...)
              ...
              $OBJ.QueryRow($OTHER)
          - pattern: |
              $QUERY = "..."
              ...
              $OTHER = $FXN(..., $QUERY, ...)
              ...
              $OBJ.QueryRow($CTX, $OTHER)
          - pattern: |
              $QUERY = "..."
              ...
              $OTHER = $FXN(..., $QUERY, ...)
              ...
              $OBJ.QueryRowContext($CTX, $OTHER, ...)
          - pattern: |
              $QUERY = "..." + $X
              ...
              $OBJ.Exec($QUERY, ...)
          - pattern: |
              $QUERY = "..." + $X
              ...
              $OBJ.Query($QUERY, ...)
          - pattern: |
              $QUERY = "..." + $X
              ...
              $OBJ.ExecContext($CTX, $QUERY, ...)
          - pattern: |
              $QUERY = "..." + $X
              ...
              $OBJ.QueryContext($CTX, $QUERY, ...)
          - pattern: |
              $QUERY = "..." + $X
              ...
              $OBJ.QueryRow($QUERY)
          - pattern: |
              $QUERY = "..." + $X
              ...
              $OBJ.QueryRow($CTX, $QUERY)
          - pattern: |
              $QUERY = "..." + $X
              ...
              $OBJ.QueryRowContext($CTX, $QUERY, ...)
  - id: go.lang.security.audit.net.bind_all.avoid-bind-to-all-interfaces
    message:
      Listening on 0.0.0.0 or empty string could unexpectedly expose the server
      publicly as it binds to all available interfaces
    languages:
      - go
    severity: WARNING
    metadata:
      cwe: "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://github.com/securego/gosec
    pattern-either:
      - pattern: tls.Listen($NETWORK, "=~/^0.0.0.0:.*$/", ...)
      - pattern: net.Listen($NETWORK, "=~/^0.0.0.0:.*$/", ...)
      - pattern: tls.Listen($NETWORK, "=~/^:.*$/", ...)
      - pattern: net.Listen($NETWORK, "=~/^:.*$/", ...)
  - id: go.lang.security.audit.net.dynamic-httptrace-clienttrace.dynamic-httptrace-clienttrace
    message: |
      Detected a potentially dynamic ClientTrace. This occurred because semgrep could not
      find a static definition for '$TRACE'. Dynamic ClientTraces are dangerous because
      they deserialize function code to run when certain Request events occur, which could lead
      to code being run without your knowledge. Ensure that your ClientTrace is statically defined.
    metadata:
      cwe: "CWE-913: Improper Control of Dynamically-Managed Code Resources"
      owasp: "A8: Insecure Deserialization"
      references:
        - https://github.com/returntocorp/semgrep-rules/issues/518
    patterns:
      - pattern-not-inside: |
          ...
          &httptrace.ClientTrace { ... }
          ...
      - pattern: httptrace.WithClientTrace($ANY, $TRACE)
    severity: WARNING
    languages:
      - go
  - id: go.lang.security.audit.net.formatted-template-string.formatted-template-string
    message: |
      Found a formatted template string passed to 'template.HTML()'.
      'template.HTML()' does not escape contents. Be absolutely sure
      there is no user-controlled data in this template. If user data
      can reach this template, you may have a XSS vulnerability.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A1: Injection"
      references:
        - https://golang.org/pkg/html/template/#HTML
    languages:
      - go
    severity: WARNING
    patterns:
      - pattern-not: template.HTML("..." + "...")
      - pattern-either:
          - pattern: template.HTML($T + $X, ...)
          - pattern: template.HTML(fmt.$P("...", ...), ...)
          - pattern: |
              $T = "..."
              ...
              $T = $FXN(..., $T, ...)
              ...
              template.HTML($T, ...)
          - pattern: |
              $T = fmt.$P("...", ...)
              ...
              template.HTML($T, ...)
          - pattern: |
              $T, $ERR = fmt.$P("...", ...)
              ...
              template.HTML($T, ...)
          - pattern: |
              $T = $X + $Y
              ...
              template.HTML($T, ...)
          - pattern: |
              $T = "..."
              ...
              $OTHER, $ERR = fmt.$P(..., $T, ...)
              ...
              template.HTML($OTHER, ...)
  - id: go.lang.security.audit.net.pprof.pprof-debug-exposure
    metadata:
      cwe: "CWE-489: Active Debug Code"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://github.com/securego/gosec#available-rules
      references:
        - https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
    message: |
      The profiling 'pprof' endpoint is automatically exposed on /debug/pprof.
      This could leak information about the server.
      Instead, use `import "net/http/pprof"`. See
      https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
      for more information and mitigation.
    languages:
      - go
    severity: WARNING
    patterns:
      - pattern-inside: |
          import _ "net/http/pprof"
          ...
      - pattern-inside: |
          func $ANY(...) {
            ...
          }
      - pattern-not: http.ListenAndServe("=~/^localhost.*/", ...)
      - pattern-not: http.ListenAndServe("=~/^127[.]0[.]0[.]1.*/", ...)
      - pattern: http.ListenAndServe(...)
  - id: go.lang.security.audit.net.unescaped-data-in-htmlattr.unescaped-data-in-htmlattr
    message: |
      Found a formatted template string passed to 'template.HTMLAttr()'.
      'template.HTMLAttr()' does not escape contents. Be absolutely sure
      there is no user-controlled data in this template.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A1: Injection"
      references:
        - https://golang.org/pkg/html/template/#HTMLAttr
    languages:
      - go
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: template.HTMLAttr($T + $X, ...)
          - pattern: template.HTMLAttr(fmt.$P("...", ...), ...)
          - pattern: |
              $T = "..."
              ...
              $T = $FXN(..., $T, ...)
              ...
              template.HTMLAttr($T, ...)
          - pattern: |
              $T = fmt.$P("...", ...)
              ...
              template.HTMLAttr($T, ...)
          - pattern: |
              $T, $ERR = fmt.$P("...", ...)
              ...
              template.HTMLAttr($T, ...)
          - pattern: |
              $T = $X + $Y
              ...
              template.HTMLAttr($T, ...)
          - pattern: |
              $T = "..."
              ...
              $OTHER, $ERR = fmt.$P(..., $T, ...)
              ...
              template.HTMLAttr($OTHER, ...)
  - id: go.lang.security.audit.net.unescaped-data-in-js.unescaped-data-in-js
    message: |
      Found a formatted template string passed to 'template.JS()'.
      'template.JS()' does not escape contents. Be absolutely sure
      there is no user-controlled data in this template.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A1: Injection"
      references:
        - https://golang.org/pkg/html/template/#JS
    languages:
      - go
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: template.JS($T + $X, ...)
          - pattern: template.JS(fmt.$P("...", ...), ...)
          - pattern: |
              $T = "..."
              ...
              $T = $FXN(..., $T, ...)
              ...
              template.JS($T, ...)
          - pattern: |
              $T = fmt.$P("...", ...)
              ...
              template.JS($T, ...)
          - pattern: |
              $T, $ERR = fmt.$P("...", ...)
              ...
              template.JS($T, ...)
          - pattern: |
              $T = $X + $Y
              ...
              template.JS($T, ...)
          - pattern: |
              $T = "..."
              ...
              $OTHER, $ERR = fmt.$P(..., $T, ...)
              ...
              template.JS($OTHER, ...)
  - id: go.lang.security.audit.net.unescaped-data-in-url.unescaped-data-in-url
    message: |
      Found a formatted template string passed to 'template.URL()'.
      'template.URL()' does not escape contents. Be absolutely sure
      there is no user-controlled data in this template.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A1: Injection"
      references:
        - https://golang.org/pkg/html/template/#URL
    languages:
      - go
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: template.URL($T + $X, ...)
          - pattern: template.URL(fmt.$P("...", ...), ...)
          - pattern: |
              $T = "..."
              ...
              $T = $FXN(..., $T, ...)
              ...
              template.URL($T, ...)
          - pattern: |
              $T = fmt.$P("...", ...)
              ...
              template.URL($T, ...)
          - pattern: |
              $T, $ERR = fmt.$P("...", ...)
              ...
              template.URL($T, ...)
          - pattern: |
              $T = $X + $Y
              ...
              template.URL($T, ...)
          - pattern: |
              $T = "..."
              ...
              $OTHER, $ERR = fmt.$P(..., $T, ...)
              ...
              template.URL($OTHER, ...)
  - id: go.lang.security.audit.net.use-tls.use-tls
    pattern: http.ListenAndServe($ADDR, $HANDLER)
    fix: http.ListenAndServeTLS($ADDR, certFile, keyFile, $HANDLER)
    metadata:
      cwe: "CWE-319: Cleartext Transmission of Sensitive Information"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://golang.org/pkg/net/http/#ListenAndServeTLS
    message:
      Found an HTTP server without TLS. Use 'http.ListenAndServeTLS' instead.
      See https://golang.org/pkg/net/http/#ListenAndServeTLS for more information.
    languages:
      - go
    severity: WARNING
  - id: go.lang.security.audit.net.wip-xss-using-responsewriter-and-printf.wip-xss-using-responsewriter-and-printf
    patterns:
      - pattern-inside: |
          func $FUNC(..., $W http.ResponseWriter, ...) {
              ...
          }
      - pattern-inside: |
          ...
          var $T = "..."
          ...
          $W.Write([]byte(fmt.$PRINTF($T, ...)), ...)
      - pattern-either:
          - pattern: |
              $PARAMS = r.URL.Query()
              ...
              $DATA, $ERR := $PARAMS[...]
              ...
              $INTERM = $ANYTHING(..., $DATA, ...)
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
          - pattern: |
              $PARAMS = r.URL.Query()
              ...
              $DATA, $ERR := $PARAMS[...]
              ...
              $INTERM = $DATA[...]
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
          - pattern: |
              $DATA, $ERR := r.URL.Query()[...]
              ...
              $INTERM = $DATA[...]
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
          - pattern: |
              $DATA, $ERR := r.URL.Query()[...]
              ...
              $INTERM = $ANYTHING(..., $DATA, ...)
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
          - pattern: |
              $PARAMS = r.URL.Query()
              ...
              $DATA, $ERR := $PARAMS[...]
              ...
              $W.Write([]byte(fmt.$PRINTF(..., $DATA, ...)))
    message: |
      Found data going from url query parameters into formatted data written to ResponseWriter.
      This could be XSS and should not be done. If you must do this, ensure your data is
      sanitized or escaped.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-Site Scripting ('XSS')"
    severity: WARNING
    languages:
      - go
  - id: go.lang.security.audit.reflect-makefunc.reflect-makefunc
    message: |
      'reflect.MakeFunc' detected. This will sidestep protections that are
      normally afforded by Go's type system. Audit this call and be sure that
      user input cannot be used to affect the code generated by MakeFunc;
      otherwise, you will have a serious security vulnerability.
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-913: Improper Control of Dynamically-Managed Code Resources"
    severity: WARNING
    pattern: reflect.MakeFunc(...)
    languages:
      - go
  - id: go.lang.security.audit.unsafe.use-of-unsafe-block
    message:
      Using the unsafe package in Go gives you low-level memory management and
      many of the strengths of the C language but also gives flexibility to the attacker
      of your application.
    languages:
      - go
    severity: WARNING
    metadata:
      cwe: "CWE-242: Use of Inherently Dangerous Function"
      source_rule_url: https://github.com/securego/gosec/blob/master/rules/unsafe.go
    patterns:
      - pattern: unsafe.$FUNC(...)
  - id: go.lang.security.bad_tmp.bad-tmp-file-creation
    message: File creation in shared tmp directory without using ioutil.Tempfile
    languages:
      - go
    severity: WARNING
    metadata:
      cwe: "CWE-377: Insecure Temporary File"
      source_rule_url: https://github.com/securego/gosec
    pattern-either:
      - pattern: ioutil.WriteFile("=~//tmp/.*$/", ...)
      - pattern: os.Create("=~//tmp/.*$/", ...)
  - id: go.lang.security.decompression_bomb.potential-dos-via-decompression-bomb
    message:
      Detected a possible denial-of-service via a zip bomb attack. By limiting
      the max bytes read, you can mitigate this attack. `io.CopyN()` can specify a size.
      Refer to https://bomb.codes/ to learn more about this attack and other ways to
      mitigate it.
    severity: WARNING
    languages:
      - go
    patterns:
      - pattern-either:
          - pattern: io.Copy(...)
          - pattern: io.CopyBuffer(...)
      - pattern-either:
          - pattern-inside: |
              gzip.NewReader(...)
              ...
          - pattern-inside: |
              zlib.NewReader(...)
              ...
          - pattern-inside: |
              zlib.NewReaderDict(...)
              ...
          - pattern-inside: |
              bzip2.NewReader(...)
              ...
          - pattern-inside: |
              flate.NewReader(...)
              ...
          - pattern-inside: |
              flate.NewReaderDict(...)
              ...
          - pattern-inside: |
              lzw.NewReader(...)
              ...
          - pattern-inside: |
              tar.NewReader(...)
              ...
          - pattern-inside: |
              zip.NewReader(...)
              ...
          - pattern-inside: |
              zip.OpenReader(...)
              ...
    fix-regex:
      regex: (.*)(Copy|CopyBuffer)\((.*?),(.*?)(\)|,.*\))
      replacement: \1CopyN(\3, \4, 1024*1024*256)
    metadata:
      cwe: "CWE-400: Uncontrolled Resource Consumption"
      source-rule-url: https://github.com/securego/gosec
      references:
        - https://bomb.codes/
        - https://golang.org/pkg/io/#CopyN
        - https://github.com/securego/gosec/blob/master/rules/decompression-bomb.go
  - id: go.lang.security.zip.path-traversal-inside-zip-extraction
    message: File traversal when extracting zip archive
    metadata:
      cwe: |
        CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
      source_rule_url: https://github.com/securego/gosec/issues/205
    languages:
      - go
    severity: WARNING
    patterns:
      - pattern: |-
          reader, $ERR := zip.OpenReader($ARCHIVE)
          ...
          for _, $FILE := range reader.File {
            ...
            path := filepath.Join($TARGET, $FILE.Name)
            ...
          }
  - id: go.otto.security.audit.dangerous-execution.dangerous-execution
    message: |
      Detected non-static script inside otto VM. Audit the input to 'VM.Run'.
      If unverified user data can reach this call site, this is a code injection
      vulnerability. A malicious actor can inject a malicious script to execute
      arbitrary code.
    metadata:
      cwe: "CWE-94: Improper Control of Generation of Code ('Code Injection')"
      owasp: "A1: Injection"
    severity: WARNING
    patterns:
      - pattern-inside: |
          $VM = otto.New(...)
          ...
      - pattern-not: $VM.Run("...", ...)
      - pattern: $VM.Run(...)
    languages:
      - go
  - id: java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal
    metadata:
      owasp: "A1: Injection"
      cwe:
        "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path
        Traversal')"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
      references:
        - https://www.owasp.org/index.php/Path_Traversal
    message: |
      Detected a potential path traversal. A malicious actor
      could control the location of this file, to include going backwards
      in the directory with '../'. To address this, ensure that user-controlled
      variables in file paths are sanitized. You may aslso consider using a utility
      method such as org.apache.commons.io.FilenameUtils.getName(...) to only
      retrieve the file name from the path.
    patterns:
      - pattern-either:
          - pattern: |
              $RETURNTYPE $FUNC (..., @PathParam(...) $TYPE $VAR, ...) {
                ...
                new File(..., $VAR, ...);
                ...
              }
          - pattern: |-
              $RETURNTYPE $FUNC (..., @javax.ws.rs.PathParam(...) $TYPE $VAR, ...) {
                ...
                new File(..., $VAR, ...);
                ...
              }
    severity: WARNING
    languages:
      - java
  - id: java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind
    metadata:
      cwe: "CWE-287: Improper Authentication"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#LDAP_ANONYMOUS
    message: |
      Detected anonymous LDAP bind.
      This permits anonymous users to execute LDAP statements. Consider enforcing
      authentication for LDAP. See https://docs.oracle.com/javase/tutorial/jndi/ldap/auth_mechs.html
      for more information.
    severity: WARNING
    pattern: |
      $ENV.put($CTX.SECURITY_AUTHENTICATION, "none");
      ...
      $DCTX = new InitialDirContext($ENV, ...);
    languages:
      - java
  - id: java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion
    metadata:
      cwe: "CWE-704: Incorrect Type Conversion or Cast"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#BAD_HEXA_CONVERSION
    message: |
      'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte.
      This mistake weakens the hash value computed since it introduces more collisions.
      Use 'String.format("%02X", ...)' instead.
    severity: WARNING
    languages:
      - java
    pattern: |-
      $X $METHOD(...) {
        ...
        MessageDigest $MD = ...;
        ...
        $MD.digest(...);
        ...
        Integer.toHexString(...);
      }
  - id: java.lang.security.audit.cbc-padding-oracle.cbc-padding-oracle
    message: |
      Using CBC with PKCS5Padding is susceptible to padding orcale attacks. A malicious actor
      could discern the difference between plaintext with valid or invalid padding. Further,
      CBC mode does not include any integrity checks. See https://find-sec-bugs.github.io/bugs.htm#CIPHER_INTEGRITY.
      Use 'AES/GCM/NoPadding' instead.
    metadata:
      cwe: "CWE-696: Incorrect Behavior Order"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PADDING_ORACLE
      references:
        - https://capec.mitre.org/data/definitions/463.html
    severity: WARNING
    patterns:
      - pattern: $CIPHER.getInstance("=~/.*\/CBC\/PKCS5Padding/");
    fix: $CIPHER.getInstance("AES/GCM/NoPadding");
    languages:
      - java
  - id: java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call
    patterns:
      - pattern-either:
          - pattern: $RUNTIME.exec($X + $Y);
          - pattern: $RUNTIME.exec(String.format(...));
          - pattern: $RUNTIME.loadLibrary($X + $Y);
          - pattern: $RUNTIME.loadLibrary(String.format(...));
    message: |
      A formatted or concatenated string was detected as input to a java.lang.Runtime call.
      This is dangerous if a variable is controlled by user input and could result in a
      command injection. Ensure your variables are not controlled by users or sufficiently sanitized.
    metadata:
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.
    severity: WARNING
    languages:
      - java
  - id: java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly
    metadata:
      cwe: "CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#HTTPONLY_COOKIE
    message: |
      A cookie was detected without setting the 'HttpOnly' flag. The 'HttpOnly' flag
      for cookies instructs the browser to forbid client-side scripts from reading the
      cookie. Set the 'HttpOnly' flag by calling 'cookie.setHttpOnly(true);'
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-not-inside: $COOKIE.setValue(""); ...
      - pattern-either:
          - pattern: $COOKIE.setHttpOnly(false);
          - patterns:
              - pattern-not-inside: $COOKIE.setHttpOnly(...); ...
              - pattern: $RESPONSE.addCookie($COOKIE);
  - id: java.lang.security.audit.cookie-missing-samesite.cookie-missing-samesite
    metadata:
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://stackoverflow.com/questions/42717210/samesite-cookie-in-java-application
    message: |
      Detected cookie without the SameSite attribute.
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-not-inside: |
          $RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...) {
            ...
            $RESP.setHeader("Set-Cookie", "=~/.*SameSite=.*/");
            ...
          }
      - pattern-either:
          - pattern: $RESP.addCookie(...);
          - pattern: $RESP.setHeader("Set-Cookie", ...);
  - id: java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag
    metadata:
      cwe: "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_COOKIE
    message: |
      A cookie was detected without setting the 'secure' flag. The 'secure' flag
      for cookies prevents the client from transmitting the cookie over insecure
      channels such as HTTP. Set the 'secure' flag by calling '$COOKIE.setSecure(true);'
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-not-inside: $COOKIE.setValue(""); ...
      - pattern-either:
          - pattern: $COOKIE.setSecure(false);
          - patterns:
              - pattern-not-inside: $COOKIE.setSecure(...); ...
              - pattern: $RESPONSE.addCookie($COOKIE);
  - id: java.lang.security.audit.crlf-injection-logs.crlf-injection-logs
    message: |
      When data from an untrusted source is put into a logger and not neutralized correctly,
      an attacker could forge log entries or include malicious content.
    metadata:
      cwe: "CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#CRLF_INJECTION_LOGS
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  class $CLASS {
                    ...
                    Logger $LOG = ...;
                    ...
                  }
              - pattern-either:
                  - pattern-inside: |
                      $X $METHOD(...,HttpServletRequest $REQ,...) {
                        ...
                      }
                  - pattern-inside: |
                      $X $METHOD(...,ServletRequest $REQ,...) {
                        ...
                      }
                  - pattern-inside: |
                      $X $METHOD(...) {
                        ...
                        HttpServletRequest $REQ = ...;
                        ...
                      }
                  - pattern-inside: |
                      $X $METHOD(...) {
                        ...
                        ServletRequest $REQ = ...;
                        ...
                      }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                Logger $LOG = ...;
                ...
                HttpServletRequest $REQ = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                Logger $LOG = ...;
                ...
                ServletRequest $REQ = ...;
                ...
              }
      - pattern-either:
          - pattern: |
              String $VAL = $REQ.getParameter(...);
              ...
              $LOG.$LEVEL(<... $VAL ...>);
          - pattern: |
              String $VAL = $REQ.getParameter(...);
              ...
              $LOG.log($LEVEL,<... $VAL ...>);
          - pattern: |
              $LOG.$LEVEL(<... $REQ.getParameter(...) ...>);
          - pattern: |
              $LOG.log($LEVEL,<... $REQ.getParameter(...) ...>);
  - id: java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated
    message: |
      DES is considered deprecated. AES is the recommended cipher.
      Upgrade to use AES.
      See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information.
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DES_USAGE
      references:
        - https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard
    severity: WARNING
    pattern: $CIPHER.getInstance("=~/DES/.*/");
    fix: $CIPHER.getInstance("AES/GCM/NoPadding");
    languages:
      - java
  - id: java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated
    message: |
      Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher.
      Upgrade to use AES.
      See https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA for more information.
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE
      references:
        - https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA
    severity: WARNING
    pattern: $CIPHER.getInstance("=~/DESede.*/");
    fix: Cipher.getInstance("AES/GCM/NoPadding");
    languages:
      - java
  - id: java.lang.security.audit.crypto.no-null-cipher.no-null-cipher
    pattern: new NullCipher(...);
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#NULL_CIPHER
    message: |
      NullCipher was detected. This will not encrypt anything;
      the cipher text will be the same as the plain text. Use
      a valid, secure cipher: Cipher.getInstance("AES/CBC/PKCS7PADDING").
      See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions
      for more information.
    severity: WARNING
    languages:
      - java
  - id: java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector
    message: |
      Initialization Vectors (IVs) for block ciphers should be randomly generated
      each time they are used. Using a static IV means the same plaintext
      encrypts to the same ciphertext every time, weakening the strength
      of the encryption.
    metadata:
      cwe: "CWE-329: Not Using a Random IV with CBC Mode"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#STATIC_IV
      references:
        - https://cwe.mitre.org/data/definitions/329.html
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: |
              byte[] $IV = {
                  ...
              };
              ...
              new IvParameterSpec($IV, ...);
          - pattern: |
              class $CLASS {
                  byte[] $IV = {
                      ...
                  };
                  ...
                  $METHOD(...) {
                      ...
                      new IvParameterSpec($IV, ...);
                      ...
                  }
              }
  - id: java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitve Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#RSA_NO_PADDING
      references: https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/
    message: |
      Using RSA without OAEP mode weakens the encryption.
    severity: WARNING
    languages:
      - java
    pattern: $CIPHER.getInstance("RSA/NONE/NoPadding")
  - id: java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#CUSTOM_MESSAGE_DIGEST
      references:
        - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#custom-algorithms
    message: |
      Cryptographic algorithms are notoriously difficult to get right. By implementing
      a custom message digest, you risk introducing security issues into your program.
      Use one of the many sound message digests already available to you:
      MessageDigest sha256Digest = MessageDigest.getInstance("SHA256");
    severity: WARNING
    languages:
      - java
    pattern: |-
      class $CLASS extends MessageDigest {
        ...
      }
  - id: java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DEFAULT_HTTP_CLIENT
    message: |
      DefaultHttpClient is deprecated. Further, it does not support connections
      using TLS1.2, which makes using DefaultHttpClient a security hazard.
      Use SystemDefaultHttpClient instead, which supports TLS1.2.
    severity: WARNING
    languages:
      - java
    pattern: new DefaultHttpClient(...);
    fix-regex:
      regex: DefaultHttpClient
      replacement: SystemDefaultHttpClient
  - id: java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier
    message: |
      Insecure HostnameVerifier implementation detected. This will accept
      any SSL certificate with any hostname, which creates the possibility
      for man-in-the-middle attacks.
    metadata:
      cwe: "CWE-295: Improper Certificate Validation"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: |
              class $CLASS implements HostnameVerifier {
                ...
                public boolean verify(...) { return true; }
              }
          - pattern: |-
              new HostnameVerifier(...){
                public boolean verify(...) {
                  return true;
                }
              }
  - id: java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager
    metadata:
      cwe: "CWE-295: Improper Certificate Validation"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER
      references:
        - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
    message: |
      Detected empty trust manager implementations. This is dangerous because it accepts any
      certificate, enabling man-in-the-middle attacks. Consider using a KeyStore
      and TrustManagerFactory isntead.
      See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
      for more information.
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern-inside: |
              class $CLASS implements X509TrustManager {
                ...
              }
          - pattern-inside: |
              new X509TrustManager() {
                ...
              }
          - pattern-inside: |
              class $CLASS implements X509ExtendedTrustManager {
                ...
              }
          - pattern-inside: |
              new X509ExtendedTrustManager() {
                ...
              }
      - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }
      - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }
      - pattern-either:
          - pattern: public void checkClientTrusted(...) {}
          - pattern: public void checkServerTrusted(...) {}
          - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }
  - id: java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket
    metadata:
      cwe: "CWE-319: Cleartext Transmission of Sensitive Information"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNENCRYPTED_SOCKET
    message: |
      This socket is not encrypted.
      The traffic could be read by an attacker intercepting the network traffic.
      Use an SSLSocket created by 'SSLSocketFactory' or 'SSLServerSocketFactory'
      instead
    severity: WARNING
    languages:
      - java
    pattern-either:
      - pattern: new ServerSocket(...)
      - pattern: new Socket(...)
  - id: java.lang.security.audit.crypto.weak-hash.use-of-md5
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    languages:
      - java
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5
    pattern-either:
      - pattern: |
          MessageDigest $VAR = $MD.getInstance("MD5");
      - pattern: |
          $DU.getMd5Digest().digest(...)
  - id: java.lang.security.audit.crypto.weak-hash.use-of-sha1
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    languages:
      - java
    severity: WARNING
    metadata:
      owasp: "A9: Using Components with Known Vulnerabilities"
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_SHA1
    pattern-either:
      - pattern: |
          MessageDigest $VAR = $MD.getInstance("SHA1");
      - pattern: |
          $DU.getSha1Digest().digest(...)
  - id: java.lang.security.audit.el-injection.el-injection
    metadata:
      cwe: "CWE-94: Improper Control of Generation of Code ('Code Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION
    message: |
      An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createValueExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF = ...;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createValueExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              $X $METHOD(...) {
                ...
                ExpressionFactory $EF = ...;
                ...
                $EF.createValueExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              $X $METHOD(...,ExpressionFactory $EF,...) {
                ...
                $EF.createValueExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createMethodExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF = ...;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createMethodExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              $X $METHOD(...) {
                ...
                ExpressionFactory $EF = ...;
                ...
                $EF.createMethodExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              $X $METHOD(...,ExpressionFactory $EF,...) {
                ...
                $EF.createMethodExpression($CTX,$INPUT,...);
                ...
              }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            $EF.createValueExpression($CTX,"...",...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            String $S = "...";
            ...
            $EF.createValueExpression($CTX,$S,...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            $EF.createMethodExpression($CTX,"...",...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            String $S = "...";
            ...
            $EF.createMethodExpression($CTX,$S,...);
            ...
          }
  - id: java.lang.security.audit.formatted-sql-string.formatted-sql-string
    metadata:
      cwe:
        "CWE-89: Improper Neutralization of Special Elements used in an SQL Command
        ('SQL Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION
      references:
        - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
        - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps
        - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement
    message: |
      Detected a formatted string in a SQL statement. This could lead to SQL
      injection if variables in the SQL statement are not properly sanitized.
      Use a prepared statements (java.sql.PreparedStatement) instead. You
      can obtain a PreparedStatement using 'connection.prepareStatement'.
    patterns:
      - pattern-not: $W.execute(<... "=~/.*TABLE *$/" ...>);
      - pattern-not: $W.execute(<... "=~/.*TABLE %s$/" ...>);
      - pattern-either:
          - pattern: $W.execute($X + $Y, ...);
          - pattern: |
              String $SQL = $X + $Y;
              ...
              $W.execute($SQL, ...);
          - pattern: |
              String $SQL = $X;
              ...
              $SQL += $Y;
              ...
              $W.execute($SQL, ...);
          - pattern: $W.execute(String.format($X, ...), ...);
          - pattern: |
              String $SQL = String.format($X, ...);
              ...
              $W.execute($SQL, ...);
          - pattern: |
              String $SQL = $X;
              ...
              $SQL += String.format(...);
              ...
              $W.execute($SQL, ...);
          - pattern: $W.executeQuery($X + $Y, ...);
          - pattern: |
              String $SQL = $X + $Y;
              ...
              $W.executeQuery($SQL, ...);
          - pattern: |
              String $SQL = $X;
              ...
              $SQL += $Y;
              ...
              $W.executeQuery($SQL, ...);
          - pattern: $W.executeQuery(String.format($X, ...), ...);
          - pattern: |
              String $SQL = String.format($X, ...);
              ...
              $W.executeQuery($SQL, ...);
          - pattern: |
              String $SQL = $X;
              ...
              $SQL += String.format(...);
              ...
              $W.executeQuery($SQL, ...);
          - pattern: $W.createQuery($X + $Y, ...);
          - pattern: |
              String $SQL = $X + $Y;
              ...
              $W.createQuery($SQL, ...);
          - pattern: |
              String $SQL = $X;
              ...
              $SQL += $Y;
              ...
              $W.createQuery($SQL, ...);
          - pattern: $W.createQuery(String.format($X, ...), ...);
          - pattern: |
              String $SQL = String.format($X, ...);
              ...
              $W.createQuery($SQL, ...);
          - pattern: |
              String $SQL = $X;
              ...
              $SQL += String.format(...);
              ...
              $W.createQuery($SQL, ...);
          - pattern: $W.query($X + $Y, ...);
          - pattern: |
              String $SQL = $X + $Y;
              ...
              $W.query($SQL, ...);
          - pattern: |
              String $SQL = $X;
              ...
              $SQL += $Y;
              ...
              $W.query($SQL, ...);
          - pattern: $W.query(String.format($X, ...), ...);
          - pattern: |
              String $SQL = String.format($X, ...);
              ...
              $W.query($SQL, ...);
          - pattern: |
              String $SQL = $X;
              ...
              $SQL += String.format(...);
              ...
              $W.query($SQL, ...);
    severity: WARNING
    languages:
      - java
  - id: java.lang.security.audit.http-response-splitting.http-response-splitting
    metadata:
      cwe:
        "CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP
        Response Splitting')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#HTTP_RESPONSE_SPLITTING
      references:
        - https://www.owasp.org/index.php/HTTP_Response_Splitting
    message: |
      Older Java application servers are vulnreable to HTTP response splitting, which may occur if an HTTP
      request can be injected with CRLF characters. This finding is reported for completeness; it is recommended
      to ensure your environment is not affected by testing this yourself.
    severity: INFO
    patterns:
      - pattern-either:
          - pattern: |
              $VAR = $REQ.getParameter(...);
              ...
              $COOKIE = new Cookie(..., $VAR, ...);
              ...
              $RESP.addCookie($COOKIE, ...);
          - patterns:
              - pattern-inside: |
                  $RETTYPE $FUNC(...,@PathVariable $TYPE $VAR, ...) {
                    ...
                  }
              - pattern: |
                  $COOKIE = new Cookie(..., $VAR, ...);
                  ...
                  $RESP.addCookie($COOKIE, ...);
    languages:
      - java
  - id: java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection
    metadata:
      cwe: "CWE-297: Improper Validation of Certificate with Host Mismatch"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_SMTP_SSL
    message: |
      Insecure SMTP connection detected. This connection will trust any SSL certificate.
      Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'.
    severity: WARNING
    patterns:
      - pattern-not-inside: |
          $EMAIL.setSSLCheckServerIdentity(true);
          ...
      - pattern-inside: |
          $EMAIL = new SimpleEmail(...);
          ...
      - pattern: $EMAIL.send(...);
    languages:
      - java
  - id: java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string
    metadata:
      cwe:
        "CWE-89: Improper Neutralization of Special Elements used in an SQL Command
        ('SQL Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION_SPRING_JDBC
    message: |
      Possible JDBC injection detected. Use the parameterized query
      feature available in queryForObject instead of concatenating or formatting strings:
      'jdbc.queryForObject("select * from table where name = ?", Integer.class, parameterName);'
    patterns:
      - pattern-inside: |
          $JDBC = new JdbcTemplate(...);
          ...
      - pattern-either:
          - pattern: $JDBC.queryForObject($STR + $VAR, ...);
          - pattern: $JDBC.queryForObject(String.format(...), ...);
          - pattern: |
              String $Q = $STR + $VAR;
              ...
              $JDBC.queryForObject($Q, ...);
          - pattern: |
              String $Q = String.format(...);
              ...
              $JDBC.queryForObject($Q, ...);
          - pattern: |
              StringBuilder $Q = new StringBuilder(...);
              ...
              $Q.append($STR + $VAR);
              ...
              $JDBC.queryForObject($Q, ...);
          - pattern: $JDBC.queryForList($STR + $VAR);
          - pattern: $JDBC.queryForList(String.format(...));
          - pattern: |
              String $Q = $STR + $VAR;
              ...
              $JDBC.queryForList($Q);
          - pattern: |
              String $Q = String.format(...);
              ...
              $JDBC.queryForList($Q);
          - pattern: |
              StringBuilder $Q = new StringBuilder(...);
              ...
              $Q.append($STR + $VAR);
              ...
              $JDBC.queryForList($Q, ...);
          - pattern: $JDBC.update($STR + $VAR);
          - pattern: $JDBC.update(String.format(...));
          - pattern: |
              String $Q = $STR + $VAR;
              ...
              $JDBC.update($Q);
          - pattern: |
              String $Q = String.format(...);
              ...
              $JDBC.update($Q);
          - pattern: |
              StringBuilder $Q = new StringBuilder(...);
              ...
              $Q.append($STR + $VAR);
              ...
              $JDBC.update($Q, ...);
          - pattern: $JDBC.execute($STR + $VAR);
          - pattern: $JDBC.execute(String.format(...));
          - pattern: |
              String $Q = $STR + $VAR;
              ...
              $JDBC.execute($Q);
          - pattern: |
              String $Q = String.format(...);
              ...
              $JDBC.execute($Q);
          - pattern: |
              StringBuilder $Q = new StringBuilder(...);
              ...
              $Q.append($STR + $VAR);
              ...
              $JDBC.execute($Q, ...);
          - pattern: $JDBC.insert($STR + $VAR);
          - pattern: $JDBC.insert(String.format(...));
          - pattern: |
              String $Q = $STR + $VAR;
              ...
              $JDBC.insert($Q);
          - pattern: |
              String $Q = String.format(...);
              ...
              $JDBC.insert($Q);
          - pattern: |
              StringBuilder $Q = new StringBuilder(...);
              ...
              $Q.append($STR + $VAR);
              ...
              $JDBC.insert($Q, ...);
    severity: WARNING
    languages:
      - java
  - id: java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning
    metadata:
      owasp: "A1: Injection"
      cwe:
        "CWE-90: Improper Neutralization of Special Elements used in an LDAP Query
        ('LDAP Injection')"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#LDAP_ENTRY_POISONING
      references:
        - https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf
        - https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html
    message: |
      An object-returning LDAP search will allow attackers to control the LDAP response. This could
      lead to Remote Code Execution.
    severity: WARNING
    pattern-either:
      - pattern: |
          new SearchControls($S, $CL, $TL, $AT, true, $DEREF)
      - pattern: |
          SearchControls $VAR = new SearchControls();
          ...
          $VAR.setReturningObjFlag(true);
    languages:
      - java
  - id: java.lang.security.audit.ldap-injection.ldap-injection
    message: |
      Detected non-constant data passed into an LDAP query. If this data can be
      controlled by an external user, this is an LDAP injection.
      Ensure data passed to an LDAP query is not controllable; or properly sanitize
      the data.
    metadata:
      cwe:
        "CWE-90: Improper Neutralization of Special Elements used in an LDAP Query
        ('LDAP Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#LDAP_INJECTION
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                InitialDirContext $CTX = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                DirContext $CTX = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                InitialLdapContext $CTX = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                LdapContext $CTX = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                LdapCtx $CTX = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                EventDirContext $CTX = ...;
                ...
              }
      - pattern: |
          $X $METHOD(...) {
            ...
            $CTX.search($Y,$INPUT,...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            $CTX.search($Y,"...",...);
            ...
          }
  - id: java.lang.security.audit.object-deserialization.object-deserialization
    metadata:
      cwe: "CWE-502: Deserialization of Untrusted Data"
      owasp: "A8: Insecure Deserialization"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#OBJECT_DESERIALIZATION
      references:
        - https://www.owasp.org/index.php/Deserialization_of_untrusted_data
    message: |
      Found object deserialization using ObjectInputStream. Deserializing entire
      Java objects is dangerous because malicious actors can create Java object
      streams with unintended consequences. Ensure that the objects being deserialized
      are not user-controlled. If this must be done, consider using HMACs to sign
      the data stream to make sure it is not tampered with, or consider only
      transmitting object fields and populating a new object.
    patterns:
      - pattern: new ObjectInputStream(...);
    severity: WARNING
    languages:
      - java
  - id: java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission
    message: |
      It is generally a bad practices to set overly permissive file permission such as read+write+exec for all users.
      If the file affected is a configuration, a binary, a script or sensitive data, it can lead to privilege escalation or information leakage.
    severity: WARNING
    languages:
      - java
    metadata:
      cwe: "CWE-276: Incorrect Default Permissions"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#OVERLY_PERMISSIVE_FILE_PERMISSION
    pattern-either:
      - pattern: java.nio.file.Files.setPosixFilePermissions($FILE, java.nio.file.attribute.PosixFilePermissions.fromString("=~/(^......r..$)|(^.......w.$)|(^........x$)/"));
      - pattern: |
          $TYPE $P = java.nio.file.attribute.PosixFilePermissions.fromString("=~/(^......r..$)|(^.......w.$)|(^........x$)/");
          ...
          java.nio.file.Files.setPosixFilePermissions($FILE, $P);
      - pattern: |
          $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_READ);
          ...
          java.nio.file.Files.setPosixFilePermissions($FILE, $P);
      - pattern: |
          $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_WRITE);
          ...
          java.nio.file.Files.setPosixFilePermissions($FILE, $P);
      - pattern: |-
          $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_EXECUTE);
          ...
          java.nio.file.Files.setPosixFilePermissions($FILE, $P);
  - id: java.lang.security.audit.permissive-cors.permissive-cors
    message: |
      https://find-sec-bugs.github.io/bugs.htm#PERMISSIVE_CORS
      Permissive CORS policy will allow a malicious application to communicate with the victim application in an inappropriate way, leading to spoofing, data theft, relay and other attacks.
    severity: WARNING
    languages:
      - java
    pattern-either:
      - pattern: |
          HttpServletResponse $RES = ...;
          ...
          $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
      - pattern: |
          HttpServletResponse $RES = ...;
          ...
          $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
      - pattern: |
          ServerHttpResponse $RES = ...;
          ...
          $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
      - pattern: |
          HttpHeaders $HEADERS = ...;
          ...
          $HEADERS.set("=~/access-control-allow-origin/i", "=~/^*|null$/i");
      - pattern: |
          ServerWebExchange $SWE = ...;
          ...
          $SWE.getResponse().getHeaders().add("Access-Control-Allow-Origin", "*");
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...) {
            ...
            $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...) {
            ...
            $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
            ...
          }
      - pattern: |
          $X $METHOD(...,ServerHttpResponse $RES,...) {
            ...
            $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
            ...
          }
      - pattern: |
          $X $METHOD(...,ServerWebExchange $SWE,...) {
            ...
            $SWE.getResponse().getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
            ...
          }
      - pattern: ResponseEntity.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
      - pattern: ServerResponse.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
  - id: java.lang.security.audit.script-engine-injection.script-engine-injection
    message: |
      Detected potential code injection using ScriptEngine. Ensure
      user-controlled data cannot enter '.eval()', otherwise, this is
      a code injection vulnerability.
    metadata:
      cwe: "CWE-94: Improper Control of Generation of Code ('Code Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SCRIPT_ENGINE_INJECTION
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern-inside: |
              class $CLASS {
                ...
                ScriptEngine $SE;
                ...
              }
          - pattern-inside: |
              class $CLASS {
                ...
                ScriptEngine $SE = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                ScriptEngine $SE = ...;
                ...
              }
      - pattern: |
          $X $METHOD(...) {
            ...
            $SE.eval(...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            $SE.eval("...");
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            String $S = "...";
            ...
            $SE.eval($S);
            ...
          }
  - id: java.lang.security.audit.unvalidated-redirect.unvalidated-redirect
    message: |
      Application redirects to a destination URL specified by a user-supplied
      parameter that is not validated. This could direct users to malicious locations.
      Consider using an allowlist to validate URLs.
    metadata:
      cwe: "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNVALIDATED_REDIRECT
    severity: WARNING
    languages:
      - java
    pattern-either:
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...,String $URL,...) {
            ...
            $RES.sendRedirect($URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,String $URL,...,HttpServletResponse $RES,...) {
            ...
            $RES.sendRedirect($URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
            ...
            String $URL = $REQ.getParameter(...);
            ...
            $RES.sendRedirect($URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
            ...
            String $URL = $REQ.getParameter(...);
            ...
            $RES.sendRedirect($URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,String $URL,...) {
            ...
            HttpServletResponse $RES = ...;
            ...
            $RES.sendRedirect($URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
            ...
            $RES.sendRedirect($REQ.getParameter(...));
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
            ...
            $RES.sendRedirect($REQ.getParameter(...));
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...,String $URL,...) {
            ...
            $RES.addHeader("Location",$URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,String $URL,...,HttpServletResponse $RES,...) {
            ...
            $RES.addHeader("Location",$URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
            ...
            String $URL = $REQ.getParameter(...);
            ...
            $RES.addHeader("Location",$URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
            ...
            String $URL = $REQ.getParameter(...);
            ...
            $RES.addHeader("Location",$URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,String $URL,...) {
            ...
            HttpServletResponse $RES = ...;
            ...
            $RES.addHeader("Location",$URL);
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
            ...
            $RES.addHeader("Location",$REQ.getParameter(...));
            ...
          }
      - pattern: |-
          $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
            ...
            $RES.addHeader("Location",$REQ.getParameter(...));
            ...
          }
  - id: java.lang.security.audit.url-rewriting.url-rewriting
    message: |
      URL rewriting has significant security risks.
      Since session ID appears in the URL, it may be easily seen by third parties.
    metadata:
      cwe: "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#URL_REWRITING
    severity: WARNING
    languages:
      - java
    pattern-either:
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...) {
            ...
            $RES.encodeURL(...);
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...) {
            ...
            $RES.encodeUrl(...);
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...) {
            ...
            $RES.encodeRedirectURL(...);
            ...
          }
      - pattern: |
          $X $METHOD(...,HttpServletResponse $RES,...) {
            ...
            $RES.encodeRedirectUrl(...);
            ...
          }
      - pattern: |
          $X $METHOD(...) {
            ...
            HttpServletResponse $RES = ...;
            ...
            $RES.encodeURL(...);
            ...
          }
      - pattern: |
          $X $METHOD(...) {
            ...
            HttpServletResponse $RES = ...;
            ...
            $RES.encodeUrl(...);
            ...
          }
      - pattern: |
          $X $METHOD(...) {
            ...
            HttpServletResponse $RES = ...;
            ...
            $RES.encodeRedirectURL(...);
            ...
          }
      - pattern: |-
          $X $METHOD(...) {
            ...
            HttpServletResponse $RES = ...;
            ...
            $RES.encodeRedirectUrl(...);
            ...
          }
  - id: java.lang.security.audit.weak-ssl-context.weak-ssl-context
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source_rule_url: https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT
      references:
        - https://tools.ietf.org/html/rfc7568
        - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
    message: |
      An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions
      are considered weak encryption and are deprecated.
      Use SSLContext.getInstance("TLSv1.2") for the best security.
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-not: SSLContext.getInstance("TLS1.3")
      - pattern-not: SSLContext.getInstance("TLS1.2")
      - pattern: SSLContext.getInstance("...")
    fix-regex:
      regex: (.*?)\.getInstance\(.*?\)
      replacement: \1.getInstance("TLS1.2")
  - id: java.lang.security.audit.xml-decoder.xml-decoder
    message: |
      XMLDecoder should not be used to parse untrusted data.
      Deserializing user input can lead to arbitrary code execution.
      Use an alternative and explicitly disable external entities.
      See https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html
      for alternatives and vulnerability prevention.
    metadata:
      cwe: "CWE-611: Improper Restriction of XML External Entity Reference"
      owasp: "A4: XML External Entities (XXE)"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XML_DECODER
      references:
        - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern: |
          $X $METHOD(...) {
            ...
            new XMLDecoder(...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            new XMLDecoder("...");
            ...
          }
      - pattern-not: |-
          $X $METHOD(...) {
            ...
            String $STR = "...";
            ...
            new XMLDecoder($STR);
            ...
          }
  - id: java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure
    metadata:
      owasp: "A7: Cross-Site Scripting (XSS)"
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_REQUEST_WRAPPER
    message: |
      It looks like you're using an implementation of XSSRequestWrapper from dzone.
      (https://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html)
      The XSS filtering in this code is not secure and can be bypassed by malicious actors.
      It is recommended to use a stack that automatically escapes in your view or templates
      instead of filtering yourself.
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: |
              class XSSRequestWrapper extends HttpServletRequestWrapper {
                ...
              }
          - pattern: |-
              $P = $X.compile("</script>", $X.CASE_INSENSITIVE);
              $V = $P.matcher(...).replaceAll("");
    languages:
      - java
  - id: java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
    metadata:
      cwe:
        "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path
        Traversal')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
      references:
        - https://www.owasp.org/index.php/Path_Traversal
    message: |
      Detected a potential path traversal. A malicious actor
      could control the location of this file, to include going backwards
      in the directory with '../'. To address this, ensure that user-controlled
      variables in file paths are sanitized. You may aslso consider using a utility
      method such as org.apache.commons.io.FilenameUtils.getName(...) to only
      retrieve the file name from the path.
    patterns:
      - pattern-inside: |
          $RETURNTYPE $FUNC (..., HttpServletRequest $REQ, ...) {
            ...
          }
      - pattern-either:
          - pattern: |
              $VAR = ($TYPE)$REQ.getParameter(...);
              ...
              new File(..., $VAR, ...);
          - pattern: |
              $VAR = $REQ.getParameter(...);
              ...
              new File(..., $VAR, ...);
    severity: ERROR
    languages:
      - java
  - id: java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss
    message: |
      Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User
      input was detected going directly from the HttpServletRequest into output. Ensure your
      data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-Site Scripting ('XSS')"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET
    severity: ERROR
    patterns:
      - pattern-inside: $TYPE $FUNC(..., HttpServletResponse $RESP, ...) { ... }
      - pattern-inside: $VAR = $REQ.getParameter(...); ...
      - pattern-either:
          - pattern: $RESP.getWriter(...).write(..., $VAR, ...);
          - pattern: |
              $WRITER = $RESP.getWriter(...);
              ...
              $WRITER.write(..., $VAR, ...);
    languages:
      - java
  - id: java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled
    severity: ERROR
    metadata:
      cwe: "CWE-611: Improper Restriction of XML External Entity Reference"
      owasp: "A4: XML External Entities (XXE)"
      references:
        - https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf
    message: |
      XML external entities are enabled for this XMLInputFactory. This is vulnerable to XML external entity
      attacks. Disable external entities by setting "javax.xml.stream.isSupportingExternalEntities" to false.
    pattern:
      $XMLFACTORY.setProperty("javax.xml.stream.isSupportingExternalEntities",
      true);
    languages:
      - java
  - id: java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe
    severity: WARNING
    metadata:
      cwe: "CWE-611: Improper Restriction of XML External Entity Reference"
      owasp: "A4: XML External Entities (XXE)"
      references:
        - https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf
        - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#xmlinputfactory-a-stax-parser
    message: |
      XML external entities are not explicitly disabled for this XMLInputFactory. This could be vulnerable to XML external entity
      vulnerabilities. Explicitly disable external entities by setting "javax.xml.stream.isSupportingExternalEntities" to false.
    patterns:
      - pattern-not-inside: |
          $RETURNTYPE $METHOD(...) {
            ...
            $XMLFACTORY.setProperty("javax.xml.stream.isSupportingExternalEntities", false);
            ...
          }
      - pattern-not-inside: |
          $RETURNTYPE $METHOD(...) {
            ...
            $XMLFACTORY.setProperty(java.xml.stream.XMLFactoryInput.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
            ...
          }
      - pattern-either:
          - pattern: $XMLFACTORY = $W.newFactory(...);
          - pattern: $XMLFACTORY = new XMLInputFactory(...);
    languages:
      - java
  - id: java.rmi.security.server-dangerous-object-deserialization.server-dangerous-object-deserialization
    severity: ERROR
    metadata:
      cwe: "CWE-502: Deserialization of Untrusted Data"
      owasp: "A8: Insecure Deserialization"
      references:
        - https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/
        - https://frohoff.github.io/appseccali-marshalling-pickles/
    message: |
      Using an arbitrary object ('Object $PARAM') with Java RMI is an insecure deserialization
      vulnerability. This object can be manipulated by a malicious actor allowing them to execute
      code on your system. Instead, use an integer ID to look up your object, or consider alternative
      serializiation schemes such as JSON.
    patterns:
      - pattern: |
          interface $INTERFACE extends Remote {
            $RETURNTYPE $METHOD(Object $PARAM) throws RemoteException;
          }
    languages:
      - java
  - id: java.spring.security.audit.spel-injection.spel-injection
    message: |
      A Spring expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
    metadata:
      cwe: "CWE-94: Improper Control of Generation of Code ('Code Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPEL_INJECTION
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern-inside: |
              class $CLASS {
                ...
                ExpressionParser $PARSER;
                ...
              }
          - pattern-inside: |
              class $CLASS {
                ...
                ExpressionParser $PARSER = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                ExpressionParser $PARSER = ...;
                ...
              }
          - pattern-inside: |
              class $CLASS {
                ...
                SpelExpressionParser $PARSER;
                ...
              }
          - pattern-inside: |
              class $CLASS {
                ...
                SpelExpressionParser $PARSER = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                SpelExpressionParser $PARSER = ...;
                ...
              }
          - pattern-inside: |
              class $CLASS {
                ...
                TemplateAwareExpressionParser $PARSER;
                ...
              }
          - pattern-inside: |
              class $CLASS {
                ...
                TemplateAwareExpressionParser $PARSER = ...;
                ...
              }
          - pattern-inside: |
              $X $METHOD(...) {
                ...
                TemplateAwareExpressionParser $PARSER = ...;
                ...
              }
      - pattern: |
          $X $METHOD(...) {
            ...
            $PARSER.parseExpression(...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            $PARSER.parseExpression("...");
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            String $S = "...";
            ...
            $PARSER.parseExpression($S);
            ...
          }
  - id: java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled
    message: |
      CSRF is disabled for this configuration. This is a security risk.
    metadata:
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_PROTECTION_DISABLED
    severity: WARNING
    languages:
      - java
    pattern: $OBJ.csrf(...).disable(...)
  - id: java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect
    message: |
      Application redirects a user to a destination URL specified by a user supplied parameter that is not validated.
    metadata:
      cwe: "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
      owasp: "A1: Injection"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNVALIDATED_REDIRECT
    severity: WARNING
    languages:
      - java
    pattern-either:
      - pattern: |
          $X $METHOD(...,String $URL,...) {
            return "redirect:" + $URL;
          }
      - pattern: |
          $X $METHOD(...,String $URL,...) {
            ...
            String $REDIR = "redirect:" + $URL;
            ...
            return $REDIR;
            ...
          }
      - pattern: |
          $X $METHOD(...,String $URL,...) {
            ...
            new ModelAndView("redirect:" + $URL);
            ...
          }
      - pattern: |-
          $X $METHOD(...,String $URL,...) {
            ...
            String $REDIR = "redirect:" + $URL;
            ...
            new ModelAndView($REDIR);
            ...
          }
  - id: java.spring.security.unrestricted-request-mapping.unrestricted-request-mapping
    patterns:
      - pattern: |
          @RequestMapping(...)
          $RETURNTYPE $METHOD(...) { ... }
      - pattern-not-inside: |
          @RequestMapping(..., method = $X)
          $RETURNTYPE $METHOD(...) { ... }
    message:
      Detected a method annotated with 'RequestMapping' that does not specify
      the HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or OPTIONS,
      and by default all HTTP methods are allowed when the HTTP method is not explicitly
      specified. This means that a method that performs state changes could be vulnerable
      to CSRF attacks. To mitigate, add the 'method' field and specify the HTTP method
      (such as 'RequestMethod.POST').
    severity: WARNING
    metadata:
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
      references:
        - https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
    languages:
      - java
  - id: javascript.grpc.security.grpc-nodejs-insecure-connection.grpc-nodejs-insecure-connection
    message: |
      Found an insecure gRPC connection. This creates a connection without encryption to a gRPC client/server. A malicious attacker
      could tamper with the gRPC message, which could compromise the machine.
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
    severity: ERROR
    languages:
      - javascript
    pattern-either:
      - pattern: |
          require('grpc');
          ...
          $GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);
      - pattern: |-
          require('grpc');
          ...
          $CREDS = <... $CREDENTIALS.createInsecure() ...>;
          ...
          $GRPC($ADDR,...,$CREDS,...);
  - id: javascript.jose.security.jwt-exposed-credentials.jwt-exposed-credentials
    languages:
      - javascript
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      references:
        - https://cwe.mitre.org/data/definitions/522.html
    message: |
      Password is exposed through JWT token payload. This is not encrypted and
      the password could be compromised. Do not store passwords in JWT tokens.
    patterns:
      - pattern-either:
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign({password:...},...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $T = JWT.sign({password:...},...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = {password:...};
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = {password:...};
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = {password:...};
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = {password:...};
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P.password = ...;
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P.password = ...;
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $T = JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $T = JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = {$U:{password:...}};
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = {$U:{password:...}};
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = {$U:{password:...}};
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = {$U:{password:...}};
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P.$U.password = ...;
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P.$U.password = ...;
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              var $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $T = JWT.sign($P,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    severity: ERROR
  - id: javascript.jose.security.jwt-hardcode.hardcoded-jwt-secret
    message: |
      Hardcoded JWT secret or private key is used.
      This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
      Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    patterns:
      - pattern-either:
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              JWT.verify($P, "...", ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.sign($P, "...", ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $T = JWT.verify($P, "...", ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              JWT.verify($P, JWK.asKey("..."), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $KEY = JWK.asKey("...");
              ...
              JWT.verify($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $T = JWT.sign($P, JWK.asKey("..."), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $T = JWT.verify($P, JWK.asKey("..."), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $KEY = JWK.asKey("...");
              ...
              var $T = JWT.sign($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $KEY = JWK.asKey("...");
              ...
              var $T = JWT.verify($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              JWT.verify($P, $SECRET, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $T = JWT.sign($P, $SECRET, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $T = JWT.verify($P, $SECRET, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              JWT.verify($P, JWK.asKey($SECRET), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $KEY = JWK.asKey($SECRET);
              ...
              JWT.verify($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $T = JWT.sign($P, JWK.asKey($SECRET), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $KEY = JWK.asKey($SECRET);
              ...
              var $T = JWT.sign($P, $KEY, ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $T = JWT.verify($P, JWK.asKey($SECRET), ...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $SECRET = "...";
              ...
              var $KEY = JWK.asKey($SECRET);
              ...
              var $T = JWT.verify($P, $KEY, ...);
    languages:
      - javascript
    severity: ERROR
  - id: javascript.jose.security.jwt-none-alg.jwt-none-alg
    message: |
      Detected use of the 'none' algorithm in a JWT token.
      The 'none' algorithm assumes the integrity of the token has already
      been verified. This would allow a malicious actor to forge a JWT token
      that will automatically be verified. Do not explicitly use the 'none'
      algorithm. Instead, use an algorithm such as 'HS256'.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    languages:
      - javascript
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              var $T = JWT.verify($P, JWK.None,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              $T = JWT.verify($P, JWK.None,...);
          - pattern: |
              var $JOSE = require("jose");
              ...
              var { JWK, JWT } = $JOSE;
              ...
              JWT.verify($P, JWK.None,...);
  - id: javascript.jsonwebtoken.security.jwt-exposed-credentials.jwt-exposed-credentials
    languages:
      - javascript
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
      references:
        - https://cwe.mitre.org/data/definitions/522.html
    message: |
      Password is exposed through JWT token payload. This is not encrypted and
      the password could be compromised. Do not store passwords in JWT tokens.
    patterns:
      - pattern-either:
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign({password:...},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.sign({password:...},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign({password:...},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {password:...};
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {password:...};
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {password:...};
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {password:...};
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {password:...};
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {password:...};
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.password = ...;
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.password = ...;
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.password = ...;
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{password:...},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{password:...},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign(Object.assign(...,{password:...},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign({$U:{password:...}},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {$U:{password:...}};
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {$U:{password:...}};
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = {$U:{password:...}};
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {$U:{password:...}};
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {$U:{password:...}};
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = {$U:{password:...}};
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.$U.password = ...;
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.$U.password = ...;
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P.$U.password = ...;
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              var $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $T = $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $P = Object.assign(...,{$U:{password:...}},...);
              ...
              $JWT.sign($P,...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    severity: ERROR
  - id: javascript.jsonwebtoken.security.jwt-hardcode.hardcoded-jwt-secret
    message: |
      Hardcoded JWT secret or private key is used.
      This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
      Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
    metadata:
      cwe: "CWE-522: Insufficiently Protected Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    patterns:
      - pattern-either:
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.sign($P, "...", ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.verify($P, "...", ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.sign($P, "...", ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.verify($P, "...", ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $SECRET = "...";
              ...
              var $T = $JWT.sign($P, $SECRET, ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $SECRET = "...";
              ...
              var $T = $JWT.verify($P, $SECRET, ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $SECRET = "...";
              ...
              $JWT.sign($P, $SECRET, ...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $SECRET = "...";
              ...
              $JWT.verify($P, $SECRET, ...);
    languages:
      - javascript
    severity: ERROR
  - id: javascript.jsonwebtoken.security.jwt-none-alg.jwt-none-alg
    message: |
      Detected use of the 'none' algorithm in a JWT token.
      The 'none' algorithm assumes the integrity of the token has already
      been verified. This would allow a malicious actor to forge a JWT token
      that will automatically be verified. Do not explicitly use the 'none'
      algorithm. Instead, use an algorithm such as 'HS256'.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    languages:
      - javascript
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              var $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
          - pattern: |
              var $JWT = require("jsonwebtoken");
              ...
              $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
          - pattern: |-
              var $JWT = require("jsonwebtoken");
              ...
              $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
  - id: javascript.lang.security.detect-buffer-noassert.detect-buffer-noassert
    metadata:
      cwe:
        "CWE-119: Improper Restriction of Operations within the Bounds of a Memory
        Buffer"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-buffer-noassert.js
    message: |
      Detected usage of noassert in Buffer API, which allows the offset the be beyond the
      end of the buffer. This could result in writing or reading beyond the end of the buffer.
    patterns:
      - pattern: $OBJ.$API(..., true)
      - metavariable-regex:
          metavariable: $API
          regex: (read|write)(U?Int8|(U?Int(16|32)|Float|Double)(LE|BE))
    severity: WARNING
    languages:
      - javascript
      - typescript
  - id: javascript.lang.security.detect-child-process.detect-child-process
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js
    message: |
      Detected non-literal calls to child_process.exec(). This could lead to a command
      injection vulnerability.
    patterns:
      - pattern: child_process.exec(...)
      - pattern-not: child_process.exec('...')
    severity: WARNING
    languages:
      - javascript
      - typescript
  - id: javascript.lang.security.detect-disable-mustache-escape.detect-disable-mustache-escape
    metadata:
      cwe: "CWE-116: Improper Encoding or Escaping of Output"
      owasp: "A7: Cross-Site Scripting XSS"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-disable-mustache-escape.js
    message: |
      Markup escaping disabled. This can be used with some template engines to escape
      disabling of HTML entities, which can lead to XSS attacks.
    pattern: $OBJ.escapeMarkup = false
    severity: WARNING
    languages:
      - javascript
      - typescript
  - id: javascript.lang.security.detect-eval-with-expression.detect-eval-with-expression
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-eval-with-expression.js
    message: |
      Detected eval(variable), which could allow a malicious actor to run arbitrary code.
    patterns:
      - pattern: eval($OBJ)
      - pattern-not: eval("...")
    severity: WARNING
    languages:
      - javascript
      - typescript
  - id: javascript.lang.security.detect-no-csrf-before-method-override.detect-no-csrf-before-method-override
    metadata:
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-no-csrf-before-method-override.js
      references:
        - https://github.com/nodesecurity/eslint-plugin-security/blob/master/docs/bypass-connect-csrf-protection-by-abusing.md
    message: |
      Detected use of express.csrf() middleware before express.methodOverride(). This can
      allow GET requests (which are not checked by csrf) to turn into POST requests later.
    pattern: |
      express.csrf();
      ...
      express.methodOverride();
    severity: WARNING
    languages:
      - javascript
      - typescript
  - id: javascript.lang.security.detect-non-literal-require.detect-non-literal-require
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-require.js
    message: |
      Detected the use of require(variable). Calling require with a non-literal argument might
      allow an attacker to load an run arbitrary code, or access arbitrary files.
    patterns:
      - pattern: require($OBJ)
      - pattern-not: require('...')
    severity: WARNING
    languages:
      - javascript
      - typescript
  - id: javascript.lang.security.detect-pseudorandombytes.detect-pseudoRandomBytes
    metadata:
      cwe: "CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)"
      owasp: "A9: Using Components with Known Vulnerabilities"
      source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-pseudoRandomBytes.js
    message: |
      Detected usage of crypto.pseudoRandomBytes, which does not produce secure random numbers.
    pattern: crypto.pseudoRandomBytes
    severity: WARNING
    languages:
      - javascript
      - typescript
  - id: javascript.lang.security.spawn-git-clone.spawn-git-clone
    message: |
      Git allows shell commands to be specified in ext URLs for remote repositories.
      For example, git clone 'ext::sh -c whoami% >&2' will execute the whoami command to try to connect to a remote repository.
      Make sure that the URL is not controlled by external input.
    metadata:
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
    languages:
      - javascript
      - typescript
    severity: ERROR
    patterns:
      - pattern-either:
          - pattern: spawn('git', ['clone',...,$F])
          - pattern: $X.spawn('git', ['clone',...,$F])
          - pattern: spawn('git', ['clone',...,$P,$F])
          - pattern: $X.spawn('git', ['clone',...,$P,$F])
      - pattern-not: spawn('git', ['clone',...,"..."])
      - pattern-not: $X.spawn('git', ['clone',...,"..."])
      - pattern-not: spawn('git', ['clone',...,"...","..."])
      - pattern-not: $X.spawn('git', ['clone',...,"...","..."])
  - id: javascript.node-expat.security.audit.expat-xxe.expat-xxe
    message: |
      If unverified user data can reach the XML Parser it can result in XML External or
      Internal Entity (XXE) Processing vulnerabilities
    metadata:
      owasp: "A4: XML External Entities (XXE)"
      cwe: "CWE-611: Improper Restriction of XML External Entity Reference"
    severity: WARNING
    languages:
      - javascript
    patterns:
      - pattern-either:
          - pattern: |
              var $EXPAT = require('node-expat');
              ...
              new $EXPAT.Parser(...);
              ...
              $PARSER.parse(...);
          - pattern: |
              var $EXPAT = require('node-expat');
              ...
              new $EXPAT.Parser(...);
              ...
              $PARSER.write(...);
          - pattern: |
              require('node-expat');
              ...
              new Parser(...);
              ...
              $PARSER.parse(...);
          - pattern: |
              require('node-expat');
              ...
              new Parser(...);
              ...
              $PARSER.write(...);
      - pattern-not: |
          var $EXPAT = require('node-expat');
          ...
          new $EXPAT.Parser(...);
          ...
          $PARSER.parse("...");
      - pattern-not: |
          var $EXPAT = require('node-expat');
          ...
          new $EXPAT.Parser(...);
          ...
          $PARSER.write("...");
      - pattern-not: |
          require('node-expat');
          ...
          new Parser(...);
          ...
          $PARSER.parse("...");
      - pattern-not: |
          require('node-expat');
          ...
          new Parser(...);
          ...
          $PARSER.write("...");
      - pattern-not: |
          $X = "...";
          ...
          $PARSER.parse($X);
      - pattern-not: |-
          $X = "...";
          ...
          $PARSER.write($X);
  - id: javascript.sax.security.audit.sax-xxe.sax-xxe
    message: |
      Use of 'ondoctype' in 'sax' library detected. By default, 'sax'
      won't do anything with custom DTD entity definitions. If you're
      implementing a custom DTD entity definition, be sure not to introduce
      XML External Entity (XXE) vulnerabilities, or be absolutely sure that
      external entities received from a trusted source while processing XML.
    metadata:
      owasp: "A4: XML External Entities (XXE)"
      cwe: "CWE-611: Improper Restriction of XML External Entity Reference"
      references:
        - https://github.com/Leonidas-from-XIV/node-xml2js/issues/415
        - https://github.com/isaacs/sax-js
    severity: WARNING
    languages:
      - javascript
    pattern-either:
      - pattern: |
          require('sax');
          ...
          $PARSER.ondoctype = ...;
      - pattern: |-
          require('sax');
          ...
          $PARSER.on('doctype',...);
  - id: javascript.xml2json.security.audit.xml2json-xxe.xml2json-xxe
    message: |
      If unverified user data can reach the XML Parser it can result in XML External or
      Internal Entity (XXE) Processing vulnerabilities
    metadata:
      owasp: "A4: XML External Entities (XXE)"
      cwe: "CWE-611: Improper Restriction of XML External Entity Reference"
    severity: WARNING
    languages:
      - javascript
    patterns:
      - pattern: |
          var $XML = require('xml2json');
          ...
          $XML.toJson(...);
      - pattern-not: |
          var $XML = require('xml2json');
          ...
          $XML.toJson("...",...);
      - pattern-not: |-
          var $XML = require('xml2json');
          ...
          var $S = "...";
          ...
          $XML.toJson($S,...);
  - id: javascript.lang.security.audit.unknown-value-with-script-tag.unknown-value-with-script-tag
    patterns:
      - pattern-inside: |
          $UNK = $ANYFUNC(...);
          ...
          $OTHERFUNC(..., <... $UNK ...>, ...);
      - pattern: $OTHERFUNC(..., <... "=~/.*<script.*/" ...>, ...)
    message: |
      Cannot determine what '$UNK' is and it is used with a '<script>' tag. This
      could be susceptible to cross-site scripting (XSS). Ensure '$UNK' is not
      externally controlled, or sanitize this data.
    metadata:
      owasp: "A7: Cross-site Scripting (XSS)"
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      references:
        - https://www.developsec.com/2017/11/09/xss-in-a-script-tag/
        - https://github.com/juice-shop/juice-shop/blob/1ceb8751e986dacd3214a618c37e7411be6bc11a/routes/videoHandler.ts#L68
    severity: WARNING
    languages:
      - javascript
      - typescript
  - id: javascript.express.security.audit.possible-user-input-redirect.unknown-value-in-redirect
    patterns:
      - pattern-either:
          - pattern-inside: |
              $UNK = query.$B;
              ...
          - pattern-inside: |
              $UNK = $A.query.$B;
              ...
          - pattern-inside: |
              $UNK = req.$SOMETHING;
              ...
      - pattern: $RES.redirect(..., <... $UNK ...>, ...)
    message: |
      It looks like '$UNK' is read from user input and it is used to as a redirect. Ensure
      '$UNK' is not externally controlled, otherwise this is an open redirect.
    metadata:
      owasp: "A1: Injection"
      cwe: "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
    severity: WARNING
    languages:
      - javascript
  - id: python.airflow.security.audit.formatted-string-bashoperator.formatted-string-bashoperator
    patterns:
      - pattern-either:
          - pattern: |
              airflow.operators.bash_operator.BashOperator(..., bash_command="..." + $CONCAT, ...)
          - pattern: |
              airflow.operators.bash_operator.BashOperator(..., bash_command="...".format(...), ...)
          - pattern: |
              airflow.operators.bash_operator.BashOperator(..., bash_command=f"...", ...)
          - pattern: |
              airflow.operators.bash_operator.BashOperator(..., bash_command="..." % $PARAMS, ...)
          - pattern: |
              $CMD = "..." % $PARAMS
              ...
              airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
          - pattern: |
              $CMD = $STR.format(...)
              ...
              airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
          - pattern: |
              $CMD = f"..."
              ...
              airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
          - pattern: |
              $CMD = "..." + $CONCAT
              ...
              airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
          - pattern: |
              $CMD = "..."
              ...
              $CMD += $CONCAT
              ...
              airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
    message: |
      Found a formatted string in BashOperator: $CMD.
      This could be vulnerable to injection.
      Be extra sure your variables are not controllable by external sources.
    metadata:
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
    languages:
      - python
    severity: WARNING
  - id: python.boto3.security.hardcoded-token.hardcoded-token
    message: |
      Hardcoded AWS access token detected. Use environment variables
      to access tokens (e.g., os.environ.get(...)) or use non version-controlled
      configuration files.
    metadata:
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://pypi.org/project/flake8-boto3/
      references:
        - https://bento.dev/checks/boto3/hardcoded-access-token/
        - https://aws.amazon.com/blogs/security/what-to-do-if-you-inadvertently-expose-an-aws-access-key/
    patterns:
      - pattern-either:
          - pattern: $W(..., aws_secret_access_key="=~/^[A-Za-z0-9/+=]+$/", ...)
          - pattern: $W(..., aws_access_key_id="=~/^AKI/", ...)
          - pattern: $W(..., aws_session_token="...", ...)
    languages:
      - python
    severity: WARNING
  - id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-blowfish
    pattern: cryptography.hazmat.primitives.ciphers.algorithms.Blowfish(...)
    message: |
      Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L96
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-idea
    pattern: cryptography.hazmat.primitives.ciphers.algorithms.IDEA(...)
    message: |
      Detected IDEA cipher algorithm which is considered insecure. The algorithm is
      considered weak and has been deprecated. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://tools.ietf.org/html/rfc5469
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-rc4
    pattern: cryptography.hazmat.primitives.ciphers.algorithms.ARC4(...)
    message: |
      Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L94
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
    pattern: cryptography.hazmat.primitives.ciphers.modes.ECB(...)
    message: |
      Detected ECB cipher mode which is considered insecure. The algorithm can
      potentially leak information about the plaintext. Use CBC mode instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L101
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B305
      references:
        - https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
    pattern: cryptography.hazmat.primitives.hashes.MD5(...)
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B303
      references:
        - https://tools.ietf.org/html/rfc6151
        - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
    pattern: cryptography.hazmat.primitives.hashes.SHA1(...)
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B303
      references:
        - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
        - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
        - http://2012.sharcs.org/slides/stevens.pdf
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.cryptography.security.insufficient-ec-key-size.insufficient-ec-key-size
    patterns:
      - pattern-inside: cryptography.hazmat.primitives.asymmetric.ec.generate_private_key(...)
      - pattern-either:
          - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECP192R1
          - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163K1
          - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163R2
    message: |
      Detected an insufficient curve size for EC. NIST recommends
      a key size of 224 or higher. For example, use 'ec.SECP256R1'.
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
      references:
        - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
        - https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#elliptic-curves
    languages:
      - python
    severity: WARNING
  - id: python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
      references: https://docs.python.org/3/library/pickle.html
    message:
      Avoid using insecure deserialization library, backed by `pickle`, `_pickle`,
      `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code
      execution vulnerabilities.
    languages:
      - python
    severity: ERROR
    patterns:
      - pattern-inside: |
          def $X(..., request, ...):
            ...
      - pattern-either:
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              pickle.$FUNC(<... $VAR ...>)
          - pattern: pickle.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              _pickle.$FUNC(<... $VAR ...>)
          - pattern: _pickle.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              cPickle.$FUNC(<... $VAR ...>)
          - pattern: cPickle.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              dill.$FUNC(<... $VAR ...>)
          - pattern: dill.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              shelve.$FUNC(<... $VAR ...>)
          - pattern: shelve.$FUNC(<... request.$Y.get(...) ...>)
          - pattern: |
              $VAR = <... request.$Y.get(...) ...>
              ...
              yaml.$FUNC(<... $VAR ...>)
          - pattern: yaml.$FUNC(<... request.$Y.get(...) ...>)
  - id: python.django.security.audit.avoid-mark-safe.avoid-mark-safe
    patterns:
      - pattern-not-inside: django.utils.html.format_html(...)
      - pattern-not: django.utils.safestring.mark_safe("...")
      - pattern: django.utils.safestring.mark_safe(...)
    message: |
      'mark_safe()' is used to mark a string as "safe" for HTML output.
      This disables escaping and could therefore subject the content to
      XSS attacks. Use 'django.utils.html.format_html()' to build HTML
      for rendering instead.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-Site Scripting (XSS)"
      references:
        - https://docs.djangoproject.com/en/3.0/ref/utils/#django.utils.safestring.mark_safe
        - https://docs.djangoproject.com/en/3.0/ref/utils/#django.utils.html.format_html
    languages:
      - python
    severity: WARNING
  - id: python.django.security.audit.csrf-exempt.no-csrf-exempt
    pattern: |
      @django.views.decorators.csrf.csrf_exempt
      def $R(...):
        ...
    message: There is rarely a good reason to use @csrf_exempt as is used for `$R`.
    metadata:
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A6: Security Misconfiguration"
    languages:
      - python
    severity: WARNING
  - id: python.django.security.audit.custom-expression-as-sql.custom-expression-as-sql
    languages:
      - python
    message:
      Detected a Custom Expression ''$EXPRESSION'' calling ''as_sql(...).'' Ensure
      no user input enters this function because it is susceptible to SQL injection.
      See https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.Func.as_sql
      for more information.
    metadata:
      cwe:
        "CWE-89: Improper Neutralization of Special Elements used in an SQL Command
        ('SQL Injection')"
      owasp: "A1: Injection"
      references:
        - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.Func.as_sql
        - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
    pattern: $EXPRESSION.as_sql(...)
    severity: WARNING
  - id: python.django.security.audit.extends-custom-expression.extends-custom-expression
    languages:
      - python
    message: |
      Found extension of custom expression: $CLASS. Extending expressions
      in this way could inadvertently expose a SQL injection vulnerability.
      See https://docs.djangoproject.com/en/3.0/ref/models/expressions/#avoiding-sql-injection
      for more information.
    metadata:
      cwe:
        "CWE-89: Improper Neutralization of Special Elements used in an SQL Command
        ('SQL Injection')"
      owasp: "A1: Injection"
      references:
        - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#avoiding-sql-injection
        - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
    patterns:
      - pattern-either:
          - pattern: |
              class $CLASS(..., django.db.models.Func, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Func, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Expression, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Expression, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Value, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Value, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.DurationValue, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.DurationValue, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.RawSQL, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.RawSQL, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Star, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Star, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Random, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Random, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Col, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Col, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Ref, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Ref, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.ExpressionList, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.ExpressionList, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.ExpressionWrapper, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.ExpressionWrapper, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.When, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.When, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Case, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Case, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Subquery, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Subquery, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Exists, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Exists, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.Window, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.Window, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.WindowFrame, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.WindowFrame, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.RowRange, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.RowRange, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.ValueRange, ...):
                  ...
          - pattern: |
              class $CLASS(..., django.db.models.expressions.ValueRange, ...):
                  ...
    severity: WARNING
  - id: python.django.security.audit.query-set-extra.avoid-query-set-extra
    patterns:
      - pattern-either:
          - pattern: $X.objects.$FUNC(...).extra(...)
          - pattern: $X.objects.$FUNC(...).$FILTER(...).extra(...)
          - pattern: $X.objects.$FUNC(...).$FILTER(...).$UPDATE(...).extra(...)
    message:
      This is a last resort. You should be careful when using QuerySet.extra
      due to SQLi https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.extra
    metadata:
      cwe:
        "CWE-89: Improper Neutralization of Special Elements used in an SQL Command
        ('SQL Injection')"
      owasp: "A1: Injection"
      references:
        - https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.extra
        - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
    languages:
      - python
    severity: ERROR
  - id: python.django.security.audit.raw-query.avoid-raw-sql
    patterns:
      - pattern-either:
          - pattern: $MODEL.objects.raw($QUERY, ...)
          - pattern: django.db.models.expressions.RawSQL(...)
    message:
      You should be very careful whenever you write raw SQL. Consider using Django
      ORM before raw SQL. See https://docs.djangoproject.com/en/3.0/topics/db/sql/#passing-parameters-into-raw
    metadata:
      cwe:
        "CWE-89: Improper Neutralization of Special Elements used in an SQL Command
        ('SQL Injection')"
      owasp: "A1: Injection"
      references:
        - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#raw-sql-expressions
        - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
    languages:
      - python
    severity: ERROR
  - id: python.django.security.audit.secure-cookies.django-secure-set-cookie
    patterns:
      - pattern-either:
          - pattern-inside: |
              import django.http.HttpResponse
              ...
          - pattern-inside: |
              import django.shortcuts.render
              ...
      - pattern-not-inside: |
          LANGUAGE_QUERY_PARAMETER = 'language'
          ...
          def set_language(request):
              ...
          # Exclude vendored contrib/messages/storage/cookie.py
      - pattern-not-inside: |
          class CookieStorage(django.contrib.messages.storage.base.BaseStorage):
              ...
          # Exclude cookies handled by vendored middleware
      - pattern-not: response.set_cookie(django.conf.settings.SESSION_COOKIE_NAME, ...)
      - pattern-not: response.set_cookie(django.conf.settings.CSRF_COOKIE_NAME, ...)
      - pattern-not: response.set_cookie(django.conf.settings.LANGUAGE_COOKIE_NAME, ...)
      - pattern-not:
          response.set_cookie(rest_framework_jwt.settings.api_settings.JWT_AUTH_COOKIE,
          ...)
      - pattern-not: response.set_cookie(..., secure=$A, httponly=$B, samesite=$C, ...)
      - pattern-not: response.set_cookie(..., **$A)
      - pattern: response.set_cookie(...)
    message: |
      Django cookies should be handled securely by setting secure=True, httponly=True, and samesite='Lax' in
      response.set_cookie(...). If your situation calls for different settings, explicitly disable the setting.
      If you want to send the cookie over http, set secure=False.  If you want to let client-side JavaScript
      read the cookie, set httponly=False. If you want to attach cookies to requests for external sites,
      set samesite=None.
    metadata:
      cwe: "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://docs.djangoproject.com/en/3.0/ref/request-response/#django.http.HttpResponse.set_cookie
        - https://blog.r2c.dev/2020/bento-check-keeping-cookies-safe-in-flask/
        - https://bento.dev/checks/flask/secure-set-cookie/
    languages:
      - python
    severity: WARNING
  - id: python.django.security.audit.unvalidated-password.unvalidated-password
    patterns:
      - pattern-not-inside: |
          if <... django.contrib.auth.password_validation.validate_password(...) ...>:
              ...
      - pattern-not-inside: |
          django.contrib.auth.password_validation.validate_password(...)
          ...
      - pattern-not-inside: |
          try:
            ...
            django.contrib.auth.password_validation.validate_password(...)
            ...
          except $EX:
            ...
          ...
      - pattern-not-inside: |
          try:
            ...
            django.contrib.auth.password_validation.validate_password(...)
            ...
          except $EX as $E:
            ...
          ...
      - pattern-not: UserModel().set_password($X)
      - pattern: $MODEL.set_password($X)
    fix: |
      if django.contrib.auth.password_validation.validate_password($X, user=$MODEL):
          $MODEL.set_password($X)
    message: |
      The password on '$MODEL' is being set without validating the password.
      Call django.contrib.auth.password_validation.validate_password() with
      validation functions before setting the password. See
      https://docs.djangoproject.com/en/3.0/topics/auth/passwords/
      for more information.
    metadata:
      cwe: "CWE-521: Weak Password Requirements"
      owasp: "A2: Broken Authentication"
      references:
        - https://docs.djangoproject.com/en/3.0/topics/auth/passwords/#module-django.contrib.auth.password_validation
    languages:
      - python
    severity: WARNING
  - id: python.django.security.injection.code.globals-misuse-code-execution.globals-misuse-code-execution
    message: |
      Found request data as an index to 'globals()'. This is extremely
      dangerous because it allows an attacker to execute arbitrary code
      on the system. Refactor your code not to use 'globals()'.
    metadata:
      cwe:
        "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static
        Code Injection')"
      owasp: "A1: Injection"
      references:
        - https://github.com/mpirnat/lets-be-bad-guys/blob/d92768fb3ade32956abd53bd6bb06e19d634a084/badguys/vulnerable/views.py#L181-L186
    languages:
      - python
    severity: WARNING
    patterns:
      - pattern-inside: |
          def $FUNC(...):
            ...
      - pattern-either:
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals().get($DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals().get("..." % $DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals().get(f"...{$DATA}...", ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals().get("...".format(..., $DATA, ...), ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals()[$DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals()["..." % $DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals()[f"...{$DATA}..."]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = globals()["...".format(..., $DATA, ...)]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals().get($DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals().get("..." % $DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals().get(f"...{$DATA}...", ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals().get("...".format(..., $DATA, ...), ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals()[$DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals()["..." % $DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals()[f"...{$DATA}..."]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = globals()["...".format(..., $DATA, ...)]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals().get($DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals().get("..." % $DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals().get(f"...{$DATA}...", ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals().get("...".format(..., $DATA, ...), ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals()[$DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals()["..." % $DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals()[f"...{$DATA}..."]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = globals()["...".format(..., $DATA, ...)]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals().get($DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals().get("..." % $DATA, ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals().get(f"...{$DATA}...", ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals().get("...".format(..., $DATA, ...), ...)
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals()[$DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals()["..." % $DATA]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals()[f"...{$DATA}..."]
              ...
              $INTERM(...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = globals()["...".format(..., $DATA, ...)]
              ...
              $INTERM(...)
  - id: python.django.security.injection.code.user-eval.user-eval
    message: |
      Found user data in a call to 'eval'. This is extremely dangerous because
      it can enable an attacker to execute remote code. See
      https://owasp.org/www-community/attacks/Code_Injection for more information
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
      references:
        - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
    patterns:
      - pattern-inside: |
          def $F(...):
            ...
      - pattern-either:
          - pattern: eval(..., request.$W.get(...), ...)
          - pattern: |
              $V = request.$W.get(...)
              ...
              eval(..., $V, ...)
          - pattern: eval(..., request.$W(...), ...)
          - pattern: |
              $V = request.$W(...)
              ...
              eval(..., $V, ...)
          - pattern: eval(..., request.$W[...], ...)
          - pattern: |
              $V = request.$W[...]
              ...
              eval(..., $V, ...)
    languages:
      - python
    severity: WARNING
  - id: python.django.security.injection.code.user-exec.user-exec
    message: |
      Found user data in a call to 'exec'. This is extremely dangerous because
      it can enable an attacker to execute remote code. See
      https://owasp.org/www-community/attacks/Code_Injection for more information.
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
    patterns:
      - pattern-inside: |
          def $F(...):
            ...
      - pattern-either:
          - pattern: exec(..., request.$W.get(...), ...)
          - pattern: |
              $V = request.$W.get(...)
              ...
              exec(..., $V, ...)
          - pattern: exec(..., request.$W(...), ...)
          - pattern: |
              $V = request.$W(...)
              ...
              exec(..., $V, ...)
          - pattern: exec(..., request.$W[...], ...)
          - pattern: |
              $V = request.$W[...]
              ...
              exec(..., $V, ...)
    languages:
      - python
    severity: WARNING
  - id: python.django.security.injection.mass-assignment.mass-assignment
    languages:
      - python
    severity: WARNING
    message: |
      Mass assignment detected. This can result in assignment to
      model fields that are unintended and can be exploited by
      an attacker. Instead of using '**request.$W', assign each field you
      want to edit individually to prevent mass assignment. You can read
      more about mass assignment at
      https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html.
    metadata:
      cwe:
        "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
        Attributes"
      owasp: "A1: Injection"
      owaspapi: "API6: Mass Assignment"
      references:
        - https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html
    patterns:
      - pattern-either:
          - pattern: $MODEL.objects.create(**request.$W)
          - pattern: |
              $OBJ.update(**request.$W)
              ...
              $OBJ.save()
  - id: python.django.security.injection.email.xss-html-email-body.xss-html-email-body
    message: |
      Found request data in an EmailMessage that is set to use HTML.
      This is dangerous because HTML emails are susceptible to XSS.
      An attacker could inject data into this HTML email, causing XSS.
    metadata:
      cwe:
        "CWE-74: Improper Neutralization of Special Elements in Output Used by a
        Downstream Component ('Injection')"
      owasp: "A1: Injection"
      references:
        - https://www.damonkohler.com/2008/12/email-injection.html
    languages:
      - python
    severity: WARNING
    patterns:
      - pattern-inside: |
          def $FUNC(...):
            ...
            $EMAIL.content_subtype = "html"
            ...
      - pattern-either:
          - pattern: django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $B.$C(..., $DATA, ...)
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
          - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
          - pattern: django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $B.$C(..., $DATA, ...)
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
          - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
          - pattern: django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.EmailMessage($SUBJ, $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $B.$C(..., $DATA, ...)
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
          - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
          - pattern: django.core.mail.EmailMessage($SUBJ, request.$W, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.EmailMessage($SUBJ, $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $B.$C(..., $DATA, ...)
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
          - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W, ...)
          - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W, ...)
  - id: python.django.security.injection.email.xss-send-mail-html-message.xss-send-mail-html-message
    message: |
      Found request data in 'send_mail(...)' that uses 'html_message'.
      This is dangerous because HTML emails are susceptible to XSS.
      An attacker could inject data into this HTML email, causing XSS.
    metadata:
      cwe:
        "CWE-74: Improper Neutralization of Special Elements in Output Used by a
        Downstream Component ('Injection')"
      owasp: "A1: Injection"
      references:
        - https://www.damonkohler.com/2008/12/email-injection.html
    languages:
      - python
    severity: WARNING
    patterns:
      - pattern-inside: |
          def $FUNC(...):
            ...
      - pattern-either:
          - pattern: django.core.mail.send_mail(..., html_message=request.$W.get(...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=$DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR + $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern:
              $A = django.core.mail.send_mail(..., html_message=request.$W.get(...),
              ...)
          - pattern:
              return django.core.mail.send_mail(..., html_message=request.$W.get(...),
              ...)
          - pattern: django.core.mail.send_mail(..., html_message=request.$W(...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=$DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR + $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern:
              $A = django.core.mail.send_mail(..., html_message=request.$W(...),
              ...)
          - pattern:
              return django.core.mail.send_mail(..., html_message=request.$W(...),
              ...)
          - pattern: django.core.mail.send_mail(..., html_message=request.$W[...], ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=$DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR + $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern:
              $A = django.core.mail.send_mail(..., html_message=request.$W[...],
              ...)
          - pattern:
              return django.core.mail.send_mail(..., html_message=request.$W[...],
              ...)
          - pattern: django.core.mail.send_mail(..., html_message=request.$W, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=$DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR % $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = f"...{$DATA}..."
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR + $DATA
              ...
              django.core.mail.send_mail(..., html_message=$INTERM, ...)
          - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W, ...)
          - pattern: return django.core.mail.send_mail(..., html_message=request.$W, ...)
  - id: python.django.security.injection.command.command-injection-os-system.command-injection-os-system
    message:
      Request data detected in os.system. This could be vulnerable to a command
      injection and should be avoided. If this must be done, use the 'subprocess' module
      instead and pass the arguments as a list. See https://owasp.org/www-community/attacks/Command_Injection
      for more information.
    metadata:
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
      references:
        - https://owasp.org/www-community/attacks/Command_Injection
    languages:
      - python
    severity: WARNING
    patterns:
      - pattern-inside: |
          def $FUNC(...):
            ...
      - pattern-either:
          - pattern: os.system(..., request.$W.get(...), ...)
          - pattern: os.system(..., $S.format(..., request.$W.get(...), ...), ...)
          - pattern: os.system(..., $S % request.$W.get(...), ...)
          - pattern: os.system(..., f"...{request.$W.get(...)}...", ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., $STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR % $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              os.system(..., $STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W.get(...)
              ...
              $INTERM = $STR + $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: $A = os.system(..., request.$W.get(...), ...)
          - pattern: $A = os.system(..., $S.format(..., request.$W.get(...), ...), ...)
          - pattern: $A = os.system(..., $S % request.$W.get(...), ...)
          - pattern: $A = os.system(..., f"...{request.$W.get(...)}...", ...)
          - pattern: return os.system(..., request.$W.get(...), ...)
          - pattern: return os.system(..., $S.format(..., request.$W.get(...), ...), ...)
          - pattern: return os.system(..., $S % request.$W.get(...), ...)
          - pattern: return os.system(..., f"...{request.$W.get(...)}...", ...)
          - pattern: os.system(..., request.$W(...), ...)
          - pattern: os.system(..., $S.format(..., request.$W(...), ...), ...)
          - pattern: os.system(..., $S % request.$W(...), ...)
          - pattern: os.system(..., f"...{request.$W(...)}...", ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., $STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR % $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = f"...{$DATA}..."
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              os.system(..., $STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W(...)
              ...
              $INTERM = $STR + $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: $A = os.system(..., request.$W(...), ...)
          - pattern: $A = os.system(..., $S.format(..., request.$W(...), ...), ...)
          - pattern: $A = os.system(..., $S % request.$W(...), ...)
          - pattern: $A = os.system(..., f"...{request.$W(...)}...", ...)
          - pattern: return os.system(..., request.$W(...), ...)
          - pattern: return os.system(..., $S.format(..., request.$W(...), ...), ...)
          - pattern: return os.system(..., $S % request.$W(...), ...)
          - pattern: return os.system(..., f"...{request.$W(...)}...", ...)
          - pattern: os.system(..., request.$W[...], ...)
          - pattern: os.system(..., $S.format(..., request.$W[...], ...), ...)
          - pattern: os.system(..., $S % request.$W[...], ...)
          - pattern: os.system(..., f"...{request.$W[...]}...", ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., $STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR % $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = f"...{$DATA}..."
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              os.system(..., $STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W[...]
              ...
              $INTERM = $STR + $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: $A = os.system(..., request.$W[...], ...)
          - pattern: $A = os.system(..., $S.format(..., request.$W[...], ...), ...)
          - pattern: $A = os.system(..., $S % request.$W[...], ...)
          - pattern: $A = os.system(..., f"...{request.$W[...]}...", ...)
          - pattern: return os.system(..., request.$W[...], ...)
          - pattern: return os.system(..., $S.format(..., request.$W[...], ...), ...)
          - pattern: return os.system(..., $S % request.$W[...], ...)
          - pattern: return os.system(..., f"...{request.$W[...]}...", ...)
          - pattern: os.system(..., request.$W, ...)
          - pattern: os.system(..., $S.format(..., request.$W, ...), ...)
          - pattern: os.system(..., $S % request.$W, ...)
          - pattern: os.system(..., f"...{request.$W}...", ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., $STR.format(..., $DATA, ...), ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR.format(..., $DATA, ...)
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., $STR % $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR % $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., f"...{$DATA}...", ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = f"...{$DATA}..."
              ...
              os.system(..., $INTERM, ...)
          - pattern: |
              $DATA = request.$W
              ...
              os.system(..., $STR + $DATA, ...)
          - pattern: |
              $DATA = request.$W
              ...
              $INTERM = $STR + $DATA
              ...
              os.system(..., $INTERM, ...)
          - pattern: $A = os.system(..., request.$W, ...)
          - pattern: $A = os.system(..., $S.format(..., request.$W, ...), ...)
          - pattern: $A = os.system(..., $S % request.$W, ...)
          - pattern: $A = os.system(..., f"...{request.$W}...", ...)
          - pattern: return os.system(..., request.$W, ...)
          - pattern: return os.system(..., $S.format(..., request.$W, ...), ...)
          - pattern: return os.system(..., $S % request.$W, ...)
          - pattern: return os.system(..., f"...{request.$W}...", ...)
  - id: python.django.security.injection.path-traversal.path-traversal-file-name.path-traversal-file-name
    message: |
      Data from request is passed to a file name `$FILE`.
      This is a path traversal vulnerability: https://owasp.org/www-community/attacks/Path_Traversal
      To mitigate, consider using os.path.abspath or os.path.realpath or Path library.
    metadata:
      cwe:
        "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path
        Traversal')"
      owasp: "A1: Injection"
      references:
        - https://owasp.org/www-community/attacks/Path_Traversal
    patterns:
      - pattern-inside: |
          def $F(...):
            ...
      - pattern-not: |
          ...
          os.path.realpath(...)
          ...
      - pattern-not: |
          ...
          os.path.abspath(...)
          ...
      - pattern-either:
          - pattern: |
              $V = request.$W.get($X)
              ...
              $FILE % ($V)
          - pattern: |
              $V = request.$W[$X]
              ...
              $FILE % ($V)
          - pattern: |
              $V = request.$W($X)
              ...
              $FILE % ($V)
          - pattern: |
              $V = request.$W
              ...
              $FILE % ($V)
              # match format use cases
          - pattern: |
              $V = request.$W.get($X)
              ...
              $FILE.format(..., $V, ...)
          - pattern: |
              $V = request.$W[$X]
              ...
              $FILE.format(..., $V, ...)
          - pattern: |
              $V = request.$W($X)
              ...
              $FILE.format(..., $V, ...)
          - pattern: |
              $V = request.$W
              ...
              $FILE.format(..., $V, ...)
      - metavariable-regex:
          metavariable: $FILE
          regex: .*\.(log|zip|txt|csv|xml|html).*
    languages:
      - python
    severity: WARNING
  - id: python.django.security.passwords.use-none-for-password-default.use-none-for-password-default
    message: |
      '$VAR' is using the empty string as its default and is being used to set
      the password on '$MODEL'. If you meant to set an unusable password, set
      the default value to 'None' or call 'set_unusable_password()'.
    metadata:
      cwe: "CWE-521: Weak Password Requirements"
      owasp: "A2: Broken Authentication"
      references:
        - https://docs.djangoproject.com/en/3.0/ref/contrib/auth/#django.contrib.auth.models.User.set_password
    patterns:
      - pattern-either:
          - pattern: |
              $VAR = request.$W.get($X, "")
              ...
              $MODEL.set_password($VAR)
              ...
              $MODEL.save(...)
          - pattern: |
              def $F(..., $VAR="", ...):
                ...
                $MODEL.set_password($VAR)
    fix-regex:
      regex: (def.*|request.*)(""|'')
      replacement: \1None
    languages:
      - python
    severity: ERROR
  - id: python.django.security.audit.xss.context-autoescape-off.context-autoescape-off
    message: |
      Detected a Context with autoescape diabled. If you are
      rendering any web pages, this exposes your application to cross-site
      scripting (XSS) vulnerabilities. Remove 'autoescape: False' or set it
      to 'True'.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://docs.djangoproject.com/en/3.1/ref/settings/#templates
        - https://docs.djangoproject.com/en/3.1/topics/templates/#django.template.backends.django.DjangoTemplates
    languages:
      - python
    severity: WARNING
    patterns:
      - pattern-either:
          - pattern: '{..., "autoescape": False, ...}'
          - pattern: $D["autoescape"] = False
    fix-regex:
      regex: (autoescape.*?)False
      replacement: \1True
  - id: python.django.security.audit.xss.global-autoescape-off.global-autoescape-off
    message: |
      Autoescape is globally disbaled for this Django application. If you are
      rendering any web pages, this exposes your application to cross-site
      scripting (XSS) vulnerabilities. Remove 'autoescape: False' or set it
      to 'True'.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://docs.djangoproject.com/en/3.1/ref/settings/#templates
        - https://docs.djangoproject.com/en/3.1/topics/templates/#django.template.backends.django.DjangoTemplates
    languages:
      - python
    severity: WARNING
    pattern: |
      {..., 'BACKEND': ..., 'OPTIONS': {..., 'autoescape': False, ...}, ...}
    fix-regex:
      regex: (autoescape.*?)False
      replacement: \1True
  - id: python.django.security.audit.xss.template-autoescape-off.template-autoescape-off
    message: |
      Detected a template block where autoescaping is explicitly
      disabled with '{% autoescape off %}'. This allows rendering of raw HTML
      in this segment. Turn autoescaping on to prevent cross-site scripting (XSS).
      If you must do this, consider instead, using `mark_safe` in Python code.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#autoescape
    languages:
      - none
    paths:
      include:
        - "*.html"
    severity: WARNING
    pattern-regex: '{%\s+autoescape\s+off\s+%}'
  - id: python.django.security.audit.xss.template-blocktranslate-no-escape.template-blocktranslate-no-escape
    languages:
      - generic
    severity: INFO
    message: |
      Translated strings will not be escaped when rendered in a template.
      This leads to a vulnerability where translators could include malicious script tags in their translations.
      Consider using `force_escape` to explicitly escape a translated text.
    patterns:
      - pattern-either:
          - pattern: |
              {% blocktranslate...%}
          - pattern: |
              {% blocktrans...%}
      - pattern-not-inside: |
          {%...filter...force_escape...%}
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          {%...endfilter...%}
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates
        - https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code
  - id: python.django.security.audit.xss.template-translate-as-no-escape.template-translate-as-no-escape
    languages:
      - generic
    severity: INFO
    message: |
      Translated strings will not be escaped when rendered in a template.
      This leads to a vulnerability where translators could include malicious script tags in their translations.
      Consider using `force_escape` to explicitly escape a transalted text.
    patterns:
      - pattern-either:
          - pattern: |
              {% translate ... as $TRANS ... %}
              ...
              ...
              ...
              ...
              ...
              ...
              ...
              ...
              ...
              ...
              {{ ... $TRANS ... }}
          - pattern: |
              {% trans ... as $TRANS ... %}
              ...
              ...
              ...
              ...
              ...
              ...
              ...
              ...
              ...
              ...
              {{ ... $TRANS ... }}
      - pattern-not: |
          {% translate ... as $TRANS ... %}
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          {{ ... $TRANS ... | ... force_escape ... }}
      - pattern-not: |
          {% trans ... as $TRANS ... %}
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          {{ ... $TRANS ... | ... force_escape ... }}
      - pattern-not: |
          {% translate ... as $TRANS ... %}
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          {% filter force_escape %}
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          {{ ... $TRANS ... }}
      - pattern-not: |
          {% trans ... as $TRANS ... %}
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          {% filter force_escape %}
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          {{ ... $TRANS ... }}
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates
        - https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code
  - id: python.django.security.audit.xss.template-translate-no-escape.template-translate-no-escape
    languages:
      - generic
    severity: INFO
    message: |
      Translated strings will not be escaped when rendered in a template.
      This leads to a vulnerability where translators could include malicious script tags in their translations.
      Consider using `force_escape` to explicitly escape a transalted text.
    patterns:
      - pattern-either:
          - pattern: |
              {% translate...%}
          - pattern: |
              {% trans...%}
      - pattern-not: |
          {% translate...as...%}
      - pattern-not: |
          {% trans...as...%}
      - pattern-not-inside: |
          {%...filter...force_escape...%}
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          ...
          {%...endfilter...%}
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates
        - https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code
  - id: python.django.security.audit.xss.template-var-unescaped-with-safeseq.template-var-unescaped-with-safeseq
    message: |
      Detected a template variable where autoescaping is explicitly
      disabled with '| safeseq' filter. This allows rendering of raw HTML
      in this segment. Ensure no user data is rendered here, otherwise this
      is a cross-site scripting (XSS) vulnerability. If you must do this,
      use `mark_safe` in your Python code.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://docs.djangoproject.com/en/3.0/ref/templates/builtins/#safeseq
    languages:
      - none
    paths:
      include:
        - "*.html"
    severity: WARNING
    pattern-regex: '{{.*?\|\s+safeseq(\s+}})?'
  - id: python.flask.security.audit.app-run-param-config.avoid_app_run_with_bad_host
    patterns:
      - pattern-either:
          - pattern: app.run(..., host="0.0.0.0", ...)
          - pattern: app.run(..., "0.0.0.0", ...)
    message: Running flask app with host 0.0.0.0 could expose the server publicly.
    metadata:
      cwe: "CWE-668: Exposure of Resource to Wrong Sphere"
      owasp: "A6: Security Misconfiguration"
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.audit.app-run-security-config.avoid_using_app_run_directly
    patterns:
      - pattern-not-inside: |
          if __name__ == '__main__':
            ...
      - pattern-not-inside: |
          def $X(...):
            ...
      - pattern: app.run(...)
    message:
      top-level app.run(...) is ignored by flask. Consider putting app.run(...)
      behind a guard, like inside a function
    metadata:
      cwe: "CWE-668: Exposure of Resource to Wrong Sphere"
      owasp: "A6: Security Misconfiguration"
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.audit.debug-enabled.debug-enabled
    patterns:
      - pattern-inside: |
          import flask
          ...
      - pattern: $APP.run(..., debug=True, ...)
    message: |
      Detected Flask app with debug=True. Do not deploy to production with this flag enabled
      as it will leak sensitive information. Instead, consider using Flask configuration
      variables or setting 'debug' using system environment variables.
    metadata:
      cwe: "CWE-489: Active Debug Code"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://labs.detectify.com/2015/10/02/how-patreon-got-hacked-publicly-exposed-werkzeug-debugger/
    severity: WARNING
    languages:
      - python
  - id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_DEBUG
    pattern-either:
      - pattern: $M.update(DEBUG=True)
      - pattern: $M.update(DEBUG=False)
      - pattern: $M.config['DEBUG'] = True
      - pattern: $M.config['DEBUG'] = False
    message:
      Hardcoded variable `DEBUG` detected. Set this by using FLASK_DEBUG environment
      variable
    metadata:
      cwe: "CWE-489: Active Debug Code"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://bento.dev/checks/flask/avoid-hardcoded-config/
        - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
        - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_ENV
    pattern-either:
      - pattern: $M.update(ENV="=~/^development|production$/")
      - pattern: $M.config['ENV'] = "=~/^development|production$/"
    message:
      Hardcoded variable `ENV` detected. Set this by using FLASK_ENV environment
      variable
    metadata:
      cwe: "CWE-489: Active Debug Code"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://bento.dev/checks/flask/avoid-hardcoded-config/
        - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
        - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_SECRET_KEY
    pattern-either:
      - pattern: $M.update(SECRET_KEY="=~/.*/")
      - pattern: $M.config['SECRET_KEY'] = "=~/.*/"
    message:
      Hardcoded variable `SECRET_KEY` detected. Use environment variables or
      config files instead
    metadata:
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A2: Broken Authentication"
      references:
        - https://bento.dev/checks/flask/avoid-hardcoded-config/
        - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
        - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
    languages:
      - python
    severity: ERROR
  - id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_TESTING
    pattern-either:
      - pattern: $M.config['TESTING'] = True
      - pattern: $M.config['TESTING'] = False
      - pattern: $M.update(TESTING=True, ...)
      - pattern: $M.update(TESTING=False, ...)
    message:
      Hardcoded variable `TESTING` detected. Use environment variables or config
      files instead
    metadata:
      cwe: "CWE-489: Active Debug Code"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://bento.dev/checks/flask/avoid-hardcoded-config/
        - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
        - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.audit.render-template-string.render-template-string
    pattern: flask.render_template_string(...)
    metadata:
      cwe:
        "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static
        Code Injection')"
      owasp: "A1: Injection"
      references:
        - https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html
    message:
      Found a template created with string formatting. This is susceptible to
      server-side template injection and cross-site scripting attacks.
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.audit.secure-set-cookie.secure-set-cookie
    patterns:
      - pattern-either:
          - pattern-inside: |
              $RESP = flask.make_response(...)
              ...
          - pattern-inside: |
              $RESP = flask.Response(...)
              ...
      - pattern-not: $RESPONSE.set_cookie(..., secure=$A, httponly=$B, samesite=$C, ...)
      - pattern-not: $RESPONSE.set_cookie(..., **$A)
      - pattern: $RESPONSE.set_cookie(...)
    message: |
      Flask cookies should be handled securely by setting secure=True, httponly=True, and samesite='Lax' in
      response.set_cookie(...). If your situation calls for different settings, explicitly disable the setting.
      If you want to send the cookie over http, set secure=False.  If you want to let client-side JavaScript
      read the cookie, set httponly=False. If you want to attach cookies to requests for external sites,
      set samesite=None.
    metadata:
      cwe: "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://blog.r2c.dev/2020/bento-check-keeping-cookies-safe-in-flask/
        - https://bento.dev/checks/flask/secure-set-cookie/
        - https://flask.palletsprojects.com/en/1.1.x/security/#set-cookie-options
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.audit.wtf-csrf-disabled.flask-wtf-csrf-disabled
    patterns:
      - pattern: |
          $APP.config['WTF_CSRF_ENABLED'] = False
    message: |
      `$APP.config['WTF_CSRF_ENABLED'] = False` is probably not what you want in production because it disables https://flask-wtf.readthedocs.io/en/stable/csrf.html CSRF protection
    metadata:
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://flask-wtf.readthedocs.io/en/stable/csrf.html
    severity: WARNING
    languages:
      - python
  - id: python.flask.security.dangerous-template-string.dangerous-template-string
    patterns:
      - pattern-either:
          - pattern: |
              $V = "...".format(...)
              ...
              flask.render_template_string($V, ...)
          - pattern: |
              $V = "...".format(...)
              ...
              return flask.render_template_string($V, ...), $MORE
          - pattern: |
              $V = "..." % $S
              ...
              flask.render_template_string($V, ...)
          - pattern: |
              $V = "..." % $S
              ...
              return flask.render_template_string($V, ...), $MORE
          - pattern: |
              $V = "..."
              ...
              $V += $O
              ...
              flask.render_template_string($V, ...)
          - pattern: |
              $V = "..."
              ...
              $V += $O
              ...
              return flask.render_template_string($V, ...), $MORE
          - pattern: |
              $V = f"...{$X}..."
              ...
              flask.render_template_string($V, ...)
          - pattern: |
              $V = f"...{$X}..."
              ...
              return flask.render_template_string($V, ...), $CODE
    message: |
      Found a template created with string formatting.
      This is susceptible to server-side template injection
      and cross-site scripting attacks.
    metadata:
      cwe:
        "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static
        Code Injection')"
      owasp: "A1: Injection"
      references:
        - https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html
        - https://pequalsnp-team.github.io/cheatsheet/flask-jinja2-ssti
    languages:
      - python
    severity: ERROR
  - id: python.flask.security.injection.user-eval.eval-injection
    languages:
      - python
    severity: ERROR
    message:
      Detected user data flowing into eval. This is code injection and should
      be avoided.
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
      references:
        - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  @$APP.route($ROUTE, ...)
                  def $FUNC(..., $ROUTEVAR, ...):
                    ...
              - pattern-either:
                  - pattern: eval(..., <... $ROUTEVAR ...>, ...)
                  - pattern: |
                      $INTERM = <... $ROUTEVAR ...>
                      ...
                      eval(..., <... $INTERM ...>, ...)
          - patterns:
              - pattern-either:
                  - pattern: eval(..., <... flask.request.$W.get(...) ...>, ...)
                  - pattern: eval(..., <... flask.request.$W[...] ...>, ...)
                  - pattern: eval(..., <... flask.request.$W(...) ...>, ...)
                  - pattern: eval(..., <... flask.request.$W ...>, ...)
          - patterns:
              - pattern-either:
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W.get(...) ...>
                          ...
                          eval(..., <... $INTERM ...>, ...)
                      - pattern: eval(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W[...] ...>
                          ...
                          eval(..., <... $INTERM ...>, ...)
                      - pattern: eval(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W(...) ...>
                          ...
                          eval(..., <... $INTERM ...>, ...)
                      - pattern: eval(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W ...>
                          ...
                          eval(..., <... $INTERM ...>, ...)
                      - pattern: eval(...)
  - id: python.flask.security.injection.user-exec.exec-injection
    languages:
      - python
    severity: ERROR
    message:
      Detected user data flowing into exec. This is code injection and should
      be avoided.
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
      references:
        - https://nedbatchelder.com/blog/201206/exec_really_is_dangerous.html
    patterns:
      - pattern-either:
          - patterns:
              - pattern-inside: |
                  @$APP.route($ROUTE, ...)
                  def $FUNC(..., $ROUTEVAR, ...):
                    ...
              - pattern-either:
                  - pattern: exec(..., <... $ROUTEVAR ...>, ...)
                  - pattern: |
                      $INTERM = <... $ROUTEVAR ...>
                      ...
                      exec(..., <... $INTERM ...>, ...)
          - patterns:
              - pattern-either:
                  - pattern: exec(..., <... flask.request.$W.get(...) ...>, ...)
                  - pattern: exec(..., <... flask.request.$W[...] ...>, ...)
                  - pattern: exec(..., <... flask.request.$W(...) ...>, ...)
                  - pattern: exec(..., <... flask.request.$W ...>, ...)
          - patterns:
              - pattern-either:
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W.get(...) ...>
                          ...
                          exec(..., <... $INTERM ...>, ...)
                      - pattern: exec(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W[...] ...>
                          ...
                          exec(..., <... $INTERM ...>, ...)
                      - pattern: exec(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W(...) ...>
                          ...
                          exec(..., <... $INTERM ...>, ...)
                      - pattern: exec(...)
                  - patterns:
                      - pattern-inside: |
                          $INTERM = <... flask.request.$W ...>
                          ...
                          exec(..., <... $INTERM ...>, ...)
                      - pattern: exec(...)
  - id: python.flask.security.insecure-deserialization.insecure-deserialization
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
      references:
        - https://docs.python.org/3/library/pickle.html
    message: |
      Detected the use of an insecure deserizliation library in a Flask route. These libraries
      are prone to code execution vulnerabilities. Ensure user data does not enter this function.
      To fix this, try to avoid serializing whole objects. Consider instead using a serializer
      such as JSON.
    languages:
      - python
    severity: ERROR
    patterns:
      - pattern-inside: |
          @app.route(...)
          def $X(...):
            ...
      - pattern-not: $MODULE.$FUNC("...")
      - pattern-not: $MODULE.$FUNC(open("...", ...))
      - pattern-either:
          - pattern: pickle.$FUNC(...)
          - pattern: _pickle.$FUNC(...)
          - pattern: cPickle.$FUNC(...)
          - pattern: dill.$FUNC(...)
          - pattern: shelve.$FUNC(...)
          - pattern: yaml.load(...)
  - id: python.flask.security.open-redirect.open-redirect
    patterns:
      - pattern-inside: |
          @$APP.route(...)
          def $X():
            ...
      - pattern-not-inside: |
          ...
          if <... werkzeug.urls.url_parse($V) ...>:
            ...
      - pattern-either:
          - pattern: flask.redirect(<... flask.request.$W.get(...) ...>, ...)
          - pattern: flask.redirect(<... flask.request.$W[...] ...>, ...)
          - pattern: flask.redirect(<... flask.request.$W(...) ...>, ...)
          - pattern: flask.redirect(<... flask.request.$W ...>, ...)
          - pattern: |
              $V = flask.request.$W.get(...)
              ...
              flask.redirect(<... $V ...>, ...)
          - pattern: |
              $V = flask.request.$W[...]
              ...
              flask.redirect(<... $V ...>, ...)
          - pattern: |
              $V = flask.request.$W(...)
              ...
              flask.redirect(<... $V ...>, ...)
          - pattern: |
              $V = flask.request.$W
              ...
              flask.redirect(<... $V ...>, ...)
    message: |
      Data from request is passed to redirect().
      This is an open redirect and could be exploited.
      Consider using 'url_for()' to generate links to known locations.
      If you must use a URL to unknown pages, consider using 'urlparse()'
      or similar and checking if the 'netloc' property is the same as
      your site's host name. See the references for more information.
    metadata:
      cwe: "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
      owasp: "A1: Injection"
      references:
        - https://flask-login.readthedocs.io/en/latest/#login-example
        - https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html#dangerous-url-redirect-example-1
        - https://docs.python.org/3/library/urllib.parse.html#url-parsing
    languages:
      - python
    severity: ERROR
  - id: python.flask.security.secure-static-file-serve.avoid_send_file_without_path_sanitization
    patterns:
      - pattern-inside: |
          @app.route(...)
          def $X(filename):
            ...
      - pattern-either:
          - pattern: flask.send_file(filename, ...)
    message:
      Looks like `filename` could flow to `flask.send_file()` function. Make
      sure to properly sanitize filename or use `flask.send_from_directory`
    metadata:
      cwe: "CWE-73: External Control of File Name or Path"
      owasp: "A1: Injection"
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.unescaped-template-extension.unescaped-template-extension
    message: |
      Flask does not automatically escape Jinja templates unless they have
      .html, .htm, .xml, or .xhtml extensions. This could lead to XSS attacks.
      Use .html, .htm, .xml, or .xhtml for your template extensions.
      See https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup
      for more information.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-Site Scripting (XSS)"
      source-rule-url: https://pypi.org/project/flake8-flask/
      references:
        - https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup
        - https://blog.r2c.dev/2020/bento-check-unescaped-template-extensions-in-flask/
        - https://bento.dev/checks/flask/unescaped-file-extension/
    patterns:
      - pattern-not: flask.render_template("=~/.+\.html$/", ...)
      - pattern-not: flask.render_template("=~/.+\.xml$/", ...)
      - pattern-not: flask.render_template("=~/.+\.htm$/", ...)
      - pattern-not: flask.render_template("=~/.+\.xhtml$/", ...)
      - pattern-not: flask.render_template($X + "=~/\.html$/", ...)
      - pattern-not: flask.render_template($X + "=~/\.xml$/", ...)
      - pattern-not: flask.render_template($X + "=~/\.htm$/", ...)
      - pattern-not: flask.render_template($X + "=~/\.xhtml$/", ...)
      - pattern-not: flask.render_template("=~/.+\.html$/" % $X, ...)
      - pattern-not: flask.render_template("=~/.+\.xml$/" % $X, ...)
      - pattern-not: flask.render_template("=~/.+\.htm$/" % $X, ...)
      - pattern-not: flask.render_template("=~/.+\.xhtml$/" % $X, ...)
      - pattern-not: flask.render_template("=~/.+\.html$/".format(...), ...)
      - pattern-not: flask.render_template("=~/.+\.xml$/".format(...), ...)
      - pattern-not: flask.render_template("=~/.+\.htm$/".format(...), ...)
      - pattern-not: flask.render_template("=~/.+\.xhtml$/".format(...), ...)
      - pattern-not: flask.render_template($TEMPLATE)
      - pattern-either:
          - pattern: flask.render_template("...", ...)
          - pattern: flask.render_template($X + "...", ...)
          - pattern: flask.render_template("..." % $Y, ...)
          - pattern: flask.render_template("...".format(...), ...)
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.unsanitized-input.response-contains-unsanitized-input
    patterns:
      - pattern-either:
          - pattern: |
              $X = flask.request.args.get(...)
              ...
              flask.make_response("...".format($X))
          - pattern: |
              $X = flask.request.args.get(...)
              ...
              flask.make_response(f"...{$X}...")
          - pattern: |
              $X = flask.request.args.get(...)
              ...
              flask.make_response(f"...{$X}")
          - pattern: |
              $X = flask.request.args.get(...)
              ...
              flask.make_response(f"{$X}...")
    message: |
      Flask response reflects unsanitized user input. This could lead to a
      cross-site scripting vulnerability (https://owasp.org/www-community/attacks/xss/)
      in which an attacker causes arbitrary code to be executed in the user's browser.
      To prevent, please sanitize the user input, e.g. by rendering the response
      in a Jinja2 template (see considerations in https://flask.palletsprojects.com/en/1.0.x/security/).
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-Site Scripting (XSS)"
      references:
        - https://flask.palletsprojects.com/en/1.0.x/security/
        - https://owasp.org/www-community/attacks/xss/
    languages:
      - python
    severity: WARNING
  - id: python.flask.security.xss.audit.template-autoescape-off.template-autoescape-off
    message:
      Detected a segment of a Flask template where autoescaping is explicitly
      disabled with '{% autoescape off %}'. This allows rendering of raw HTML in this
      segment. Ensure no user data is rendered here, otherwise this is a cross-site
      scripting (XSS) vulnerability, or turn autoescape on.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://flask.palletsprojects.com/en/1.1.x/templating/#controlling-autoescaping
        - https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup
    languages:
      - none
    paths:
      include:
        - "*.html"
    severity: WARNING
    pattern-regex: '{%\s*autoescape\s+false\s*%}'
  - id: python.flask.security.xss.audit.template-unescaped-with-safe.template-unescaped-with-safe
    message:
      Detected a segment of a Flask template where autoescaping is explicitly
      disabled with '| safe' filter. This allows rendering of raw HTML in this segment.
      Ensure no user data is rendered here, otherwise this is a cross-site scripting
      (XSS) vulnerability.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss
    languages:
      - none
    paths:
      include:
        - "*.html"
    severity: WARNING
    pattern-regex: '{{.*?\|\s*safe(\s*}})?'
  - id: python.jinja2.security.audit.autoescape-disabled.autoescape-disabled
    patterns:
      - pattern-not: jinja2.Environment(..., autoescape=True, ...)
      - pattern-not:
          jinja2.Environment(..., autoescape=jinja2.select_autoescape(...),
          ...)
      - pattern: jinja2.Environment(...)
    fix-regex:
      regex: (.*)\)
      replacement: \1, autoescape=True)
    message:
      Detected a Jinja2 environment without autoescaping. Jinja2 does not autoescape
      by default. This is dangerous if you are rendering to a browser because this allows
      for cross-site scripting (XSS) attacks. If you are in a web context, enable autoescaping
      by setting 'autoescape=True.' You may also consider using 'jinja2.select_autoescape()'
      to only enable automatic escaping for certain file extensions.
    metadata:
      cwe: "CWE-116: Improper Encoding or Escaping of Output"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://jinja.palletsprojects.com/en/2.11.x/api/#basics
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.conn_recv.multiprocessing-recv
    languages:
      - python
    message:
      "The Connection.recv() method automatically unpickles the data it receives,
      which can be a security risk unless you can trust the process which sent the message.
      Therefore, unless the connection object was produced using Pipe() you should only
      use the recv() and send() methods after performing some sort of authentication.
      See more dettails: https://docs.python.org/3/library/multiprocessing.html?highlight=security#multiprocessing.connection.Connection"
    metadata:
      cwe: "CWE-502: Deserialization of Untrusted Data"
      owasp: "A8: Insecure Deserialization"
      references:
        - https://docs.python.org/3/library/multiprocessing.html?highlight=security#multiprocessing.connection.Connection
    pattern-either:
      - pattern: multiprocessing.connection.Connection.recv(...)
      - pattern: multiprocessing.connection.Client.recv(...)
      - pattern: |
          $C = multiprocessing.connection.Client(...)
          ...
          $C.recv(...)
    severity: WARNING
  - id: python.lang.security.audit.dangerous-spawn-process.dangerous-spawn-process
    patterns:
      - pattern-either:
          - patterns:
              - pattern-not: os.$W("...", ...)
              - pattern-either:
                  - pattern: os.execl(...)
                  - pattern: os.execle(...)
                  - pattern: os.execlp(...)
                  - pattern: os.execlpe(...)
                  - pattern: os.execv(...)
                  - pattern: os.execve(...)
                  - pattern: os.execvp(...)
                  - pattern: os.execvpe(...)
                  - pattern: os.startfile(...)
          - patterns:
              - pattern-not: os.$W($MODE, "...", ...)
              - pattern-either:
                  - pattern: os.spawnl(...)
                  - pattern: os.spawnle(...)
                  - pattern: os.spawnlp(...)
                  - pattern: os.spawnlpe(...)
                  - pattern: os.spawnv(...)
                  - pattern: os.spawnve(...)
                  - pattern: os.spawnvp(...)
                  - pattern: os.spawnvpe(...)
    message: |
      Found dynamic content when spawning a process. This is dangerous if external
      data can reach this function call because it allows a malicious actor to
      execute commands. Ensure no external data reaches here.
    metadata:
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.dangerous-system-call.dangerous-system-call
    patterns:
      - pattern-not: os.$W("...", ...)
      - pattern-either:
          - pattern: os.system(...)
          - pattern: os.popen(...)
          - pattern: os.popen2(...)
          - pattern: os.popen3(...)
          - pattern: os.popen4(...)
    message:
      Found dynamic content used in a system call. This is dangerous if external
      data can reach this function call because it allows a malicious actor to execute
      commands. Use the 'subprocess' module instead, which is easier to use without
      accidentally exposing a command injection vulnerability.
    metadata:
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      owasp: "A1: Injection"
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected
    patterns:
      - pattern-not: urllib.$W("...")
      - pattern-not: urllib.request.$W("...")
      - pattern-not: $OPENER.$W("...")
      - pattern-either:
          - patterns:
              - pattern-either:
                  - pattern: urllib.urlopen(...)
                  - pattern: urllib.request.urlopen(...)
                  - pattern: urllib.urlretrieve(...)
                  - pattern: urllib.request.urlretrieve(...)
          - patterns:
              - pattern-either:
                  - pattern-inside: |
                      $OPENER = urllib.URLopener(...)
                      ...
                  - pattern-inside: |
                      $OPENER = urllib.request.URLopener(...)
                      ...
                  - pattern-inside: |
                      $OPENER = urllib.FancyURLopener(...)
                      ...
                  - pattern-inside: |
                      $OPENER = urllib.request.FancyURLopener(...)
                      ...
              - pattern-either:
                  - pattern: $OPENER.open(...)
                  - pattern: $OPENER.retrieve(...)
    message:
      Detected a dynamic value being used with urllib. urllib supports 'file://'
      schemes, so a dynamic value controlled by a malicious actor may allow them to
      read arbitrary files. Audit uses of urllib calls to ensure user data cannot control
      the URLs, or consider using the 'requests' library instead.
    metadata:
      cwe: "CWE-939: Improper Authorization in Handler for Custom URL Scheme"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/blacklists/calls.py#L163
      bandit-code: B310
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.eval-detected.eval-detected
    patterns:
      - pattern-not: eval("...")
      - pattern: eval(...)
    message: |
      Detected the use of eval(). eval() can be dangerous if used to evaluate
      dynamic content. If this content can be input from outside the program, this
      may be a code injection vulnerability. Ensure evaluated content is not definable
      by external sources.
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.exec-detected.exec-detected
    patterns:
      - pattern-not: exec("...")
      - pattern: exec(...)
    message: |
      Detected the use of exec(). exec() can be dangerous if used to evaluate
      dynamic content. If this content can be input from outside the program, this
      may be a code injection vulnerability. Ensure evaluated content is not definable
      by external sources.
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A1: Injection"
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.ftplib.ftplib
    pattern: ftplib.$ANYTHING(...)
    message: |
      FTP does not encrypt communications by default. This can lead to sensitive
      data being exposed. Ensure use of FTP here does not expose sensitive data.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L265
      cwe: "CWE-319: Cleartext Transmission of Sensitive Information"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B321
      references:
        - https://docs.python.org/3/library/telnetlib.html
    severity: WARNING
    languages:
      - python
  - id: python.lang.security.audit.hardcoded-password-default-argument.hardcoded-password-default-argument
    patterns:
      - pattern: |
          def $FUNC(..., password="...", ...):
            ...
    message: |
      Hardcoded password is used as a default argument to '$FUNC'. This could be dangerous if
      a real password is not supplied.
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.httpsconnection-detected.httpsconnection-detected
    patterns:
      - pattern-either:
          - pattern: httplib.HTTPSConnection(...)
          - pattern: http.client.HTTPSConnection(...)
          - pattern: six.moves.http_client.HTTPSConnection(...)
    message: |
      The HTTPSConnection API has changed frequently with minor releases of Python.
      Ensure you are using the API for your version of Python securely.
      For example, Python 3 versions prior to 3.4.3 will not verify SSL certificates by default.
      See https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
      for more information.
    metadata:
      owasp: "A6: Security Misconfiguration"
      cwe: "CWE-295: Improper Certificate Validation"
      references:
        - https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    severity: WARNING
    languages:
      - python
  - id: python.lang.security.audit.logging.listeneval.listen-eval
    languages:
      - python
    message: |
      Because portions of the logging configuration are passed through eval(),
      use of this function may open its users to a security risk. While the
      function only binds to a socket on localhost, and so does not accept
      connections from remote machines, there are scenarios where untrusted
      code could be run under the account of the process which calls listen().
      See more details at https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
    metadata:
      cwe:
        "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
        ('Eval Injection')"
      owasp: "A6: Security Misconfiguration"
      references:
        - https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
    patterns:
      - pattern: logging.config.listen(...)
    severity: WARNING
  - id: python.lang.security.audit.mako-templates-detected.mako-templates-detected
    pattern: mako.template.Template(...)
    message: |
      Mako templates do not provide a global HTML escaping mechanism.
      This means you must escape all sensitive data in your templates
      using '| u' for URL escaping or '| h' for HTML escaping.
      If you are using Mako to serve web content, consider using
      a system such as Jinja2 which enables global escaping.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-Site Scripting (XSS)"
      source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/mako_templates.py
      references:
        - https://docs.makotemplates.org/en/latest/syntax.html#expression-escaping
        - https://jinja.palletsprojects.com/en/2.11.x/intro/#
    languages:
      - python
    severity: INFO
  - id: python.lang.security.audit.marshal.marshal-usage
    languages:
      - python
    message: |
      The marshal module is not intended to be secure against erroneous or maliciously constructed data.
      Never unmarshal data received from an untrusted or unauthenticated source.
      See more details: https://docs.python.org/3/library/marshal.html?highlight=security
    metadata:
      cwe: "CWE-502: Deserialization of Untrusted Data"
      owasp: "A8: Insecure Deserialization"
      references:
        - https://docs.python.org/3/library/marshal.html?highlight=security
    pattern-either:
      - pattern: marshal.dump(...)
      - pattern: marshal.dumps(...)
      - pattern: marshal.load(...)
      - pattern: marshal.loads(...)
    severity: WARNING
  - id: python.lang.security.audit.network.bind.avoid-bind-to-all-interfaces
    patterns:
      - pattern-either:
          - pattern: |
              $S = socket.socket(...)
              ...
              $S.bind(("0.0.0.0", ...))
          - pattern: |
              $S = socket.socket(...)
              ...
              $S.bind(("::", ...))
          - pattern: |
              $S = socket.socket(...)
              ...
              $S.bind(("", ...))
    message: |
      Running `socket.bind` to 0.0.0.0, ::, or empty string could unexpectedly
      expose the server publicly as it binds to all available interfaces. Consider
      instead getting correct address from an environment variable or
      configuration file.
    metadata:
      cwe: "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
      owasp: "A6: Security Misconfiguration"
    languages:
      - python
    severity: INFO
  - id: python.lang.security.audit.network.http-not-https-connection.http-not-https-connection
    patterns:
      - pattern-either:
          - pattern: urllib3.HTTPConnectionPool(...)
          - pattern: urllib3.connectionpool.HTTPConnectionPool(...)
    message: |
      Detected HTTPConnectionPool. This will transmit data in cleartext.
      It is recommended to use HTTPSConnectionPool instead for to encrypt
      communications.
    metadata:
      cwe: "CWE-319: Cleartext Transmission of Sensitive Information"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://urllib3.readthedocs.io/en/1.2.1/pools.html#urllib3.connectionpool.HTTPSConnectionPool
    languages:
      - python
    severity: ERROR
  - id: python.lang.security.audit.paramiko-implicit-trust-host-key.paramiko-implicit-trust-host-key
    patterns:
      - pattern-inside: |
          $CLIENT = paramiko.client.SSHClient(...)
          ...
          $CLIENT.set_missing_host_key_policy(...)
      - pattern-either:
          - pattern: paramiko.client.AutoAddPolicy
          - pattern: paramiko.client.WarningPolicy
    message: |
      Detected a paramiko host key policy that implicitly trusts a server's
      host key. Host keys should be verified to ensure the connection
      is not to a malicious server. Use RejectPolicy or a custom subclass
      instead.
    metadata:
      cwe: "CWE-322: Key Exchange without Entity Authentication"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/ssh_no_host_key_verification.py
      references:
        - http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.AutoAddPolicy
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.paramiko.paramiko-exec-command.paramiko-exec-command
    patterns:
      - pattern-inside: |
          import paramiko
          ...
      - pattern: $CLIENT.exec_command(...)
    message: |
      Unverified SSL context detected. This will permit insecure connections without verifying
      SSL certificates. Use 'ssl.create_default_context()' instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/plugins/injection_paramiko.py
      owasp: "A1: Injection"
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      references:
        - http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.exec_command
        - https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/plugins/injection_paramiko.py
    severity: WARNING
    languages:
      - python
  - id: python.lang.security.audit.ssl-wrap-socket-is-deprecated.ssl-wrap-socket-is-deprecated
    pattern: ssl.wrap_socket(...)
    message: |
      'ssl.wrap_socket()' is deprecated. This function creates an insecure socket
      without server name indication or hostname matching. Instead, create an SSL
      context using 'ssl.SSLContext()' and use that to wrap a socket.
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://docs.python.org/3/library/ssl.html#ssl.wrap_socket
        - https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.subprocess-shell-true.subprocess-shell-true
    pattern: subprocess.$FUNC(..., shell=True, ...)
    message: |
      Found 'subprocess' function '$FUNC' with 'shell=True'. This is dangerous because this call will spawn
      the command using a shell process. Doing so propagates current shell settings and variables, which
      makes it much easier for a malicious actor to execute commands. Use 'shell=False' instead.
    fix-regex:
      regex: (shell\s*=\s*)True
      replacement: \1False
    metadata:
      owasp: "A1: Injection"
      cwe:
        "CWE-78: Improper Neutralization of Special Elements used in an OS Command
        ('OS Command Injection')"
      references:
        - https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess
        - https://docs.python.org/3/library/subprocess.html
    languages:
      - python
    severity: ERROR
  - id: python.lang.security.audit.system-wildcard-detected.system-wildcard-detected
    patterns:
      - pattern-either:
          - pattern-inside: os.system("...")
          - pattern-inside: os.popen("...")
          - pattern-inside: os.popen2("...")
          - pattern-inside: os.popen3("...")
          - pattern-inside: os.popen4("...")
          - pattern-inside: subprocess.$W(..., shell=True, ...)
      - pattern-regex: (tar|chmod|chown|rsync)(.*?)\*
    message: |
      Detected use of the wildcard character in a system call that spawns a shell.
      This subjects the wildcard to normal shell expansion, which can have unintended consequences
      if there exist any non-standard file names. Consider a file named '-e sh script.sh' -- this
      will execute a script when 'rsync' is called. See
      https://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt
      for more information.
    metadata:
      cwe: "CWE-155: Improper Neutralization of Wildcards or Matching Symbols"
      owasp: "A1: Injection"
      source-url-open: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/injection_wildcard.py
      references:
        - https://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.audit.telnetlib.telnetlib
    pattern: telnetlib.$ANYTHING(...)
    message: |
      Telnet does not encrypt communications. Use SSH instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L208
      cwe: "CWE-319: Cleartext Transmission of Sensitive Information"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B312
      references:
        - https://docs.python.org/3/library/telnetlib.html
    severity: WARNING
    languages:
      - python
  - id: python.lang.security.audit.weak-ssl-version.weak-ssl-version
    patterns:
      - pattern-either:
          - pattern: ssl.PROTOCOL_SSLv2
          - pattern: ssl.PROTOCOL_SSLv3
          - pattern: ssl.PROTOCOL_TLSv1
          - pattern: ssl.PROTOCOL_TLSv1_1
          - pattern: pyOpenSSL.SSL.SSLv2_METHOD
          - pattern: pyOpenSSL.SSL.SSLv23_METHOD
          - pattern: pyOpenSSL.SSL.SSLv3_METHOD
          - pattern: pyOpenSSL.SSL.TLSv1_METHOD
          - pattern: pyOpenSSL.SSL.TLSv1_1_METHOD
    message: |
      An insecure SSL version was detected. TLS versions 1.0, 1.1, and all SSL versions
      are considered weak encryption and are deprecated.
      Use 'ssl.PROTOCOL_TLSv1_2' or higher.
    metadata:
      cwe: "CWE-326: Inadequate Encryption Strength"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/insecure_ssl_tls.py#L30
      references:
        - https://tools.ietf.org/html/rfc7568
        - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
        - https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLSv1_2
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.deserialization.avoid-pyyaml-load.avoid-pyyaml-load
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
      references:
        - https://github.com/yaml/pyyaml/wiki/PyYAML-yaml.load(input)-Deprecation
        - https://nvd.nist.gov/vuln/detail/CVE-2017-18342
    languages:
      - python
    message: |
      Avoid using `load()`. `PyYAML.load` can create arbitrary Python
      objects. A malicious actor could exploit this to run arbitrary
      code. Use `safe_load()` instead.
    fix-regex:
      regex: load
      replacement: safe_load
      count: 1
    severity: ERROR
    patterns:
      - pattern-inside: |
          import yaml
          ...
      - pattern-not-inside: |
          $YAML = ruamel.yaml.YAML(...)
          ...
          $YAML.load(...)
      - pattern-not: yaml.load(..., Loader=yaml.CSafeLoader, ...)
      - pattern-not: yaml.load(..., Loader=yaml.SafeLoader, ...)
      - pattern: yaml.load(...)
  - id: python.lang.security.deserialization.pickle.avoid-cPickle
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
      references:
        - https://docs.python.org/3/library/pickle.html
    languages:
      - python
    message: |
      Avoid using `cPickle`, which is known to lead to code execution vulnerabilities.
      When unpickling, the serialized data could be manipulated to run arbitrary code.
      Instead, consider serializing the relevant data as JSON or a similar text-based
      serialization format.
    severity: WARNING
    pattern: cPickle.$FUNC(...)
  - id: python.lang.security.deserialization.pickle.avoid-dill
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
      references:
        - https://docs.python.org/3/library/pickle.html
    languages:
      - python
    message: |
      Avoid using `dill`, which uses `pickle`, which is known to lead to code execution vulnerabilities.
      When unpickling, the serialized data could be manipulated to run arbitrary code.
      Instead, consider serializing the relevant data as JSON or a similar text-based
      serialization format.
    severity: WARNING
    pattern-either:
      - pattern: dill.$FUNC(...)
  - id: python.lang.security.deserialization.pickle.avoid-pickle
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
      references:
        - https://docs.python.org/3/library/pickle.html
        - https://davidhamann.de/2020/04/05/exploiting-python-pickle/
    languages:
      - python
    message: |
      Avoid using `pickle`, which is known to lead to code execution vulnerabilities.
      When unpickling, the serialized data could be manipulated to run arbitrary code.
      Instead, consider serializing the relevant data as JSON or a similar text-based
      serialization format.
    severity: WARNING
    pattern-either:
      - pattern: pickle.$FUNC(...)
      - pattern: _pickle.$FUNC(...)
  - id: python.lang.security.deserialization.pickle.avoid-shelve
    metadata:
      owasp: "A8: Insecure Deserialization"
      cwe: "CWE-502: Deserialization of Untrusted Data"
      references:
        - https://docs.python.org/3/library/pickle.html
    languages:
      - python
    message: |
      Avoid using `shelve`, which uses `pickle`, which is known to lead to code execution vulnerabilities.
      When unpickling, the serialized data could be manipulated to run arbitrary code.
      Instead, consider serializing the relevant data as JSON or a similar text-based
      serialization format.
    severity: WARNING
    pattern-either:
      - pattern: shelve.$FUNC(...)
  - id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
    pattern: hashlib.md5(...)
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B303
      references:
        - https://tools.ietf.org/html/rfc6151
        - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
    pattern: hashlib.sha1(...)
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B303
      references:
        - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
        - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
        - http://2012.sharcs.org/slides/stevens.pdf
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.lang.security.insecure-hash-function.insecure-hash-function
    patterns:
      - pattern-either:
          - pattern: hashlib.new("=~/[M|m][D|d][4|5]/", ...)
          - pattern: hashlib.new(..., name="=~/[M|m][D|d][4|5]/", ...)
    message: |
      Detected use of an insecure MD4 or MD5 hash function.
      These functions have known vulnerabilities and are considered deprecated.
      Consider using 'SHA256' or a similar function instead.
    metadata:
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/hashlib_new_insecure_functions.py
      references:
        - https://tools.ietf.org/html/rfc6151
        - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    languages:
      - python
    severity: WARNING
  - id: python.lang.security.unquoted-csv-writer.unquoted-csv-writer
    patterns:
      - pattern-not: csv.writer(..., quoting=csv.QUOTE_ALL, ...)
      - pattern: csv.writer(...)
    message: Found an unquoted CSV writer. This is susceptible to injection. Use 'quoting=csv.QUOTE_ALL'.
    metadata:
      cwe: "CWE-1236: Improper Neutralization of Formula Elements in a CSV File"
      owasp: "A1: Injection"
      references:
        - https://affinity-it-security.com/how-to-prevent-csv-injection/
    fix-regex:
      regex: (.*)\)
      replacement: \1, quoting=csv.QUOTE_ALL)
    languages:
      - python
    severity: ERROR
  - id: python.lang.security.unverified-ssl-context.unverified-ssl-context
    pattern: ssl._create_unverified_context(...)
    message: |
      Unverified SSL context detected. This will permit insecure connections without verifying
      SSL certificates. Use 'ssl.create_default_context()' instead.
    metadata:
      owasp: "A6: Security Misconfiguration"
      cwe: "CWE-295: Improper Certificate Validation"
      references:
        - https://docs.python.org/3/library/ssl.html#ssl-security
        - https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    severity: ERROR
    languages:
      - python
  - id: python.lang.security.use-defused-xml.use-defused-xml
    pattern-either:
      - pattern: import xml
    fix-regex:
      regex: xml
      replacement: defusedxml
    metadata:
      owasp: "A4: XML External Entities (XXE)"
      cwe: "CWE-611: Improper Restriction of XML External Entity Reference"
      references:
        - https://docs.python.org/3/library/xml.html
        - https://github.com/tiran/defusedxml
    message: |
      Found use of the native Python XML libraries, which is vulnerable to XML external entity (XXE)
      attacks. The Python documentation recommends the 'defusedxml' library instead. Use 'defusedxml'.
      See https://github.com/tiran/defusedxml for more information.
    languages:
      - python
    severity: ERROR
  - id: python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc
    pattern-either:
      - pattern: import xmlrpclib
      - pattern: import SimpleXMLRPCServer
      - pattern: import xmlrpc
    message: |
      Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities.
      Use defusedxml.xmlrpc instead.
    metadata:
      cwe:
        "CWE-776: Improper Restriction of Recursive Entity References in DTDs ('XML
        Entity Expansion')"
      owasp: "A4: XML External Entities (XXE)"
      source-rule-url: https://github.com/PyCQA/bandit/blob/07f84cb5f5e7c1055e6feaa0fe93afa471de0ac3/bandit/blacklists/imports.py#L160
      references:
        - https://pypi.org/project/defusedxml/
        - https://docs.python.org/3/library/xml.html#xml-vulnerabilities
    severity: ERROR
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-blowfish
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.Blowfish.new(...)
          - pattern: Crypto.Cipher.Blowfish.new(...)
    message: |
      Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-des
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.DES.new(...)
          - pattern: Crypto.Cipher.DES.new(...)
    message: |
      Detected DES cipher algorithm which is considered insecure. The algorithm is
      considered weak and has been deprecated. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://tools.ietf.org/html/rfc5469
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc2
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.ARC2.new(...)
          - pattern: Crypto.Cipher.ARC2.new
    message: |
      Detected RC2 cipher algorithm which is considered insecure. The algorithm has known vulnerabilities and is difficult to use securely. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://security.stackexchange.com/questions/93924/is-rc2-cbc-at-all-secure
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc4
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.ARC4.new(...)
          - pattern: Crypto.Cipher.ARC4.new(...)
    message: |
      Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
      known vulnerabilities. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
        - https://sweet32.info/
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-xor
    patterns:
      - pattern-either:
          - pattern: Cryptodome.Cipher.XOR.new(...)
          - pattern: Crypto.Cipher.XOR.new(...)
    message: |
      Detected XOR cipher algorithm which is considered insecure. This algorithm
      is not cryptographically secure and can be reversed easily. Use AES instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      bandit-code: B304
      references:
        - https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md2
    patterns:
      - pattern-either:
          - pattern: Crypto.Hash.MD2.new(...)
          - pattern: Cryptodome.Hash.MD2.new (...)
    message: |
      Detected MD2 hash algorithm which is considered insecure. This algorithm
      has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://tools.ietf.org/html/rfc6149
        - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2409
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md4
    patterns:
      - pattern-either:
          - pattern: Crypto.Hash.MD4.new(...)
          - pattern: Cryptodome.Hash.MD4.new (...)
    message: |
      Detected MD4 hash algorithm which is considered insecure. This algorithm
      has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://tools.ietf.org/html/rfc6150
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md5
    patterns:
      - pattern-either:
          - pattern: Crypto.Hash.MD5.new(...)
          - pattern: Cryptodome.Hash.MD5.new (...)
    message: |
      Detected MD5 hash algorithm which is considered insecure. MD5 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://tools.ietf.org/html/rfc6151
        - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-sha1
    patterns:
      - pattern-either:
          - pattern: Crypto.Hash.SHA.new(...)
          - pattern: Cryptodome.Hash.SHA.new (...)
    message: |
      Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
      collision resistant and is therefore not suitable as a cryptographic
      signature. Use SHA256 or SHA3 instead.
    metadata:
      source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
      cwe: "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
        - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
        - http://2012.sharcs.org/slides/stevens.pdf
        - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
    severity: WARNING
    languages:
      - python
  - id: python.requests.security.disabled-cert-validation.disabled-cert-validation
    patterns:
      - pattern-either:
          - pattern: requests.put(..., verify=False, ...)
          - pattern: requests.patch(..., verify=False, ...)
          - pattern: requests.delete(..., verify=False, ...)
          - pattern: requests.head(..., verify=False, ...)
          - pattern: requests.options(..., verify=False, ...)
          - pattern: requests.request(..., verify=False, ...)
          - pattern: requests.get(..., verify=False, ...)
          - pattern: requests.post(..., verify=False, ...)
    message: |
      Certificate verification has been explicitly disabled. This
      permits insecure connections to insecure servers. Re-enable
      certification validation.
    metadata:
      cwe: "CWE-295: Improper Certificate Validation"
      owasp: "A3: Sensitive Data Exposure"
      references:
        - https://stackoverflow.com/questions/41740361/is-it-safe-to-disable-ssl-certificate-verification-in-pythonss-requests-lib
    languages:
      - python
    severity: ERROR
  - id: python.requests.security.no-auth-over-http.no-auth-over-http
    patterns:
      - pattern-either:
          - pattern: requests.$W("=~/http:\/\/.*/", ..., auth=$X, ...)
          - pattern: |
              $URL = "=~/http:\/\/.../"
              ...
              requests.$W($URL, ..., auth=$X, ...)
    fix-regex:
      regex: http:\/\/
      replacement: https://
      count: 1
    message: |
      Authentication detected over HTTP. HTTP does not provide any
      encryption or protection for these authentication credentials.
      This may expose these credentials to unauthhorized parties.
      Use 'https://' instead.
    metadata:
      cwe: "CWE-523: Unprotected Transport of Credentials"
      owasp: "A2: Broken Authentication"
      source-rule-url: https://pypi.org/project/flake8-flask/
      references:
        - https://blog.r2c.dev/2020/bento-check-no-auth-over-http/
        - https://bento.dev/checks/requests/no-auth-over-http/
    languages:
      - python
    severity: ERROR
  - id: python.sqlalchemy.security.sqlalchemy-sql-injection.sqlalchemy-sql-injection
    patterns:
      - pattern-either:
          - pattern: |
              def $FUNC(...,$VAR,...):
                ...
                $SESSION.query(...).$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
          - pattern: |
              def $FUNC(...,$VAR,...):
                ...
                $SESSION.query.join(...).$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
          - pattern: |
              def $FUNC(...,$VAR,...):
                ...
                $SESSION.query.$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
          - pattern: |
              def $FUNC(...,$VAR,...):
                ...
                query.$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
      - metavariable-regex:
          metavariable: $SQLFUNC
          regex: (group_by|order_by|distinct|having|filter)
      - metavariable-regex:
          metavariable: $FORMATFUNC
          regex: (?!bindparams)
    message: |
      Distinct, Having, Group_by, Order_by, and Filter in SQLAlchemy can cause sql injections
      if the developer inputs raw SQL into the before-mentioned clauses.
      This pattern captures relevant cases in which the developer inputs raw SQL into the distinct, having, group_by, order_by or filter clauses and
      injects user-input into the raw SQL with any function besides "bindparams". Use bindParams to securely bind user-input
      to SQL statements.
    fix-regex:
      regex: format
      replacement: bindparams
    languages:
      - python
    severity: WARNING
  - id: ruby.lang.security.no-eval.ruby-eval
    patterns:
      - pattern-either:
          - pattern: eval(...)
          - pattern: |
              $CLASS.class_eval do
                ...
              end
          - pattern: |
              $CLASS.instance_eval do
                ...
              end
          - pattern: |
              $CLASS.module_eval do
                ...
              end
          - pattern: |
              $CLASS.class_eval(...)
          - pattern: |
              $CLASS.instance_eval(...)
          - pattern: |
              $CLASS.module_eval(...)
    message: |
      Use of eval detected. This can run arbitrary code. Ensure external data
      does not reach here, otherwise this is a security vulnerability.
      Consider other ways to do this without eval.
    languages:
      - ruby
    severity: WARNING
  - id: ruby.lang.security.filter-skipping.filter-skipping
    patterns:
      - pattern-not: |
          $CALL "=~/.*(/:action.*).*/", $ACTION
      - pattern: |
          $CALL "=~/.*(/:action.*).*/"
    message: |
      Checks for use of action in Ruby routes. This can cause Rails to render an arbitrary view if an
      attacker creates an URL accurately. Affects 3.0 applications. Can avoid the vulnerability by providing
      additional constraints.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_filter_skipping.rb
        - https://groups.google.com/g/rubyonrails-security/c/NCCsca7TEtY
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.bad-deserialization.bad-deserialization
    patterns:
      - pattern-either:
          - pattern: |
              YAML.load(...)
          - pattern: |
              CSV.load(...)
          - pattern: |
              Marshal.load(...)
          - pattern: |
              Marshal.restore(...)
          - pattern: |
              $OBJ.object_load(...)
      - pattern-not: |
          YAML.load(..., safe: true, ...)
    message: |
      Checks for unsafe deserialization. Objects in Ruby can be serialized into strings,
      then later loaded from strings. However, uses of load and object_load can cause remote code execution.
      Loading user input with YAML, MARSHAL, or CSV can potentially be dangerous. Use JSON securely instead.
    metadata:
      references:
        - https://groups.google.com/g/rubyonrails-security/c/61bkgvnSGTQ/m/nehwjA8tQ8EJ
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_deserialize.rb
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.divide-by-zero.divide-by-zero
    patterns:
      - pattern-either:
          - pattern: |
              $X / 0
          - pattern: |
              $ZERO = 0
              ...
              $X / $ZERO
    message: |
      Checks for divide by zero. Best practice involves not dividing a variable by zero, as this leads to a Ruby
      ZeroDivisionError.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_divide_by_zero.rb
    languages:
      - ruby
    severity: WARNING
  - id: ruby.lang.security.hardcoded-http-auth-in-controller.hardcoded-http-auth-in-controller
    pattern: |
      class $CONTROLLER < ApplicationController
        ...
        http_basic_authenticate_with ..., :password => "...", ...
      end
    message: |
      Detected hardcoded password used in basic authentication in a controller
      class. Including this password in version control could expose this
      credential. Consider refactoring to use environment variables or
      configuration files.
    severity: ERROR
    metadata:
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A3: Sensitive Data Exposure"
      source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/basic_auth/index.markdown
    languages:
      - ruby
  - id: ruby.lang.security.force-ssl-false.force-ssl-false
    patterns:
      - pattern: |
          config.force_ssl = false
    message: |
      Checks for configuration setting of force_ssl to false. Force_ssl forces usage of HTTPS, which
      could lead to network interception of unencrypted application traffic. To fix, set config.force_ssl = true.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_force_ssl.rb
    languages:
      - ruby
    severity: WARNING
  - id: ruby.lang.security.cookie-serialization.cookie-serialization
    patterns:
      - pattern-either:
          - pattern: |
              Rails.application.config.action_dispatch.cookies_serializer = :marshal
          - pattern: |
              Rails.application.config.action_dispatch.cookies_serializer = :hybrid
    message: |
      Checks if code allows cookies to be deserialized using Marshal. If the attacker can craft a valid cookie, this could lead to
      remote code execution. The hybrid check is just to warn users to migrate to :json for best practice.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_cookie_serialization.rb
        - https://robertheaton.com/2013/07/22/how-to-hack-a-rails-app-using-its-secret-token/
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.file-disclosure.file-disclosure
    patterns:
      - pattern: |
          config.serve_static_assets = true
    message: |
      Special requests can determine whether a file exists on a filesystem that's outside the Ruby app's
      root directory. To fix this, set config.serve_static_assets = false.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_file_disclosure.rb
        - https://groups.google.com/g/rubyonrails-security/c/23fiuwb1NBA/m/MQVM1-5GkPMJ
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.create-with.create-with
    patterns:
      - pattern-not: |
          $FUNC.create_with($PARAMSB.permit(...))
      - pattern: |
          $FUNC.create_with($PARAMSA)
    message: |
      Checks for strong parameter bypass through usage of create_with. Create_with bypasses strong parameter protection, which
      could allow attackers to set arbitrary attributes on models. To fix this vulnerability, either remove all create_with calls
      or use the permit function to specify tags that are allowed to be set.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_create_with.rb
        - https://groups.google.com/g/rubyonrails-security/c/M4chq5Sb540/m/CC1Fh0Y_NWwJ
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.no-send.bad-send
    patterns:
      - pattern-either:
          - pattern: |
              $PARAM = params[...]
              ...
              $RES = $MOD.send($PARAM.$FUNC)
          - pattern: |
              $PARAM = params[...]
              ...
              $RES = $MOD.try($PARAM.$FUNC)
          - pattern: |
              $PARAM = params[...]
              ...
              $RES = $MOD.__send__($PARAM.$FUNC)
          - pattern: |
              $PARAM = params[...]
              ...
              $RES = $MOD.public_send($PARAM.$FUNC)
    message: |
      Checks for unsafe use of Object#send, try, __send__, and public_send. These only account for unsafe
      use of a method, not target. This can lead to arbitrary calling of exit, along with arbitrary code     execution.
      Please be sure to sanitize input in order to avoid this.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_send.rb
        - https://the.igreque.info/posts/2016/01-object-send-considered-harmful-en.html
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.mass-assignment-protection-disabled.mass-assignment-protection-disabled
    pattern: $MODEL.new(params[...], ..., :without_protection => true, ...)
    message: |
      Mass assignment protection disabled for '$MODEL'. This could
      permit assignment to sensitive model fields without intention. Instead,
      use 'attr_accessible' for the model or disable mass assigment using
      'config.active_record.whitelist_attributes = true'.
      ':without_protection => true' must be removed for this to take effect.
    metadata:
      cwe:
        "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
        Attributes"
      owasp: "A1: Injection"
      source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/mass_assignment/index.markdown
    severity: WARNING
    languages:
      - ruby
  - id: ruby.lang.security.ssl-mode-no-verify.ssl-mode-no-verify
    pattern: OpenSSL::SSL::VERIFY_NONE
    message: |
      Detected SSL that will accept an unverified connection.
      This makes the connections susceptible to man-in-the-middle attacks.
      Use 'OpenSSL::SSL::VERIFY_PEER' intead.
    fix-regex:
      regex: VERIFY_NONE
      replacement: VERIFY_PEER
    severity: WARNING
    languages:
      - ruby
  - id: ruby.lang.security.timing-attack.timing-attack
    patterns:
      - pattern: |
          http_basic_authenticate_with ...
    message: |
      Checks for unsafe use of method http_basic_authenticate_with, which is vulnerable to timing attacks as it
      does not use constant-time checking when comparing passwords. Affected Rails versions include:
      5.0.0.beta1.1, 4.2.5.1, 4.1.14.1, 3.2.22.1. Avoid this function if possible.
    metadata:
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_basic_auth_timing_attack.rb
        - https://groups.google.com/g/rubyonrails-security/c/ANv0HDHEC3k/m/mt7wNGxbFQAJ
    languages:
      - ruby
    severity: ERROR
  - id: ruby.lang.security.missing-csrf-protection.missing-csrf-protection
    patterns:
      - pattern: |
          class $CONTROLLER < ActionController::Base
            ...
          end
      - pattern-not: |
          class $CONTROLLER < ActionController::Base
            ...
            protect_from_forgery :with => :exception
          end
      - pattern-not: |
          class $CONTROLLER < ActionController::Base
            ...
            protect_from_forgery prepend: true, with: :exception
          end
    message: |
      Detected controller which does not enable cross-site request forgery
      protections using 'protect_from_forgery'. Add
      'protect_from_forgery :with => :exception' to your controller class.
    severity: ERROR
    metadata:
      cwe: "CWE-352: Cross-Site Request Forgery (CSRF)"
      owasp: "A6: Security Misconfiguration"
      source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross-site_request_forgery/index.markdown
    languages:
      - ruby
  - id: ruby.lang.security.weak-hashes-md5.weak-hashes-md5
    patterns:
      - pattern-either:
          - pattern: Digest::MD5.base64digest $X
          - pattern: Digest::MD5.hexdigest $X
          - pattern: Digest::MD5.digest $X
          - pattern: Digest::MD5.new
          - pattern: OpenSSL::Digest::MD5.base64digest $X
          - pattern: OpenSSL::Digest::MD5.hexdigest $X
          - pattern: OpenSSL::Digest::MD5.digest $X
          - pattern: OpenSSL::Digest::MD5.new
    message: |
      Should not use md5 to generate hashes. md5 is proven to be vulnerable through the use of brute-force attacks.
      Could also result in collisions,leading to potential collision attacks. Use SHA256 or other hashing functions instead.
    metadata:
      references:
        - https://www.ibm.com/support/pages/security-bulletin-vulnerability-md5-signature-and-hash-algorithm-affects-sterling-integrator-and-sterling-file-gateway-cve-2015-7575
    languages:
      - ruby
    severity: WARNING
  - id: ruby.lang.security.weak-hashes-sha1.weak-hashes-sha1
    patterns:
      - pattern-either:
          - pattern: Digest::SHA1.$FUNC $X
          - pattern: Digest::SHA1.$FUNC
          - pattern: OpenSSL::Digest::SHA1.$FUNC $X
          - pattern: OpenSSL::Digest::SHA1.$FUNC
          - pattern: OpenSSL::HMAC.$FUNC("sha1",...)
    message: |
      Should not use SHA1 to generate hashes. There is a proven SHA1 hash collision by Google, which could lead to vulnerabilities.
      Use SHA256, SHA3 or other hashing functions instead.
    metadata:
      references:
        - https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html
        - https://shattered.io/
    languages:
      - ruby
    severity: WARNING
  - id: ruby.lang.security.unprotected-mass-assign.mass-assignment-vuln
    patterns:
      - pattern-either:
          - pattern: |
              $MOD.new(params[$CODE])
          - pattern: |
              $MOD.new(..., params[$CODE], :without_protection => true, ...)
      - pattern-not-inside: |
          attr_accessible $VAR
          ...
          $MOD.new(params[$CODE])
    message: |
      Checks for calls to without_protection during mass assignment (which allows record creation from hash values).
      This can lead to users bypassing permissions protections. For Rails 4 and higher, mass protection is on by default.
      Fix: Don't use :without_protection => true. Instead, configure attr_acessible to control attribute access.
    metadata:
      owasp: "A1: Injection"
      cwe:
        "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
        Attributes"
      references:
        - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_without_protection.rb
        - https://www.acunetix.com/vulnerabilities/web/rails-mass-assignment/
    languages:
      - ruby
    severity: WARNING
  - id: typescript.react.security.react-controlled-component-password.react-controlled-component-password
    pattern-either:
      - pattern: <$EL type="password" value={this.state.$X} onChange=...  />
      - pattern: |
          React.createElement($EL,{type: 'password', value: this.state.$X, onChange:...},...)
      - pattern: |
          $PARAMS = {type: 'password', value: this.state.$X, onChange:...};
          ...
          React.createElement($EL,$PARAMS,...);
    message: |
      Password can be leaked if CSS injection exists on the page.
    metadata:
      references:
        - https://no-csp-css-keylogger.badsite.io/
    languages:
      - typescript
      - javascript
    severity: WARNING
  - id: typescript.react.security.react-insecure-request.react-insecure-request
    patterns:
      - pattern-either:
          - patterns:
              - pattern-either:
                  - pattern-inside: |
                      import $AXIOS from 'axios';
                      ...
                  - pattern-inside: |
                      $AXIOS = require('axios');
                      ...
              - pattern-either:
                  - pattern: $AXIOS.$METHOD($URL,...)
                  - pattern: |
                      $VAR = $URL;
                      ...
                      $AXIOS.$METHOD($VAR,...);
                  - pattern: |
                      $AXIOS({url: $URL},...)
                  - pattern: |
                      $VAR = {url: $URL};
                      ...
                      $AXIOS($VAR,...);
          - pattern: fetch($URL,...)
          - pattern: |
              $VAR = $URL;
              ...
              fetch($VAR,...);
      - metavariable-regex:
          metavariable: $URL
          regex: '["''](http://).*[''"]'
    message: |
      Unencrypted request over HTTP detected.
    metadata:
      vulnerability: Insecure Transport
      owasp: "A3: Sensitive Data Exposure"
      cwe: "CWE-319: Cleartext Transmission of Sensitive Information"
      references:
        - https://www.npmjs.com/package/axios
    languages:
      - typescript
      - javascript
    severity: ERROR
  - id: typescript.react.security.react-markdown-insecure-html.react-markdown-insecure-html
    patterns:
      - pattern-either:
          - pattern-inside: |
              $X = require('react-markdown/with-html');
              ...
          - pattern-inside: |
              $X = require('react-markdown');
              ...
          - pattern-inside: |
              import 'react-markdown/with-html';
              ...
          - pattern-inside: |
              import 'react-markdown';
              ...
      - pattern-either:
          - pattern: |
              <$EL allowDangerousHtml />
          - pattern: |
              <$EL transformLinkUri=... />
          - pattern: |
              <$EL transformImageUri=... />
    message: |
      Overwriting `transformLinkUri` or `transformImageUri` to something insecure or turning `allowDangerousHtml` on, will open code up to XSS vectors.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://www.npmjs.com/package/react-markdown#security
    languages:
      - typescript
      - javascript
    severity: WARNING
  - id: typescript.react.security.audit.react-dangerouslysetinnerhtml.react-dangerouslysetinnerhtml
    pattern-either:
      - pattern: |
          <$X dangerouslySetInnerHTML=... />
      - pattern: |
          {dangerouslySetInnerHTML: ...}
    message:
      "Setting HTML from code is risky because it\u2019s easy to inadvertently
      expose your users to a cross-site scripting (XSS) attack.\n"
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml
    languages:
      - typescript
      - javascript
    severity: WARNING
  - id: typescript.react.security.audit.react-css-injection.react-css-injection
    patterns:
      - pattern-either:
          - pattern-inside: |
              import $STYLE from "...";
              ...
          - pattern-inside: |
              $STYLE = $METHOD(...);
              ...
          - pattern-inside: |
              function $FUNC(...,{$STYLE},...) {
                ...
              }
          - pattern-inside: |
              function $FUNC(...,$STYLE,...) {
                ...
              }
      - pattern-inside: |
          <$EL style={$STYLE} />
      - pattern-not-inside: |
          <$EL style={{$X:...}} />
      - pattern: $STYLE
    message: |
      User controlled data in a `style` attribute is an anti-pattern than can lead to XSS vulnerabilities
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
    languages:
      - typescript
      - javascript
    severity: WARNING
  - id: typescript.react.security.audit.react-http-leak.react-http-leak
    pattern-either:
      - patterns:
          - pattern: |
              <$EL codebase=... />
          - metavariable-regex:
              metavariable: $EL
              regex: applet|object
          - pattern-not: |
              <$EL codebase="..." />
      - patterns:
          - pattern: |
              <$EL cite=... />
          - metavariable-regex:
              metavariable: $EL
              regex: blockquote|del|ins|q
          - pattern-not: |
              <$EL cite="..." />
      - patterns:
          - pattern: |
              <$EL longdesc=... />
          - metavariable-regex:
              metavariable: $EL
              regex: frame|iframe|img
          - pattern-not: |
              <$EL longdesc="..." />
      - patterns:
          - pattern: |
              <$EL src={$INJECT} />
          - metavariable-regex:
              metavariable: $EL
              regex: frame|iframe|img|input|script|audio|source|track|embed|video
          - pattern-not: |
              <$EL src="..." />
          - pattern-not-inside: |
              import $INJECT from "...";
              ...
      - patterns:
          - pattern: |
              <$EL usemap=... />
          - metavariable-regex:
              metavariable: $EL
              regex: img|input|object
          - pattern-not: |
              <$EL usemap="..." />
      - patterns:
          - pattern: |
              <$EL formaction=... />
          - metavariable-regex:
              metavariable: $EL
              regex: button|input
          - pattern-not: |
              <$EL formaction="..." />
      - patterns:
          - pattern: |
              <$EL srcset=... />
          - metavariable-regex:
              metavariable: $EL
              regex: img|source
          - pattern-not: |
              <$EL srcset="..." />
      - patterns:
          - pattern: |
              <$EL archive=... />
          - metavariable-regex:
              metavariable: $EL
              regex: object|applet
          - pattern-not: |
              <$EL archive="..." />
      - patterns:
          - pattern: |
              <body background=... />
          - pattern-not: |
              <body background="..." />
      - patterns:
          - pattern: |
              <form action=... />
          - pattern-not: |
              <form action="..." />
      - patterns:
          - pattern: |
              <head profile=... />
          - pattern-not: |
              <head profile="..." />
      - patterns:
          - pattern: |
              <object $ATTR=... />
          - metavariable-regex:
              metavariable: $ATTR
              regex: classid|data
          - pattern-not: |
              <object $ATTR="..." />
      - patterns:
          - pattern: |
              <video poster=... />
          - pattern-not: |
              <video poster="..." />
      - patterns:
          - pattern: |
              <command icon=... />
          - pattern-not: |
              <command icon="..." />
      - patterns:
          - pattern: |
              <html manifest=... />
          - pattern-not: |
              <html manifest="..." />
      - patterns:
          - pattern: |
              <meta content=... />
          - pattern-not: |
              <meta content="..." />
    message:
      This HTML element '$EL' and attribute '$ATTR' together may load an external
      resource. This means that if dynamic content can enter this attribute it may be
      possible for an attacker to send HTTP requests to unintended locations which may
      leak data about your users. If this element is reaching out to a known host, consider
      hardcoding the host (or loading from a configuration) and appending the dynamic
      path. See https://github.com/cure53/HTTPLeaks for more information.
    metadata:
      owasp: "A3: Sensitive Data Exposure"
      cwe: "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
      references:
        - https://github.com/cure53/HTTPLeaks
    languages:
      - typescript
      - javascript
    severity: WARNING
  - id: json.aws.security.public-s3-policy-statement.public-s3-policy-statement
    pattern: |
      {
        "Effect": "Allow",
        "Principal": "*",
        "Resource": [
          ..., "=~/arn:aws:s3.*/", ...
        ],
        ...
      }
    message: |
      Detected public s3 bucket policy. This policy allows anyone to access
      certain properties of or items in the bucket. Do not do this unless you
      will never have sensitive data inside the bucket.
    metadata:
      owasp: "A6: Security Misconfiguration"
      cwe: CWE-264 - Permissions, Privileges, and Access Controls
      references:
        - https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteAccessPermissionsReqd.html
    severity: WARNING
    languages:
      - json
  - id: terraform.lang.security.ebs-unencrypted-volume.unencrypted-ebs-volume
    patterns:
      - pattern-either:
          - pattern: |
              {...}
      - pattern-not-inside: |
          resource "aws_ebs_volume" "..." {... encrypted=true ...}
      - pattern-inside: |
          resource "aws_ebs_volume" "..." {...}
    languages:
      - generic
    paths:
      include:
        - "*.tf"
    message: |
      An EBS volume is configured without encryption enabled.
    severity: WARNING
  - id: terraform.lang.security.eks-public-endpoint-enabled.eks-public-endpoint-enabled
    patterns:
      - pattern-either:
          - pattern: |
              {...}
      - pattern-inside: |
          resource "aws_eks_cluster" "..." {...}
      - pattern-not-inside: |
          {... vpc_config{... endpoint_public_access = false ...} ...}
    languages:
      - generic
    paths:
      include:
        - "*.tf"
    message: |
      The vpc_config resource inside the eks cluster has not explicitly disabled public endpoint access
    severity: WARNING
  - id: terraform.lang.security.s3-cors-all-origins.all-origins-allowed
    patterns:
      - pattern-inside: cors_rule { ... }
      - pattern: allowed_origins = ["*"]
    languages:
      - generic
    paths:
      include:
        - "*.tf"
    severity: WARNING
    message: CORS rule on bucket permits any origin
    metadata:
      references:
        - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#using-cors
  - id: terraform.lang.security.s3-public-rw-bucket.s3-public-rw-bucket
    pattern: acl = "public-read-write"
    languages:
      - generic
    paths:
      include:
        - "*.tf"
    severity: ERROR
    message: S3 bucket with public read-write access detected.
    metadata:
      references:
        - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#acl
        - https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl
  - id: html.security.missing-noopener.missing-noopener
    patterns:
      - pattern: |
          <a ... target="_blank" ... >
      - pattern-not-inside: |
          <a ... rel="... noopener ..." ... >
    paths:
      include:
        - "*.html"
    message:
      This anchor tag with 'target="_blank"' is missing 'noopener'. A page opened
      with 'target="_blank"' can access the window object of the origin page. This means
      it can manipulate the 'window.opener' property, which could redirect the origin
      page to a malicious URL. This is called reverse tabnabbing. To prevent this, include
      'rel=noopener' on this tag
    severity: WARNING
    languages:
      - generic
  - id: html.security.missing-noreferrer.missing-noreferrer
    patterns:
      - pattern: |
          <a ... target="_blank" ...>
      - pattern-not-inside: |
          <a ... rel="... noreferrer ..." ... >
    paths:
      include:
        - "*.html"
    message:
      This anchor tag with 'target="_blank"' is missing 'noreferrer'. A page
      opened with 'target="_blank"' can access the window object of the origin page.
      This means it can manipulate the 'window.opener' property, which could redirect
      the origin page to a malicious URL. This is called reverse tabnabbing. To prevent
      this, include 'rel=noreferrer' on this tag.
    severity: WARNING
    languages:
      - generic
  - id: generic.html-templates.security.unquoted-attribute-var.unquoted-attribute-var
    message:
      'Detected a unquoted template variable as an attribute. If unquoted, a
      malicious actor could inject custom JavaScript handlers. To fix this, add quotes
      around the template expression, like this: "{{ expr }}".'
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss
    languages:
      - generic
    paths:
      include:
        - "*.html"
        - "*.mustache"
        - "*.hbs"
    severity: WARNING
    patterns:
      - pattern-inside: <$TAG ...>
      - pattern-not-inside: ="..."
      - pattern-not-inside: ='...'
      - pattern: "{{ ... }}"
    fix-regex:
      regex: "{{(.*?)}}"
      replacement: '"{{\1}}"'
  - id: generic.html-templates.security.var-in-href.var-in-href
    message:
      Detected a template variable used in an anchor tag with the 'href' attribute.
      This allows a malicious actor to input the 'javascript:' URI and is subject to
      cross- site scripting (XSS) attacks. If using Flask, use 'url_for()' to safely
      generate a URL. If using Django, use the 'url' filter to safely generate a URL.
      If using Mustache, use a URL encoding library, or prepend a slash '/' to the variable
      for relative links (`href="/{{link}}"`). You may also consider setting the Content
      Security Policy (CSP) header.
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss#:~:text=javascript:%20URI
        - https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#url
        - https://github.com/pugjs/pug/issues/2952
        - https://content-security-policy.com/
    languages:
      - generic
    paths:
      include:
        - "*.html"
        - "*.mustache"
        - "*.hbs"
    severity: WARNING
    patterns:
      - pattern-inside: <a ...>
      - pattern-either:
          - pattern: href = {{ ... }}
          - pattern: href = "{{ ... }}"
          - pattern: href = '{{ ... }}'
      - pattern-not-inside: href = {{ url_for(...) ... }}
      - pattern-not-inside: href = "{{ url_for(...) ... }}"
      - pattern-not-inside: href = '{{ url_for(...) ... }}'
      - pattern-not-inside: href = "/{{ ... }}"
      - pattern-not-inside: href = '/{{ ... }}'
  - id: generic.html-templates.security.var-in-script-tag.var-in-script-tag
    message:
      Detected a template variable used in a script tag. Although template variables
      are HTML escaped, HTML escaping does not always prevent cross-site scripting (XSS)
      attacks when used directly in JavaScript. If you need this data on the rendered
      page, consider placing it in the HTML portion (outside of a script tag). Alternatively,
      use a JavaScript-specific encoder, such as the one available in OWASP ESAPI. For
      Django, you may also consider using the 'json_script' template tag and retrieving
      the data in your script by using the element ID (e.g., `document.getElementById`).
    metadata:
      cwe:
        "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site
        Scripting')"
      owasp: "A7: Cross-site Scripting (XSS)"
      references:
        - https://adamj.eu/tech/2020/02/18/safely-including-data-for-javascript-in-a-django-template/?utm_campaign=Django%2BNewsletter&utm_medium=rss&utm_source=Django_Newsletter_12A
        - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough
        - https://github.com/ESAPI/owasp-esapi-js
    languages:
      - generic
    paths:
      include:
        - "*.mustache"
        - "*.hbs"
        - "*.html"
    severity: WARNING
    patterns:
      - pattern-inside: <script ...> ... </script>
      - pattern: "{{ ... }}"
  - id: generic.dockerfile.security.last-user-is-root.last-user-is-root
    patterns:
      - pattern: USER $ROOT
      - pattern-not-inside: |
          USER $ROOT
          ...
          ...
          USER $OTHER
      - metavariable-regex:
          metavariable: $ROOT
          regex: root
    message:
      The last user in the container is 'root'. This is a security hazard because
      if an attacker gains control of the container they will have root access. Switch
      back to another user after running commands as 'root'.
    severity: ERROR
    languages:
      - generic
    metadata:
      source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3002
      references:
        - https://github.com/hadolint/hadolint/wiki/DL3002
    paths:
      include:
        - "*dockerfile*"
        - "*Dockerfile*"
  - id: generic.nginx.security.alias-path-traversal.alias-path-traversal
    patterns:
      - pattern: |
          location ... {
            ...
            alias ...;
            ...
          }
      - pattern-not-inside: location /.../ { ... ... }
    paths:
      include:
        - "*.conf"
        - "*.vhost"
        - sites-available/*
        - sites-enabled/*
    fix-regex:
      regex: location\s+([A-Za-z0-9/-_\.]+)
      replacement: location \1/
    languages:
      - generic
    severity: WARNING
    message:
      The alias in this location block is subject to a path traversal because
      the location path does not end in a path separator (e.g., '/'). To fix, add a
      path separator to the end of the path.
    metadata:
      references:
        - https://github.com/yandex/gixy/blob/master/docs/en/plugins/aliastraversal.md
  - id: generic.nginx.security.dynamic-proxy-host.dynamic-proxy-host
    patterns:
      - pattern-either:
          - pattern: proxy_pass $SCHEME://$$HOST ...;
          - pattern: proxy_pass $$SCHEME://$$HOST ...;
    paths:
      include:
        - "*.conf"
        - "*.vhost"
        - sites-available/*
        - sites-enabled/*
    languages:
      - generic
    severity: WARNING
    message:
      The host for this proxy URL is dynamically determined. This can be dangerous
      if the host can be injected by an attacker because it may forcibly alter destination
      of the proxy. Consider hardcoding acceptable destinations and retrieving them
      with 'map' or something similar.
    metadata:
      references:
        - https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md
        - https://nginx.org/en/docs/http/ngx_http_map_module.html
  - id: generic.nginx.security.dynamic-proxy-scheme.dynamic-proxy-scheme
    patterns:
      - pattern: proxy_pass $$SCHEME:// ...;
    paths:
      include:
        - "*.conf"
        - "*.vhost"
        - sites-available/*
        - sites-enabled/*
    languages:
      - generic
    severity: WARNING
    message:
      The protocol shceme for this proxy is dynamically determined. This can
      be dangerous if the scheme can be injected by an attacker because it may forcibly
      alter the connection scheme. Consider hardcoding a scheme for this proxy.
    metadata:
      references:
        - https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md
  - id: generic.nginx.security.header-injection.header-injection
    pattern: |
      location ... <$VARIABLE> ... {
        ...
        add_header ... $$VARIABLE
        ...
      }
    paths:
      include:
        - "*.conf"
        - "*.vhost"
        - sites-available/*
        - sites-enabled/*
    languages:
      - generic
    severity: ERROR
    message:
      'The $$VARIABLE path parameter is added as a header in the response. This
      could allow an attacker to inject a newline and add a new header into the response.
      This is called HTTP response splitting. To fix, do not allow whitespace in the
      path parameter: ''[^\s]+''.'
    metadata:
      references:
        - https://github.com/yandex/gixy/blob/master/docs/en/plugins/httpsplitting.md
        - https://owasp.org/www-community/attacks/HTTP_Response_Splitting
  - id: generic.nginx.security.header-redefinition.header-redefinition
    patterns:
      - pattern-inside: |
          server {
            ...
            add_header ...;
            ...
            ...
          }
      - pattern-inside: |
          location ... {
            ...
            ...
          }
      - pattern: add_header ...;
    paths:
      include:
        - "*.conf"
        - "*.vhost"
        - sites-available/*
        - sites-enabled/*
    languages:
      - generic
    severity: WARNING
    message:
      The 'add_header' directive is called in a 'location' block after headers
      have been set at the server block. Calling 'add_header' in the location block
      will actually overwrite the headers defined in the server block, no matter which
      headers are set. To fix this, explicitly set all headers or set all headers in
      the server block.
    metadata:
      references:
        - https://github.com/yandex/gixy/blob/master/docs/en/plugins/addheaderredefinition.md
  - id: generic.nginx.security.insecure-redirect.insecure-redirect
    patterns:
      - pattern-either:
          - pattern: rewrite ... redirect
          - pattern: rewrite ... permanent
      - pattern-not-inside: rewrite ... https ... $host ... redirect
      - pattern-not-inside: rewrite ... https ... $host ... permanent
    paths:
      include:
        - "*.conf"
        - "*.vhost"
        - sites-available/*
        - sites-enabled/*
    message: |
      Detected an insecure redirect in this nginx configuration.
      If no scheme is specified, nginx will forward the request with the
      incoming scheme. This could result in unencrypted communications.
      To fix this, include the 'https' scheme.
    languages:
      - generic
    severity: WARNING
  - id: generic.nginx.security.insecure-ssl-version.insecure-ssl-version
    patterns:
      - pattern-not: ssl_protocols TLSv1.2 TLSv1.3;
      - pattern-not: ssl_protocols TLSv1.3 TLSv1.2;
      - pattern-not: ssl_protocols TLSv1.2;
      - pattern-not: ssl_protocols TLSv1.3;
      - pattern: ssl_protocols ...;
    paths:
      include:
        - "*.conf"
        - "*.vhost"
        - sites-available/*
        - sites-enabled/*
    languages:
      - generic
    severity: WARNING
    message:
      Detected use of an insecure SSL version. Secure SSL versions are TLSv1.2
      and TLS1.3; older versions are known to be broken and are susceptible to attacks.
      Prefer use of TLSv1.2 or later.
    metadata:
      references:
        - https://www.acunetix.com/blog/web-security-zone/hardening-nginx/
        - https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/
  - id: generic.nginx.security.missing-internal.missing-internal
    patterns:
      - pattern-inside: |
          location ... {
            ...
            ...
          }
      - pattern-not-inside: |
          location ... {
            ...
            internal;
            ...
          }
      - pattern: proxy_pass ...;
    paths:
      include:
        - "*.conf"
        - "*.vhost"
        - sites-available/*
        - sites-enabled/*
    languages:
      - generic
    severity: WARNING
    message:
      This location block contains a 'proxy_pass' directive but does not contain
      the 'internal' directive. The 'internal' directive restricts access to this location
      to internal requests. Without 'internal', an attacker could use your server for
      server-side request forgeries (SSRF). Include the 'internal' directive in this
      block to limit exposure.
    metadata:
      references:
        - https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md
        - https://nginx.org/en/docs/http/ngx_http_core_module.html#internal
  - id: generic.nginx.security.missing-ssl-version.missing-ssl-version
    patterns:
      - pattern: server { ... listen $PORT ssl; ... }
      - pattern-not-inside: server { ... ssl_protocols ... }
    paths:
      include:
        - "*.conf"
        - "*.vhost"
        - sites-available/*
        - sites-enabled/*
    languages:
      - generic
    severity: WARNING
    message:
      This server configuration is missing the 'ssl_protocols' directive. By
      default, this server will use 'ssl_protocols TLSv1 TLSv1.1 TLSv1.2', and versions
      older than TLSv1.2 are known to be broken. Explicitly specify 'ssl_protocols TLSv1.2
      TLSv1.3' to use secure TLS versions.
    metadata:
      references:
        - https://www.acunetix.com/blog/web-security-zone/hardening-nginx/
        - https://nginx.org/en/docs/http/configuring_https_servers.html
