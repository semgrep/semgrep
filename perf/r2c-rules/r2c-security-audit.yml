rules:
- id: c.lang.security.insecure-use-gets-fn.insecure-use-gets-fn
  pattern: gets(...)
  message: |
    Avoid 'gets()'. This function does not consider buffer boundaries and can lead
    to buffer overflows. Use 'fgets()' or 'gets_s()' instead.
  metadata:
    references:
    - https://us-cert.cisa.gov/bsi/articles/knowledge/coding-practices/fgets-and-gets_s
  languages:
  - c
  severity: ERROR
- id: c.lang.security.insecure-use-printf-fn.insecure-use-printf-fn
  patterns:
  - pattern-either:
    - pattern: |
        $FUNC($BUFFER, argv[$NUM], ...);
        ...
        vsprintf(..., $BUFFER, ...);
    - pattern: vsprintf(..., argv[$NUM], ...)
    - pattern: |
        $FUNC($BUFFER, argv[$NUM], ...);
        ...
        sprintf(..., $BUFFER, ...);
    - pattern: sprintf(...,argv[$NUM],...)
    - pattern: |
        $FUNC($BUFFER, argv[$NUM], ...);
        ...
        printf(..., $BUFFER, ...);
    - pattern: printf(...,argv[$NUM],...)
  message: |
    Avoid using user-controlled format strings passed into 'sprintf', 'printf' and 'vsprintf'.
    These functions put you at risk of buffer overflow vulnerabilities through the use of format string exploits.
    Instead, use 'snprintf' and 'vsnprintf'.
  metadata:
    references:
    - https://doc.castsoftware.com/display/SBX/Never+use+sprintf%28%29+or+vsprintf%28%29+functions
    - https://www.cvedetails.com/cwe-details/134/Uncontrolled-Format-String.html
  languages:
  - c
  severity: WARNING
- id: c.lang.security.insecure-use-scanf-fn.insecure-use-scanf-fn
  pattern: scanf(...)
  message: |
    Avoid using 'scanf()'. This function, when used improperly, does not consider
    buffer boundaries and can lead to buffer overflows. Use 'fgets()' instead
    for reading input.
  metadata:
    references:
    - http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html
  languages:
  - c
  severity: ERROR
- id: c.lang.security.insecure-use-strcat-fn.insecure-use-strcat-fn
  pattern-either:
  - pattern: strcat(...)
  - pattern: strncat(...)
  message: |
    Finding triggers whenever there is a strcat or strncat used.
    This is an issue because strcat or strncat can lead to buffer overflow vulns.
    Fix this by using strcat_s instead.
  metadata:
    references:
    - https://nvd.nist.gov/vuln/detail/CVE-2019-12553
    - https://techblog.mediaservice.net/2020/04/cve-2020-2851-stack-based-buffer-overflow-in-cde-libdtsvc/
  languages:
  - c
  severity: WARNING
- id: c.lang.security.insecure-use-string-copy-fn.insecure-use-string-copy-fn
  pattern-either:
  - pattern: strcpy(...)
  - pattern: strncpy(...)
  message: |
    Finding triggers whenever there is a strcpy or strncpy used.
    This is an issue because strcpy or strncpy can lead to buffer overflow vulns.
    Fix this by using strcpy_s instead.
  metadata:
    references:
    - https://cwe.mitre.org/data/definitions/676
    - https://nvd.nist.gov/vuln/detail/CVE-2019-11365
  languages:
  - c
  severity: WARNING
- id: c.lang.security.insecure-use-strtok-fn.insecure-use-strtok-fn
  pattern: strtok(...)
  message: |
    Avoid using 'strtok()'. This function directly modifies the first argument buffer, permanently erasing the
    delimiter character. Use 'strtok_r()' instead.
  metadata:
    references:
    - https://wiki.sei.cmu.edu/confluence/display/c/STR06-C.+Do+not+assume+that+strtok%28%29+leaves+the+parse+string+unchanged
    - https://man7.org/linux/man-pages/man3/strtok.3.html#BUGS
    - https://stackoverflow.com/a/40335556
  languages:
  - c
  severity: ERROR
- id: c.lang.security.double-free.double-free
  patterns:
  - pattern: |
      free($VAR);
      ...
      free($VAR);
  - pattern-not: |
      free($VAR);
      ...
      $VAR = NULL;
      ...
      free($VAR);
  - pattern-not: |
      free($VAR);
      ...
      $VAR = malloc(...);
      ...
      free($VAR);
  message: |
    Variable '$VAR' was freed twice. This can lead to undefined behavior.
  metadata:
    references:
    - https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory
  languages:
  - c
  severity: ERROR
- id: c.lang.security.use-after-free.use-after-free
  pattern-either:
  - patterns:
    - pattern: |
        free($VAR);
        ...
        $VAR->$FUNC(...);
    - pattern-not: |
        free($VAR);
        ...
        $VAR = NULL;
        ...
        $VAR->$FUNC(...);
  - patterns:
    - pattern: |
        free($VAR);
        ...
        $FUNC(..., $VAR->$MEMBER, ...);
    - pattern-not: |
        free($VAR);
        ...
        $VAR = NULL;
        ...
        $FUNC(..., $VAR->$MEMBER, ...);
  message: |
    Variable '$VAR' was used after being freed. This can lead to undefined behavior.
  metadata:
    references:
    - https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/use_after_free/
  languages:
  - c
  severity: ERROR
- id: c.lang.security.random-fd-exhaustion.random-fd-exhaustion
  pattern-either:
  - patterns:
    - pattern: |
        $FD = open("/dev/urandom", ...);
        ...
        read($FD, ...);
    - pattern-not: |
        $FD = open("/dev/urandom", ...);
        ...
        $BYTES_READ = read($FD, ...);
  - patterns:
    - pattern: |
        $FD = open("/dev/random", ...);
        ...
        read($FD, ...);
    - pattern-not: |
        $FD = open("/dev/random", ...);
        ...
        $BYTES_READ = read($FD, ...);
  message: |
    Call to 'read()' without error checking is susceptible to file descriptor
    exhaustion. Consider using the 'getrandom()' function.
  metadata:
    references:
    - https://lwn.net/Articles/606141/
  languages:
  - c
  severity: ERROR
- id: go.grpc.security.grpc-client-insecure-connection.grpc-client-insecure-connection
  metadata:
    cwe: 'CWE-300: Channel Accessible by Non-Endpoint'
    references:
    - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
  message: 'Found an insecure gRPC connection using ''grpc.WithInsecure()''. This
    creates a connection without encryption to a gRPC server. A malicious attacker
    could tamper with the gRPC message, which could compromise the machine. Instead,
    establish a secure connection with an SSL certificate using the ''grpc.WithTransportCredentials()''
    function. You can create a create credentials using a ''tls.Config{}'' struct
    with ''credentials.NewTLS()''. The final fix looks like this: ''grpc.WithTransportCredentials(credentials.NewTLS(<config>))''.'
  languages:
  - go
  severity: ERROR
  pattern: $GRPC.Dial($ADDR, ..., $GRPC.WithInsecure(...), ...)
  fix-regex:
    regex: (.*)WithInsecure\(.*?\)
    replacement: \1WithTransportCredentials(credentials.NewTLS(<your_tls_config_here>))
- id: go.grpc.security.grpc-server-insecure-connection.grpc-server-insecure-connection
  metadata:
    cwe: 'CWE-300: Channel Accessible by Non-Endpoint'
    references:
    - https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption
  message: Found an insecure gRPC server without 'grpc.Creds()' or options with credentials.
    This allows for a connection without encryption to this server. A malicious attacker
    could tamper with the gRPC message, which could compromise the machine. Include
    credentials derived from an SSL certificate in order to create a secure gRPC connection.
    You can create credentials using 'credentials.NewServerTLSFromFile("cert.pem",
    "cert.key")'.
  languages:
  - go
  severity: ERROR
  patterns:
  - pattern-not: grpc.NewServer(..., grpc.Creds(...), ...)
  - pattern-not-inside: |
      $OPTS := []grpc.ServerOption{
        ...,
        grpc.Creds(credentials.NewClientTLSFromCert(...)),
        ...,
      }
      grpc.NewServer($OPTS...)
  - pattern-not-inside: |
      $CREDS := credentials.NewClientTLSFromCert(...)
      ...
      $OPTS := []grpc.ServerOption{
        ...,
        $CREDS,
        ...,
      }
      grpc.NewServer($OPTS...)
  - pattern: grpc.NewServer(...)
- id: go.jwt-go.security.jwt.hardcoded-jwt-key
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
  pattern-either:
  - pattern: |
      $X = []byte("...")
      ...
      $Y := $TOKEN.SignedString($X)
  - pattern: |
      $TOKEN.SignedString([]byte("..."))
  message: JWT token is hardcoded
  languages:
  - go
  severity: WARNING
- id: go.lang.security.audit.crypto.bad_imports.insecure-module-used
  message: Detected use of an insecure cryptographic hashing method. This method is
    known to be broken and easily compromised. Use SHA256 or SHA3 instead.
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://godoc.org/golang.org/x/crypto/sha3
  languages:
  - go
  severity: WARNING
  pattern-either:
  - patterns:
    - pattern-inside: |
        import "crypto/md5"
        ...
    - pattern: |
        md5.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "crypto/des"
        ...
    - pattern: |
        des.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "crypto/sha1"
        ...
    - pattern: |
        sha1.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "crypto/rc4"
        ...
    - pattern: |
        rc4.$FUNC(...)
  - patterns:
    - pattern-inside: |
        import "net/http/cgi"
        ...
    - pattern: |
        cgi.$FUNC(...)
- id: go.lang.security.audit.crypto.insecure_ssh.avoid-ssh-insecure-ignore-host-key
  message: |
    Disabled host key verification detected. This allows man-in-the-middle
    attacks. Use the 'golang.org/x/crypto/ssh/knownhosts' package to do
    host key verification.
    See https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
    to learn more about the problem and how to fix it.
  metadata:
    cwe: 'CWE-322: Key Exchange without Entity Authentication'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/
    - https://gist.github.com/Skarlso/34321a230cf0245018288686c9e70b2d
  languages:
  - go
  severity: WARNING
  pattern: ssh.InsecureIgnoreHostKey()
- id: go.lang.security.audit.crypto.math_random.math-random-used
  metadata:
    cwe: 'CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation
  message: Do not use `math/rand`. Use `crypto/rand` instead.
  languages:
  - go
  severity: WARNING
  pattern-either:
  - patterns:
    - pattern-inside: |
        import mrand "math/rand"
        ...
    - pattern-either:
      - pattern: mrand.Int()
      - pattern: mrand.Read(...)
  - patterns:
    - pattern-inside: |
        import "math/rand"
        ...
    - pattern-not-inside: |
        import "crypto/rand"
        ...
    - pattern-either:
      - pattern: rand.Int()
      - pattern: rand.Read(...)
- id: go.lang.security.audit.crypto.ssl.ssl-v3-is-insecure
  message: |
    SSLv3 is insecure because it has known vulnerabilities.
    Starting with go1.14, SSLv3 will be removed. Instead, use
    'tls.VersionTLS13'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls_config.go
    references:
    - https://golang.org/doc/go1.14#crypto/tls
    - https://www.us-cert.gov/ncas/alerts/TA14-290A
  languages:
  - go
  severity: ERROR
  patterns:
  - pattern: 'tls.Config{..., MinVersion: $TLS.VersionSSL30, ...}'
  fix-regex:
    regex: VersionSSL30
    replacement: VersionTLS13
- id: go.lang.security.audit.crypto.tls.tls-with-insecure-cipher
  message: |
    Detected an insecure CipherSuite via the 'tls' module. This suite is considered weak.
    Use the function 'tls.CipherSuites()' to get a list of good cipher suites.
    See https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
    for why and what other cipher suites to use.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/securego/gosec/blob/master/rules/tls.go
    references:
    - https://golang.org/pkg/crypto/tls/#InsecureCipherSuites
  languages:
  - go
  severity: WARNING
  pattern-either:
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,...}}
  - pattern: |
      tls.CipherSuite{..., TLS_RSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_RSA_WITH_AES_128_CBC_SHA256 ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_RC4_128_SHA ,...}
  - pattern: |
      tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 ,...}
  - pattern: tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 ,...}
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-DES
  message: |
    Detected DES cipher algorithm which is insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
  pattern-either:
  - pattern: |
      des.NewTripleDESCipher(...)
  - pattern: |
      des.NewCipher(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-md5
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
  pattern-either:
  - pattern: |
      md5.New()
  - pattern: |
      md5.Sum(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-rc4
  message: |
    Detected RC4 cipher algorithm which is insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
  pattern: rc4.NewCipher(...)
- id: go.lang.security.audit.crypto.use_of_weak_crypto.use-of-sha1
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - go
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://github.com/securego/gosec#available-rules
  pattern-either:
  - pattern: |
      sha1.New()
  - pattern: |
      sha1.Sum(...)
- id: go.lang.security.audit.database.string-formatted-query.string-formatted-query
  languages:
  - go
  message: |
    String-formatted SQL query detected. This could lead to SQL injection if
    the string is not sanitized properly. Audit this call to ensure the
    SQL is not manipulatable by external data.
  severity: WARNING
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    source-rule-url: https://github.com/securego/gosec
  patterns:
  - pattern-either:
    - pattern: $OBJ.Exec("..." + $X)
    - pattern: $OBJ.ExecContext($CTX, "..." + $X)
    - pattern: $OBJ.Query("..." + $X)
    - pattern: $OBJ.QueryContext($CTX, "..." + $X)
    - pattern: $OBJ.QueryRow("..." + $X)
    - pattern: $OBJ.QueryRow($CTX, "..." + $X)
    - pattern: $OBJ.QueryRowContext($CTX, "..." + $X)
    - pattern: $OBJ.Exec(fmt.$P("...", ...))
    - pattern: $OBJ.ExecContext($CTX, fmt.$P("...", ...))
    - pattern: $OBJ.Query(fmt.$P("...", ...))
    - pattern: $OBJ.QueryContext($CTX, fmt.$P("...", ...))
    - pattern: $OBJ.QueryRow(fmt.$P("...", ...))
    - pattern: $OBJ.QueryRow($CTX, fmt.$P("...", ...))
    - pattern: $OBJ.QueryRowContext($CTX, fmt.$P("...", ...))
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.Exec($QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.Query($QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.ExecContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRow($QUERY)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRow($CTX, $QUERY)
    - pattern: |
        $QUERY = "..."
        ...
        $QUERY = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRowContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.Exec($OTHER, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.Query($OTHER, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.ExecContext($CTX, $OTHER, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryContext($CTX, $OTHER, ...)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRow($OTHER)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRow($CTX, $OTHER)
    - pattern: |
        $QUERY = "..."
        ...
        $OTHER = $FXN(..., $QUERY, ...)
        ...
        $OBJ.QueryRowContext($CTX, $OTHER, ...)
    - pattern: |
        $QUERY = "..." + $X
        ...
        $OBJ.Exec($QUERY, ...)
    - pattern: |
        $QUERY = "..." + $X
        ...
        $OBJ.Query($QUERY, ...)
    - pattern: |
        $QUERY = "..." + $X
        ...
        $OBJ.ExecContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = "..." + $X
        ...
        $OBJ.QueryContext($CTX, $QUERY, ...)
    - pattern: |
        $QUERY = "..." + $X
        ...
        $OBJ.QueryRow($QUERY)
    - pattern: |
        $QUERY = "..." + $X
        ...
        $OBJ.QueryRow($CTX, $QUERY)
    - pattern: |
        $QUERY = "..." + $X
        ...
        $OBJ.QueryRowContext($CTX, $QUERY, ...)
- id: go.lang.security.audit.net.bind_all.avoid-bind-to-all-interfaces
  message: Listening on 0.0.0.0 or empty string could unexpectedly expose the server
    publicly as it binds to all available interfaces
  languages:
  - go
  severity: WARNING
  metadata:
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/securego/gosec
  pattern-either:
  - pattern: tls.Listen($NETWORK, "=~/^0.0.0.0:.*$/", ...)
  - pattern: net.Listen($NETWORK, "=~/^0.0.0.0:.*$/", ...)
  - pattern: tls.Listen($NETWORK, "=~/^:.*$/", ...)
  - pattern: net.Listen($NETWORK, "=~/^:.*$/", ...)
- id: go.lang.security.audit.net.dynamic-httptrace-clienttrace.dynamic-httptrace-clienttrace
  message: |
    Detected a potentially dynamic ClientTrace. This occurred because semgrep could not
    find a static definition for '$TRACE'. Dynamic ClientTraces are dangerous because
    they deserialize function code to run when certain Request events occur, which could lead
    to code being run without your knowledge. Ensure that your ClientTrace is statically defined.
  metadata:
    cwe: 'CWE-913: Improper Control of Dynamically-Managed Code Resources'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://github.com/returntocorp/semgrep-rules/issues/518
  patterns:
  - pattern-not-inside: |
      ...
      &httptrace.ClientTrace { ... }
      ...
  - pattern: httptrace.WithClientTrace($ANY, $TRACE)
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.net.formatted-template-string.formatted-template-string
  message: |
    Found a formatted template string passed to 'template.HTML()'.
    'template.HTML()' does not escape contents. Be absolutely sure
    there is no user-controlled data in this template. If user data
    can reach this template, you may have a XSS vulnerability.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A1: Injection'
    references:
    - https://golang.org/pkg/html/template/#HTML
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-not: template.HTML("..." + "...")
  - pattern-either:
    - pattern: template.HTML($T + $X, ...)
    - pattern: template.HTML(fmt.$P("...", ...), ...)
    - pattern: |
        $T = "..."
        ...
        $T = $FXN(..., $T, ...)
        ...
        template.HTML($T, ...)
    - pattern: |
        $T = fmt.$P("...", ...)
        ...
        template.HTML($T, ...)
    - pattern: |
        $T, $ERR = fmt.$P("...", ...)
        ...
        template.HTML($T, ...)
    - pattern: |
        $T = $X + $Y
        ...
        template.HTML($T, ...)
    - pattern: |
        $T = "..."
        ...
        $OTHER, $ERR = fmt.$P(..., $T, ...)
        ...
        template.HTML($OTHER, ...)
- id: go.lang.security.audit.net.pprof.pprof-debug-exposure
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/securego/gosec#available-rules
    references:
    - https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
  message: |
    The profiling 'pprof' endpoint is automatically exposed on /debug/pprof.
    This could leak information about the server.
    Instead, use `import "net/http/pprof"`. See
    https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/
    for more information and mitigation.
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-inside: |
      import _ "net/http/pprof"
      ...
  - pattern-inside: |
      func $ANY(...) {
        ...
      }
  - pattern-not: http.ListenAndServe("=~/^localhost.*/", ...)
  - pattern-not: http.ListenAndServe("=~/^127[.]0[.]0[.]1.*/", ...)
  - pattern: http.ListenAndServe(...)
- id: go.lang.security.audit.net.unescaped-data-in-htmlattr.unescaped-data-in-htmlattr
  message: |
    Found a formatted template string passed to 'template.HTMLAttr()'.
    'template.HTMLAttr()' does not escape contents. Be absolutely sure
    there is no user-controlled data in this template.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A1: Injection'
    references:
    - https://golang.org/pkg/html/template/#HTMLAttr
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern: template.HTMLAttr($T + $X, ...)
    - pattern: template.HTMLAttr(fmt.$P("...", ...), ...)
    - pattern: |
        $T = "..."
        ...
        $T = $FXN(..., $T, ...)
        ...
        template.HTMLAttr($T, ...)
    - pattern: |
        $T = fmt.$P("...", ...)
        ...
        template.HTMLAttr($T, ...)
    - pattern: |
        $T, $ERR = fmt.$P("...", ...)
        ...
        template.HTMLAttr($T, ...)
    - pattern: |
        $T = $X + $Y
        ...
        template.HTMLAttr($T, ...)
    - pattern: |
        $T = "..."
        ...
        $OTHER, $ERR = fmt.$P(..., $T, ...)
        ...
        template.HTMLAttr($OTHER, ...)
- id: go.lang.security.audit.net.unescaped-data-in-js.unescaped-data-in-js
  message: |
    Found a formatted template string passed to 'template.JS()'.
    'template.JS()' does not escape contents. Be absolutely sure
    there is no user-controlled data in this template.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A1: Injection'
    references:
    - https://golang.org/pkg/html/template/#JS
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern: template.JS($T + $X, ...)
    - pattern: template.JS(fmt.$P("...", ...), ...)
    - pattern: |
        $T = "..."
        ...
        $T = $FXN(..., $T, ...)
        ...
        template.JS($T, ...)
    - pattern: |
        $T = fmt.$P("...", ...)
        ...
        template.JS($T, ...)
    - pattern: |
        $T, $ERR = fmt.$P("...", ...)
        ...
        template.JS($T, ...)
    - pattern: |
        $T = $X + $Y
        ...
        template.JS($T, ...)
    - pattern: |
        $T = "..."
        ...
        $OTHER, $ERR = fmt.$P(..., $T, ...)
        ...
        template.JS($OTHER, ...)
- id: go.lang.security.audit.net.unescaped-data-in-url.unescaped-data-in-url
  message: |
    Found a formatted template string passed to 'template.URL()'.
    'template.URL()' does not escape contents. Be absolutely sure
    there is no user-controlled data in this template.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A1: Injection'
    references:
    - https://golang.org/pkg/html/template/#URL
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern: template.URL($T + $X, ...)
    - pattern: template.URL(fmt.$P("...", ...), ...)
    - pattern: |
        $T = "..."
        ...
        $T = $FXN(..., $T, ...)
        ...
        template.URL($T, ...)
    - pattern: |
        $T = fmt.$P("...", ...)
        ...
        template.URL($T, ...)
    - pattern: |
        $T, $ERR = fmt.$P("...", ...)
        ...
        template.URL($T, ...)
    - pattern: |
        $T = $X + $Y
        ...
        template.URL($T, ...)
    - pattern: |
        $T = "..."
        ...
        $OTHER, $ERR = fmt.$P(..., $T, ...)
        ...
        template.URL($OTHER, ...)
- id: go.lang.security.audit.net.use-tls.use-tls
  pattern: http.ListenAndServe($ADDR, $HANDLER)
  fix: http.ListenAndServeTLS($ADDR, certFile, keyFile, $HANDLER)
  metadata:
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://golang.org/pkg/net/http/#ListenAndServeTLS
  message: Found an HTTP server without TLS. Use 'http.ListenAndServeTLS' instead.
    See https://golang.org/pkg/net/http/#ListenAndServeTLS for more information.
  languages:
  - go
  severity: WARNING
- id: go.lang.security.audit.net.wip-xss-using-responsewriter-and-printf.wip-xss-using-responsewriter-and-printf
  patterns:
  - pattern-inside: |
      func $FUNC(..., $W http.ResponseWriter, ...) {
          ...
      }
  - pattern-inside: |
      ...
      var $T = "..."
      ...
      $W.Write([]byte(fmt.$PRINTF($T, ...)), ...)
  - pattern-either:
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $INTERM = $ANYTHING(..., $DATA, ...)
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $INTERM = $DATA[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $DATA, $ERR := r.URL.Query()[...]
        ...
        $INTERM = $DATA[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $DATA, $ERR := r.URL.Query()[...]
        ...
        $INTERM = $ANYTHING(..., $DATA, ...)
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))
    - pattern: |
        $PARAMS = r.URL.Query()
        ...
        $DATA, $ERR := $PARAMS[...]
        ...
        $W.Write([]byte(fmt.$PRINTF(..., $DATA, ...)))
  message: |
    Found data going from url query parameters into formatted data written to ResponseWriter.
    This could be XSS and should not be done. If you must do this, ensure your data is
    sanitized or escaped.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (''XSS'')'
  severity: WARNING
  languages:
  - go
- id: go.lang.security.audit.reflect-makefunc.reflect-makefunc
  message: |
    'reflect.MakeFunc' detected. This will sidestep protections that are
    normally afforded by Go's type system. Audit this call and be sure that
    user input cannot be used to affect the code generated by MakeFunc;
    otherwise, you will have a serious security vulnerability.
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-913: Improper Control of Dynamically-Managed Code Resources'
  severity: WARNING
  pattern: reflect.MakeFunc(...)
  languages:
  - go
- id: go.lang.security.audit.unsafe.use-of-unsafe-block
  message: Using the unsafe package in Go gives you low-level memory management and
    many of the strengths of the C language but also gives flexibility to the attacker
    of your application.
  languages:
  - go
  severity: WARNING
  metadata:
    cwe: 'CWE-242: Use of Inherently Dangerous Function'
    source_rule_url: https://github.com/securego/gosec/blob/master/rules/unsafe.go
  patterns:
  - pattern: unsafe.$FUNC(...)
- id: go.lang.security.bad_tmp.bad-tmp-file-creation
  message: File creation in shared tmp directory without using ioutil.Tempfile
  languages:
  - go
  severity: WARNING
  metadata:
    cwe: 'CWE-377: Insecure Temporary File'
    source_rule_url: https://github.com/securego/gosec
  pattern-either:
  - pattern: ioutil.WriteFile("=~//tmp/.*$/", ...)
  - pattern: os.Create("=~//tmp/.*$/", ...)
- id: go.lang.security.decompression_bomb.potential-dos-via-decompression-bomb
  message: Detected a possible denial-of-service via a zip bomb attack. By limiting
    the max bytes read, you can mitigate this attack. `io.CopyN()` can specify a size.
    Refer to https://bomb.codes/ to learn more about this attack and other ways to
    mitigate it.
  severity: WARNING
  languages:
  - go
  patterns:
  - pattern-either:
    - pattern: io.Copy(...)
    - pattern: io.CopyBuffer(...)
  - pattern-either:
    - pattern-inside: |
        gzip.NewReader(...)
        ...
    - pattern-inside: |
        zlib.NewReader(...)
        ...
    - pattern-inside: |
        zlib.NewReaderDict(...)
        ...
    - pattern-inside: |
        bzip2.NewReader(...)
        ...
    - pattern-inside: |
        flate.NewReader(...)
        ...
    - pattern-inside: |
        flate.NewReaderDict(...)
        ...
    - pattern-inside: |
        lzw.NewReader(...)
        ...
    - pattern-inside: |
        tar.NewReader(...)
        ...
    - pattern-inside: |
        zip.NewReader(...)
        ...
    - pattern-inside: |
        zip.OpenReader(...)
        ...
  fix-regex:
    regex: (.*)(Copy|CopyBuffer)\((.*?),(.*?)(\)|,.*\))
    replacement: \1CopyN(\3, \4, 1024*1024*256)
  metadata:
    cwe: 'CWE-400: Uncontrolled Resource Consumption'
    source-rule-url: https://github.com/securego/gosec
    references:
    - https://bomb.codes/
    - https://golang.org/pkg/io/#CopyN
    - https://github.com/securego/gosec/blob/master/rules/decompression-bomb.go
- id: go.lang.security.zip.path-traversal-inside-zip-extraction
  message: File traversal when extracting zip archive
  metadata:
    cwe: |
      CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
    source_rule_url: https://github.com/securego/gosec/issues/205
  languages:
  - go
  severity: WARNING
  patterns:
  - pattern: |-
      reader, $ERR := zip.OpenReader($ARCHIVE)
      ...
      for _, $FILE := range reader.File {
        ...
        path := filepath.Join($TARGET, $FILE.Name)
        ...
      }
- id: go.otto.security.audit.dangerous-execution.dangerous-execution
  message: |
    Detected non-static script inside otto VM. Audit the input to 'VM.Run'.
    If unverified user data can reach this call site, this is a code injection
    vulnerability. A malicious actor can inject a malicious script to execute
    arbitrary code.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
  severity: WARNING
  patterns:
  - pattern-inside: |
      $VM = otto.New(...)
      ...
  - pattern-not: $VM.Run("...", ...)
  - pattern: $VM.Run(...)
  languages:
  - go
- id: java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
    references:
    - https://www.owasp.org/index.php/Path_Traversal
  message: |
    Detected a potential path traversal. A malicious actor
    could control the location of this file, to include going backwards
    in the directory with '../'. To address this, ensure that user-controlled
    variables in file paths are sanitized. You may aslso consider using a utility
    method such as org.apache.commons.io.FilenameUtils.getName(...) to only
    retrieve the file name from the path.
  patterns:
  - pattern-either:
    - pattern: |
        $RETURNTYPE $FUNC (..., @PathParam(...) $TYPE $VAR, ...) {
          ...
          new File(..., $VAR, ...);
          ...
        }
    - pattern: |-
        $RETURNTYPE $FUNC (..., @javax.ws.rs.PathParam(...) $TYPE $VAR, ...) {
          ...
          new File(..., $VAR, ...);
          ...
        }
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind
  metadata:
    cwe: 'CWE-287: Improper Authentication'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#LDAP_ANONYMOUS
  message: |
    Detected anonymous LDAP bind.
    This permits anonymous users to execute LDAP statements. Consider enforcing
    authentication for LDAP. See https://docs.oracle.com/javase/tutorial/jndi/ldap/auth_mechs.html
    for more information.
  severity: WARNING
  pattern: |
    $ENV.put($CTX.SECURITY_AUTHENTICATION, "none");
    ...
    $DCTX = new InitialDirContext($ENV, ...);
  languages:
  - java
- id: java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion
  metadata:
    cwe: 'CWE-704: Incorrect Type Conversion or Cast'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#BAD_HEXA_CONVERSION
  message: |
    'Integer.toHexString()' strips leading zeroes from each byte if read byte-by-byte.
    This mistake weakens the hash value computed since it introduces more collisions.
    Use 'String.format("%02X", ...)' instead.
  severity: WARNING
  languages:
  - java
  pattern: |-
    $X $METHOD(...) {
      ...
      MessageDigest $MD = ...;
      ...
      $MD.digest(...);
      ...
      Integer.toHexString(...);
    }
- id: java.lang.security.audit.cbc-padding-oracle.cbc-padding-oracle
  message: |
    Using CBC with PKCS5Padding is susceptible to padding orcale attacks. A malicious actor
    could discern the difference between plaintext with valid or invalid padding. Further,
    CBC mode does not include any integrity checks. See https://find-sec-bugs.github.io/bugs.htm#CIPHER_INTEGRITY.
    Use 'AES/GCM/NoPadding' instead.
  metadata:
    cwe: 'CWE-696: Incorrect Behavior Order'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PADDING_ORACLE
    references:
    - https://capec.mitre.org/data/definitions/463.html
  severity: WARNING
  patterns:
  - pattern: $CIPHER.getInstance("=~/.*\/CBC\/PKCS5Padding/");
  fix: $CIPHER.getInstance("AES/GCM/NoPadding");
  languages:
  - java
- id: java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call
  patterns:
  - pattern-either:
    - pattern: $RUNTIME.exec($X + $Y);
    - pattern: $RUNTIME.exec(String.format(...));
    - pattern: $RUNTIME.loadLibrary($X + $Y);
    - pattern: $RUNTIME.loadLibrary(String.format(...));
  message: |
    A formatted or concatenated string was detected as input to a java.lang.Runtime call.
    This is dangerous if a variable is controlled by user input and could result in a
    command injection. Ensure your variables are not controlled by users or sufficiently sanitized.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly
  metadata:
    cwe: 'CWE-1004: Sensitive Cookie Without ''HttpOnly'' Flag'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#HTTPONLY_COOKIE
  message: |
    A cookie was detected without setting the 'HttpOnly' flag. The 'HttpOnly' flag
    for cookies instructs the browser to forbid client-side scripts from reading the
    cookie. Set the 'HttpOnly' flag by calling 'cookie.setHttpOnly(true);'
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-not-inside: $COOKIE.setValue(""); ...
  - pattern-either:
    - pattern: $COOKIE.setHttpOnly(false);
    - patterns:
      - pattern-not-inside: $COOKIE.setHttpOnly(...); ...
      - pattern: $RESPONSE.addCookie($COOKIE);
- id: java.lang.security.audit.cookie-missing-samesite.cookie-missing-samesite
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://stackoverflow.com/questions/42717210/samesite-cookie-in-java-application
  message: |
    Detected cookie without the SameSite attribute.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-not-inside: |
      $RETURNTYPE $METHOD(..., HttpServletResponse $RESP, ...) {
        ...
        $RESP.setHeader("Set-Cookie", "=~/.*SameSite=.*/");
        ...
      }
  - pattern-either:
    - pattern: $RESP.addCookie(...);
    - pattern: $RESP.setHeader("Set-Cookie", ...);
- id: java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag
  metadata:
    cwe: 'CWE-614: Sensitive Cookie in HTTPS Session Without ''Secure'' Attribute'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_COOKIE
  message: |
    A cookie was detected without setting the 'secure' flag. The 'secure' flag
    for cookies prevents the client from transmitting the cookie over insecure
    channels such as HTTP. Set the 'secure' flag by calling '$COOKIE.setSecure(true);'
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-not-inside: $COOKIE.setValue(""); ...
  - pattern-either:
    - pattern: $COOKIE.setSecure(false);
    - patterns:
      - pattern-not-inside: $COOKIE.setSecure(...); ...
      - pattern: $RESPONSE.addCookie($COOKIE);
- id: java.lang.security.audit.crlf-injection-logs.crlf-injection-logs
  message: |
    When data from an untrusted source is put into a logger and not neutralized correctly,
    an attacker could forge log entries or include malicious content.
  metadata:
    cwe: 'CWE-93: Improper Neutralization of CRLF Sequences (''CRLF Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#CRLF_INJECTION_LOGS
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          class $CLASS {
            ...
            Logger $LOG = ...;
            ...
          }
      - pattern-either:
        - pattern-inside: |
            $X $METHOD(...,HttpServletRequest $REQ,...) {
              ...
            }
        - pattern-inside: |
            $X $METHOD(...,ServletRequest $REQ,...) {
              ...
            }
        - pattern-inside: |
            $X $METHOD(...) {
              ...
              HttpServletRequest $REQ = ...;
              ...
            }
        - pattern-inside: |
            $X $METHOD(...) {
              ...
              ServletRequest $REQ = ...;
              ...
            }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          Logger $LOG = ...;
          ...
          HttpServletRequest $REQ = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          Logger $LOG = ...;
          ...
          ServletRequest $REQ = ...;
          ...
        }
  - pattern-either:
    - pattern: |
        String $VAL = $REQ.getParameter(...);
        ...
        $LOG.$LEVEL(<... $VAL ...>);
    - pattern: |
        String $VAL = $REQ.getParameter(...);
        ...
        $LOG.log($LEVEL,<... $VAL ...>);
    - pattern: |
        $LOG.$LEVEL(<... $REQ.getParameter(...) ...>);
    - pattern: |
        $LOG.log($LEVEL,<... $REQ.getParameter(...) ...>);
- id: java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated
  message: |
    DES is considered deprecated. AES is the recommended cipher.
    Upgrade to use AES.
    See https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard for more information.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DES_USAGE
    references:
    - https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard
  severity: WARNING
  pattern: $CIPHER.getInstance("=~/DES/.*/");
  fix: $CIPHER.getInstance("AES/GCM/NoPadding");
  languages:
  - java
- id: java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated
  message: |
    Triple DES (3DES or DESede) is considered deprecated. AES is the recommended cipher.
    Upgrade to use AES.
    See https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA for more information.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE
    references:
    - https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA
  severity: WARNING
  pattern: $CIPHER.getInstance("=~/DESede.*/");
  fix: Cipher.getInstance("AES/GCM/NoPadding");
  languages:
  - java
- id: java.lang.security.audit.crypto.no-null-cipher.no-null-cipher
  pattern: new NullCipher(...);
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#NULL_CIPHER
  message: |
    NullCipher was detected. This will not encrypt anything;
    the cipher text will be the same as the plain text. Use
    a valid, secure cipher: Cipher.getInstance("AES/CBC/PKCS7PADDING").
    See https://owasp.org/www-community/Using_the_Java_Cryptographic_Extensions
    for more information.
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector
  message: |
    Initialization Vectors (IVs) for block ciphers should be randomly generated
    each time they are used. Using a static IV means the same plaintext
    encrypts to the same ciphertext every time, weakening the strength
    of the encryption.
  metadata:
    cwe: 'CWE-329: Not Using a Random IV with CBC Mode'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#STATIC_IV
    references:
    - https://cwe.mitre.org/data/definitions/329.html
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern: |
        byte[] $IV = {
            ...
        };
        ...
        new IvParameterSpec($IV, ...);
    - pattern: |
        class $CLASS {
            byte[] $IV = {
                ...
            };
            ...
            $METHOD(...) {
                ...
                new IvParameterSpec($IV, ...);
                ...
            }
        }
- id: java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitve Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#RSA_NO_PADDING
    references: https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/
  message: |
    Using RSA without OAEP mode weakens the encryption.
  severity: WARNING
  languages:
  - java
  pattern: $CIPHER.getInstance("RSA/NONE/NoPadding")
- id: java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#CUSTOM_MESSAGE_DIGEST
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#custom-algorithms
  message: |
    Cryptographic algorithms are notoriously difficult to get right. By implementing
    a custom message digest, you risk introducing security issues into your program.
    Use one of the many sound message digests already available to you:
    MessageDigest sha256Digest = MessageDigest.getInstance("SHA256");
  severity: WARNING
  languages:
  - java
  pattern: |-
    class $CLASS extends MessageDigest {
      ...
    }
- id: java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#DEFAULT_HTTP_CLIENT
  message: |
    DefaultHttpClient is deprecated. Further, it does not support connections
    using TLS1.2, which makes using DefaultHttpClient a security hazard.
    Use SystemDefaultHttpClient instead, which supports TLS1.2.
  severity: WARNING
  languages:
  - java
  pattern: new DefaultHttpClient(...);
  fix-regex:
    regex: DefaultHttpClient
    replacement: SystemDefaultHttpClient
- id: java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier
  message: |
    Insecure HostnameVerifier implementation detected. This will accept
    any SSL certificate with any hostname, which creates the possibility
    for man-in-the-middle attacks.
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern: |
        class $CLASS implements HostnameVerifier {
          ...
          public boolean verify(...) { return true; }
        }
    - pattern: |-
        new HostnameVerifier(...){
          public boolean verify(...) {
            return true;
          }
        }
- id: java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER
    references:
    - https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
  message: |
    Detected empty trust manager implementations. This is dangerous because it accepts any
    certificate, enabling man-in-the-middle attacks. Consider using a KeyStore
    and TrustManagerFactory isntead.
    See https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https
    for more information.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern-inside: |
        class $CLASS implements X509TrustManager {
          ...
        }
    - pattern-inside: |
        new X509TrustManager() {
          ...
        }
    - pattern-inside: |
        class $CLASS implements X509ExtendedTrustManager {
          ...
        }
    - pattern-inside: |
        new X509ExtendedTrustManager() {
          ...
        }
  - pattern-not: public void checkClientTrusted(...) { $SOMETHING; }
  - pattern-not: public void checkServerTrusted(...) { $SOMETHING; }
  - pattern-either:
    - pattern: public void checkClientTrusted(...) {}
    - pattern: public void checkServerTrusted(...) {}
    - pattern: public X509Certificate[] getAcceptedIssuers(...) { return null; }
- id: java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket
  metadata:
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNENCRYPTED_SOCKET
  message: |
    This socket is not encrypted.
    The traffic could be read by an attacker intercepting the network traffic.
    Use an SSLSocket created by 'SSLSocketFactory' or 'SSLServerSocketFactory'
    instead
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: new ServerSocket(...)
  - pattern: new Socket(...)
- id: java.lang.security.audit.crypto.weak-hash.use-of-md5
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - java
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5
  pattern-either:
  - pattern: |
      MessageDigest $VAR = $MD.getInstance("MD5");
  - pattern: |
      $DU.getMd5Digest().digest(...)
- id: java.lang.security.audit.crypto.weak-hash.use-of-sha1
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  languages:
  - java
  severity: WARNING
  metadata:
    owasp: 'A9: Using Components with Known Vulnerabilities'
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_SHA1
  pattern-either:
  - pattern: |
      MessageDigest $VAR = $MD.getInstance("SHA1");
  - pattern: |
      $DU.getSha1Digest().digest(...)
- id: java.lang.security.audit.el-injection.el-injection
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION
  message: |
    An expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern: |
        class $CLASS {
          ...
          ExpressionFactory $EF;
          ...
          $X $METHOD(...) {
            ...
            $EF.createValueExpression($CTX,$INPUT,...);
            ...
          }
          ...
        }
    - pattern: |
        class $CLASS {
          ...
          ExpressionFactory $EF = ...;
          ...
          $X $METHOD(...) {
            ...
            $EF.createValueExpression($CTX,$INPUT,...);
            ...
          }
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ExpressionFactory $EF = ...;
          ...
          $EF.createValueExpression($CTX,$INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ExpressionFactory $EF,...) {
          ...
          $EF.createValueExpression($CTX,$INPUT,...);
          ...
        }
    - pattern: |
        class $CLASS {
          ...
          ExpressionFactory $EF;
          ...
          $X $METHOD(...) {
            ...
            $EF.createMethodExpression($CTX,$INPUT,...);
            ...
          }
          ...
        }
    - pattern: |
        class $CLASS {
          ...
          ExpressionFactory $EF = ...;
          ...
          $X $METHOD(...) {
            ...
            $EF.createMethodExpression($CTX,$INPUT,...);
            ...
          }
          ...
        }
    - pattern: |
        $X $METHOD(...) {
          ...
          ExpressionFactory $EF = ...;
          ...
          $EF.createMethodExpression($CTX,$INPUT,...);
          ...
        }
    - pattern: |
        $X $METHOD(...,ExpressionFactory $EF,...) {
          ...
          $EF.createMethodExpression($CTX,$INPUT,...);
          ...
        }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $EF.createValueExpression($CTX,"...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $EF.createValueExpression($CTX,$S,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $EF.createMethodExpression($CTX,"...",...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $EF.createMethodExpression($CTX,$S,...);
        ...
      }
- id: java.lang.security.audit.formatted-sql-string.formatted-sql-string
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
    - https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps
    - https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement
  message: |
    Detected a formatted string in a SQL statement. This could lead to SQL
    injection if variables in the SQL statement are not properly sanitized.
    Use a prepared statements (java.sql.PreparedStatement) instead. You
    can obtain a PreparedStatement using 'connection.prepareStatement'.
  patterns:
  - pattern-not: $W.execute(<... "=~/.*TABLE *$/" ...>);
  - pattern-not: $W.execute(<... "=~/.*TABLE %s$/" ...>);
  - pattern-either:
    - pattern: $W.execute($X + $Y, ...);
    - pattern: |
        String $SQL = $X + $Y;
        ...
        $W.execute($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += $Y;
        ...
        $W.execute($SQL, ...);
    - pattern: $W.execute(String.format($X, ...), ...);
    - pattern: |
        String $SQL = String.format($X, ...);
        ...
        $W.execute($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += String.format(...);
        ...
        $W.execute($SQL, ...);
    - pattern: $W.executeQuery($X + $Y, ...);
    - pattern: |
        String $SQL = $X + $Y;
        ...
        $W.executeQuery($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += $Y;
        ...
        $W.executeQuery($SQL, ...);
    - pattern: $W.executeQuery(String.format($X, ...), ...);
    - pattern: |
        String $SQL = String.format($X, ...);
        ...
        $W.executeQuery($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += String.format(...);
        ...
        $W.executeQuery($SQL, ...);
    - pattern: $W.createQuery($X + $Y, ...);
    - pattern: |
        String $SQL = $X + $Y;
        ...
        $W.createQuery($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += $Y;
        ...
        $W.createQuery($SQL, ...);
    - pattern: $W.createQuery(String.format($X, ...), ...);
    - pattern: |
        String $SQL = String.format($X, ...);
        ...
        $W.createQuery($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += String.format(...);
        ...
        $W.createQuery($SQL, ...);
    - pattern: $W.query($X + $Y, ...);
    - pattern: |
        String $SQL = $X + $Y;
        ...
        $W.query($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += $Y;
        ...
        $W.query($SQL, ...);
    - pattern: $W.query(String.format($X, ...), ...);
    - pattern: |
        String $SQL = String.format($X, ...);
        ...
        $W.query($SQL, ...);
    - pattern: |
        String $SQL = $X;
        ...
        $SQL += String.format(...);
        ...
        $W.query($SQL, ...);
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.http-response-splitting.http-response-splitting
  metadata:
    cwe: 'CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers (''HTTP
      Response Splitting'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#HTTP_RESPONSE_SPLITTING
    references:
    - https://www.owasp.org/index.php/HTTP_Response_Splitting
  message: |
    Older Java application servers are vulnreable to HTTP response splitting, which may occur if an HTTP
    request can be injected with CRLF characters. This finding is reported for completeness; it is recommended
    to ensure your environment is not affected by testing this yourself.
  severity: INFO
  patterns:
  - pattern-either:
    - pattern: |
        $VAR = $REQ.getParameter(...);
        ...
        $COOKIE = new Cookie(..., $VAR, ...);
        ...
        $RESP.addCookie($COOKIE, ...);
    - patterns:
      - pattern-inside: |
          $RETTYPE $FUNC(...,@PathVariable $TYPE $VAR, ...) {
            ...
          }
      - pattern: |
          $COOKIE = new Cookie(..., $VAR, ...);
          ...
          $RESP.addCookie($COOKIE, ...);
  languages:
  - java
- id: java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection
  metadata:
    cwe: 'CWE-297: Improper Validation of Certificate with Host Mismatch'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#INSECURE_SMTP_SSL
  message: |
    Insecure SMTP connection detected. This connection will trust any SSL certificate.
    Enable certificate verification by setting 'email.setSSLCheckServerIdentity(true)'.
  severity: WARNING
  patterns:
  - pattern-not-inside: |
      $EMAIL.setSSLCheckServerIdentity(true);
      ...
  - pattern-inside: |
      $EMAIL = new SimpleEmail(...);
      ...
  - pattern: $EMAIL.send(...);
  languages:
  - java
- id: java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION_SPRING_JDBC
  message: |
    Possible JDBC injection detected. Use the parameterized query
    feature available in queryForObject instead of concatenating or formatting strings:
    'jdbc.queryForObject("select * from table where name = ?", Integer.class, parameterName);'
  patterns:
  - pattern-inside: |
      $JDBC = new JdbcTemplate(...);
      ...
  - pattern-either:
    - pattern: $JDBC.queryForObject($STR + $VAR, ...);
    - pattern: $JDBC.queryForObject(String.format(...), ...);
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.queryForObject($Q, ...);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.queryForObject($Q, ...);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.queryForObject($Q, ...);
    - pattern: $JDBC.queryForList($STR + $VAR);
    - pattern: $JDBC.queryForList(String.format(...));
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.queryForList($Q);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.queryForList($Q);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.queryForList($Q, ...);
    - pattern: $JDBC.update($STR + $VAR);
    - pattern: $JDBC.update(String.format(...));
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.update($Q);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.update($Q);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.update($Q, ...);
    - pattern: $JDBC.execute($STR + $VAR);
    - pattern: $JDBC.execute(String.format(...));
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.execute($Q);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.execute($Q);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.execute($Q, ...);
    - pattern: $JDBC.insert($STR + $VAR);
    - pattern: $JDBC.insert(String.format(...));
    - pattern: |
        String $Q = $STR + $VAR;
        ...
        $JDBC.insert($Q);
    - pattern: |
        String $Q = String.format(...);
        ...
        $JDBC.insert($Q);
    - pattern: |
        StringBuilder $Q = new StringBuilder(...);
        ...
        $Q.append($STR + $VAR);
        ...
        $JDBC.insert($Q, ...);
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-90: Improper Neutralization of Special Elements used in an LDAP Query
      (''LDAP Injection'')'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#LDAP_ENTRY_POISONING
    references:
    - https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf
    - https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html
  message: |
    An object-returning LDAP search will allow attackers to control the LDAP response. This could
    lead to Remote Code Execution.
  severity: WARNING
  pattern-either:
  - pattern: |
      new SearchControls($S, $CL, $TL, $AT, true, $DEREF)
  - pattern: |
      SearchControls $VAR = new SearchControls();
      ...
      $VAR.setReturningObjFlag(true);
  languages:
  - java
- id: java.lang.security.audit.ldap-injection.ldap-injection
  message: |
    Detected non-constant data passed into an LDAP query. If this data can be
    controlled by an external user, this is an LDAP injection.
    Ensure data passed to an LDAP query is not controllable; or properly sanitize
    the data.
  metadata:
    cwe: 'CWE-90: Improper Neutralization of Special Elements used in an LDAP Query
      (''LDAP Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#LDAP_INJECTION
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          InitialDirContext $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          DirContext $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          InitialLdapContext $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          LdapContext $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          LdapCtx $CTX = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          EventDirContext $CTX = ...;
          ...
        }
  - pattern: |
      $X $METHOD(...) {
        ...
        $CTX.search($Y,$INPUT,...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $CTX.search($Y,"...",...);
        ...
      }
- id: java.lang.security.audit.object-deserialization.object-deserialization
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#OBJECT_DESERIALIZATION
    references:
    - https://www.owasp.org/index.php/Deserialization_of_untrusted_data
  message: |
    Found object deserialization using ObjectInputStream. Deserializing entire
    Java objects is dangerous because malicious actors can create Java object
    streams with unintended consequences. Ensure that the objects being deserialized
    are not user-controlled. If this must be done, consider using HMACs to sign
    the data stream to make sure it is not tampered with, or consider only
    transmitting object fields and populating a new object.
  patterns:
  - pattern: new ObjectInputStream(...);
  severity: WARNING
  languages:
  - java
- id: java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission
  message: |
    It is generally a bad practices to set overly permissive file permission such as read+write+exec for all users.
    If the file affected is a configuration, a binary, a script or sensitive data, it can lead to privilege escalation or information leakage.
  severity: WARNING
  languages:
  - java
  metadata:
    cwe: 'CWE-276: Incorrect Default Permissions'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#OVERLY_PERMISSIVE_FILE_PERMISSION
  pattern-either:
  - pattern: java.nio.file.Files.setPosixFilePermissions($FILE, java.nio.file.attribute.PosixFilePermissions.fromString("=~/(^......r..$)|(^.......w.$)|(^........x$)/"));
  - pattern: |
      $TYPE $P = java.nio.file.attribute.PosixFilePermissions.fromString("=~/(^......r..$)|(^.......w.$)|(^........x$)/");
      ...
      java.nio.file.Files.setPosixFilePermissions($FILE, $P);
  - pattern: |
      $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_READ);
      ...
      java.nio.file.Files.setPosixFilePermissions($FILE, $P);
  - pattern: |
      $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_WRITE);
      ...
      java.nio.file.Files.setPosixFilePermissions($FILE, $P);
  - pattern: |-
      $P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_EXECUTE);
      ...
      java.nio.file.Files.setPosixFilePermissions($FILE, $P);
- id: java.lang.security.audit.permissive-cors.permissive-cors
  message: |
    https://find-sec-bugs.github.io/bugs.htm#PERMISSIVE_CORS
    Permissive CORS policy will allow a malicious application to communicate with the victim application in an inappropriate way, leading to spoofing, data theft, relay and other attacks.
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      HttpServletResponse $RES = ...;
      ...
      $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      HttpServletResponse $RES = ...;
      ...
      $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      ServerHttpResponse $RES = ...;
      ...
      $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      HttpHeaders $HEADERS = ...;
      ...
      $HEADERS.set("=~/access-control-allow-origin/i", "=~/^*|null$/i");
  - pattern: |
      ServerWebExchange $SWE = ...;
      ...
      $SWE.getResponse().getHeaders().add("Access-Control-Allow-Origin", "*");
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.addHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.setHeader("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: |
      $X $METHOD(...,ServerHttpResponse $RES,...) {
        ...
        $RES.getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: |
      $X $METHOD(...,ServerWebExchange $SWE,...) {
        ...
        $SWE.getResponse().getHeaders().add("=~/access-control-allow-origin/i", "=~/^*|null$/i");
        ...
      }
  - pattern: ResponseEntity.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
  - pattern: ServerResponse.$RES().header("=~/access-control-allow-origin/i", "=~/^*|null$/i")
- id: java.lang.security.audit.script-engine-injection.script-engine-injection
  message: |
    Detected potential code injection using ScriptEngine. Ensure
    user-controlled data cannot enter '.eval()', otherwise, this is
    a code injection vulnerability.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SCRIPT_ENGINE_INJECTION
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern-inside: |
        class $CLASS {
          ...
          ScriptEngine $SE;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          ScriptEngine $SE = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          ScriptEngine $SE = ...;
          ...
        }
  - pattern: |
      $X $METHOD(...) {
        ...
        $SE.eval(...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $SE.eval("...");
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $SE.eval($S);
        ...
      }
- id: java.lang.security.audit.unvalidated-redirect.unvalidated-redirect
  message: |
    Application redirects to a destination URL specified by a user-supplied
    parameter that is not validated. This could direct users to malicious locations.
    Consider using an allowlist to validate URLs.
  metadata:
    cwe: 'CWE-601: URL Redirection to Untrusted Site (''Open Redirect'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNVALIDATED_REDIRECT
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,String $URL,...) {
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...,HttpServletResponse $RES,...) {
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
        ...
        String $URL = $REQ.getParameter(...);
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
        ...
        String $URL = $REQ.getParameter(...);
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.sendRedirect($URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
        ...
        $RES.sendRedirect($REQ.getParameter(...));
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
        ...
        $RES.sendRedirect($REQ.getParameter(...));
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,String $URL,...) {
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...,HttpServletResponse $RES,...) {
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
        ...
        String $URL = $REQ.getParameter(...);
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
        ...
        String $URL = $REQ.getParameter(...);
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.addHeader("Location",$URL);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {
        ...
        $RES.addHeader("Location",$REQ.getParameter(...));
        ...
      }
  - pattern: |-
      $X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {
        ...
        $RES.addHeader("Location",$REQ.getParameter(...));
        ...
      }
- id: java.lang.security.audit.url-rewriting.url-rewriting
  message: |
    URL rewriting has significant security risks.
    Since session ID appears in the URL, it may be easily seen by third parties.
  metadata:
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#URL_REWRITING
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.encodeURL(...);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.encodeUrl(...);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.encodeRedirectURL(...);
        ...
      }
  - pattern: |
      $X $METHOD(...,HttpServletResponse $RES,...) {
        ...
        $RES.encodeRedirectUrl(...);
        ...
      }
  - pattern: |
      $X $METHOD(...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.encodeURL(...);
        ...
      }
  - pattern: |
      $X $METHOD(...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.encodeUrl(...);
        ...
      }
  - pattern: |
      $X $METHOD(...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.encodeRedirectURL(...);
        ...
      }
  - pattern: |-
      $X $METHOD(...) {
        ...
        HttpServletResponse $RES = ...;
        ...
        $RES.encodeRedirectUrl(...);
        ...
      }
- id: java.lang.security.audit.weak-ssl-context.weak-ssl-context
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source_rule_url: https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT
    references:
    - https://tools.ietf.org/html/rfc7568
    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
  message: |
    An insecure SSL context was detected. TLS versions 1.0, 1.1, and all SSL versions
    are considered weak encryption and are deprecated.
    Use SSLContext.getInstance("TLSv1.2") for the best security.
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-not: SSLContext.getInstance("TLS1.3")
  - pattern-not: SSLContext.getInstance("TLS1.2")
  - pattern: SSLContext.getInstance("...")
  fix-regex:
    regex: (.*?)\.getInstance\(.*?\)
    replacement: \1.getInstance("TLS1.2")
- id: java.lang.security.audit.xml-decoder.xml-decoder
  message: |
    XMLDecoder should not be used to parse untrusted data.
    Deserializing user input can lead to arbitrary code execution.
    Use an alternative and explicitly disable external entities.
    See https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html
    for alternatives and vulnerability prevention.
  metadata:
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    owasp: 'A4: XML External Entities (XXE)'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XML_DECODER
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern: |
      $X $METHOD(...) {
        ...
        new XMLDecoder(...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        new XMLDecoder("...");
        ...
      }
  - pattern-not: |-
      $X $METHOD(...) {
        ...
        String $STR = "...";
        ...
        new XMLDecoder($STR);
        ...
      }
- id: java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure
  metadata:
    owasp: 'A7: Cross-Site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_REQUEST_WRAPPER
  message: |
    It looks like you're using an implementation of XSSRequestWrapper from dzone.
    (https://www.javacodegeeks.com/2012/07/anti-cross-site-scripting-xss-filter.html)
    The XSS filtering in this code is not secure and can be bypassed by malicious actors.
    It is recommended to use a stack that automatically escapes in your view or templates
    instead of filtering yourself.
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern: |
        class XSSRequestWrapper extends HttpServletRequestWrapper {
          ...
        }
    - pattern: |-
        $P = $X.compile("</script>", $X.CASE_INSENSITIVE);
        $V = $P.matcher(...).replaceAll("");
  languages:
  - java
- id: java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN
    references:
    - https://www.owasp.org/index.php/Path_Traversal
  message: |
    Detected a potential path traversal. A malicious actor
    could control the location of this file, to include going backwards
    in the directory with '../'. To address this, ensure that user-controlled
    variables in file paths are sanitized. You may aslso consider using a utility
    method such as org.apache.commons.io.FilenameUtils.getName(...) to only
    retrieve the file name from the path.
  patterns:
  - pattern-inside: |
      $RETURNTYPE $FUNC (..., HttpServletRequest $REQ, ...) {
        ...
      }
  - pattern-either:
    - pattern: |
        $VAR = ($TYPE)$REQ.getParameter(...);
        ...
        new File(..., $VAR, ...);
    - pattern: |
        $VAR = $REQ.getParameter(...);
        ...
        new File(..., $VAR, ...);
  severity: ERROR
  languages:
  - java
- id: java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss
  message: |
    Cross-site scripting detected in HttpServletResponse writer with variable '$VAR'. User
    input was detected going directly from the HttpServletRequest into output. Ensure your
    data is properly encoded using org.owasp.encoder.Encode.forHtml: 'Encode.forHtml($VAR)'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (''XSS'')'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET
  severity: ERROR
  patterns:
  - pattern-inside: $TYPE $FUNC(..., HttpServletResponse $RESP, ...) { ... }
  - pattern-inside: $VAR = $REQ.getParameter(...); ...
  - pattern-either:
    - pattern: $RESP.getWriter(...).write(..., $VAR, ...);
    - pattern: |
        $WRITER = $RESP.getWriter(...);
        ...
        $WRITER.write(..., $VAR, ...);
  languages:
  - java
- id: java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled
  severity: ERROR
  metadata:
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    owasp: 'A4: XML External Entities (XXE)'
    references:
    - https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf
  message: |
    XML external entities are enabled for this XMLInputFactory. This is vulnerable to XML external entity
    attacks. Disable external entities by setting "javax.xml.stream.isSupportingExternalEntities" to false.
  pattern: $XMLFACTORY.setProperty("javax.xml.stream.isSupportingExternalEntities",
    true);
  languages:
  - java
- id: java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe
  severity: WARNING
  metadata:
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    owasp: 'A4: XML External Entities (XXE)'
    references:
    - https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf
    - https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#xmlinputfactory-a-stax-parser
  message: |
    XML external entities are not explicitly disabled for this XMLInputFactory. This could be vulnerable to XML external entity
    vulnerabilities. Explicitly disable external entities by setting "javax.xml.stream.isSupportingExternalEntities" to false.
  patterns:
  - pattern-not-inside: |
      $RETURNTYPE $METHOD(...) {
        ...
        $XMLFACTORY.setProperty("javax.xml.stream.isSupportingExternalEntities", false);
        ...
      }
  - pattern-not-inside: |
      $RETURNTYPE $METHOD(...) {
        ...
        $XMLFACTORY.setProperty(java.xml.stream.XMLFactoryInput.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
        ...
      }
  - pattern-either:
    - pattern: $XMLFACTORY = $W.newFactory(...);
    - pattern: $XMLFACTORY = new XMLInputFactory(...);
  languages:
  - java
- id: java.rmi.security.server-dangerous-object-deserialization.server-dangerous-object-deserialization
  severity: ERROR
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/
    - https://frohoff.github.io/appseccali-marshalling-pickles/
  message: |
    Using an arbitrary object ('Object $PARAM') with Java RMI is an insecure deserialization
    vulnerability. This object can be manipulated by a malicious actor allowing them to execute
    code on your system. Instead, use an integer ID to look up your object, or consider alternative
    serializiation schemes such as JSON.
  patterns:
  - pattern: |
      interface $INTERFACE extends Remote {
        $RETURNTYPE $METHOD(Object $PARAM) throws RemoteException;
      }
  languages:
  - java
- id: java.spring.security.audit.spel-injection.spel-injection
  message: |
    A Spring expression is built with a dynamic value. The source of the value(s) should be verified to avoid that unfiltered values fall into this risky code evaluation.
  metadata:
    cwe: 'CWE-94: Improper Control of Generation of Code (''Code Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPEL_INJECTION
  severity: WARNING
  languages:
  - java
  patterns:
  - pattern-either:
    - pattern-inside: |
        class $CLASS {
          ...
          ExpressionParser $PARSER;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          ExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          ExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          SpelExpressionParser $PARSER;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          SpelExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          SpelExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          TemplateAwareExpressionParser $PARSER;
          ...
        }
    - pattern-inside: |
        class $CLASS {
          ...
          TemplateAwareExpressionParser $PARSER = ...;
          ...
        }
    - pattern-inside: |
        $X $METHOD(...) {
          ...
          TemplateAwareExpressionParser $PARSER = ...;
          ...
        }
  - pattern: |
      $X $METHOD(...) {
        ...
        $PARSER.parseExpression(...);
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        $PARSER.parseExpression("...");
        ...
      }
  - pattern-not: |
      $X $METHOD(...) {
        ...
        String $S = "...";
        ...
        $PARSER.parseExpression($S);
        ...
      }
- id: java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled
  message: |
    CSRF is disabled for this configuration. This is a security risk.
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_PROTECTION_DISABLED
  severity: WARNING
  languages:
  - java
  pattern: $OBJ.csrf(...).disable(...)
- id: java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect
  message: |
    Application redirects a user to a destination URL specified by a user supplied parameter that is not validated.
  metadata:
    cwe: 'CWE-601: URL Redirection to Untrusted Site (''Open Redirect'')'
    owasp: 'A1: Injection'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#UNVALIDATED_REDIRECT
  severity: WARNING
  languages:
  - java
  pattern-either:
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        return "redirect:" + $URL;
      }
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        ...
        String $REDIR = "redirect:" + $URL;
        ...
        return $REDIR;
        ...
      }
  - pattern: |
      $X $METHOD(...,String $URL,...) {
        ...
        new ModelAndView("redirect:" + $URL);
        ...
      }
  - pattern: |-
      $X $METHOD(...,String $URL,...) {
        ...
        String $REDIR = "redirect:" + $URL;
        ...
        new ModelAndView($REDIR);
        ...
      }
- id: java.spring.security.unrestricted-request-mapping.unrestricted-request-mapping
  patterns:
  - pattern: |
      @RequestMapping(...)
      $RETURNTYPE $METHOD(...) { ... }
  - pattern-not-inside: |
      @RequestMapping(..., method = $X)
      $RETURNTYPE $METHOD(...) { ... }
  message: Detected a method annotated with 'RequestMapping' that does not specify
    the HTTP method. CSRF protections are not enabled for GET, HEAD, TRACE, or OPTIONS,
    and by default all HTTP methods are allowed when the HTTP method is not explicitly
    specified. This means that a method that performs state changes could be vulnerable
    to CSRF attacks. To mitigate, add the 'method' field and specify the HTTP method
    (such as 'RequestMethod.POST').
  severity: WARNING
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
    references:
    - https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING
  languages:
  - java
- id: javascript.grpc.security.grpc-nodejs-insecure-connection.grpc-nodejs-insecure-connection
  message: |
    Found an insecure gRPC connection. This creates a connection without encryption to a gRPC client/server. A malicious attacker
    could tamper with the gRPC message, which could compromise the machine.
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
  severity: ERROR
  languages:
  - javascript
  pattern-either:
  - pattern: |
      require('grpc');
      ...
      $GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);
  - pattern: |-
      require('grpc');
      ...
      $CREDS = <... $CREDENTIALS.createInsecure() ...>;
      ...
      $GRPC($ADDR,...,$CREDS,...);
- id: javascript.jose.security.jwt-exposed-credentials.jwt-exposed-credentials
  languages:
  - javascript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  patterns:
  - pattern-either:
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign({password:...},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign({password:...},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {password:...};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {password:...};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {password:...};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {password:...};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.password = ...;
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.password = ...;
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {$U:{password:...}};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = {$U:{password:...}};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {$U:{password:...}};
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = {$U:{password:...}};
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.$U.password = ...;
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P.$U.password = ...;
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = JWT.sign($P,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        $T = JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
  severity: ERROR
- id: javascript.jose.security.jwt-hardcode.hardcoded-jwt-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  patterns:
  - pattern-either:
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        JWT.verify($P, "...", ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.sign($P, "...", ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $T = JWT.verify($P, "...", ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        JWT.verify($P, JWK.asKey("..."), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $KEY = JWK.asKey("...");
        ...
        JWT.verify($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $T = JWT.sign($P, JWK.asKey("..."), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $T = JWT.verify($P, JWK.asKey("..."), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $KEY = JWK.asKey("...");
        ...
        var $T = JWT.sign($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $KEY = JWK.asKey("...");
        ...
        var $T = JWT.verify($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        JWT.verify($P, $SECRET, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.sign($P, $SECRET, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.verify($P, $SECRET, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        JWT.verify($P, JWK.asKey($SECRET), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $KEY = JWK.asKey($SECRET);
        ...
        JWT.verify($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.sign($P, JWK.asKey($SECRET), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $KEY = JWK.asKey($SECRET);
        ...
        var $T = JWT.sign($P, $KEY, ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $T = JWT.verify($P, JWK.asKey($SECRET), ...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $SECRET = "...";
        ...
        var $KEY = JWK.asKey($SECRET);
        ...
        var $T = JWT.verify($P, $KEY, ...);
  languages:
  - javascript
  severity: ERROR
- id: javascript.jose.security.jwt-none-alg.jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  languages:
  - javascript
  severity: ERROR
  patterns:
  - pattern-either:
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        var $T = JWT.verify($P, JWK.None,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        $T = JWT.verify($P, JWK.None,...);
    - pattern: |
        var $JOSE = require("jose");
        ...
        var { JWK, JWT } = $JOSE;
        ...
        JWT.verify($P, JWK.None,...);
- id: javascript.jsonwebtoken.security.jwt-exposed-credentials.jwt-exposed-credentials
  languages:
  - javascript
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
    references:
    - https://cwe.mitre.org/data/definitions/522.html
  message: |
    Password is exposed through JWT token payload. This is not encrypted and
    the password could be compromised. Do not store passwords in JWT tokens.
  patterns:
  - pattern-either:
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign({password:...},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign({password:...},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign({password:...},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {password:...};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {password:...};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {password:...};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {password:...};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {password:...};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {password:...};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.password = ...;
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.password = ...;
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.password = ...;
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{password:...},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{password:...},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign(Object.assign(...,{password:...},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign({$U:{password:...}},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {$U:{password:...}};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {$U:{password:...}};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = {$U:{password:...}};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {$U:{password:...}};
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {$U:{password:...}};
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = {$U:{password:...}};
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.$U.password = ...;
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.$U.password = ...;
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P.$U.password = ...;
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        var $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $T = $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $P = Object.assign(...,{$U:{password:...}},...);
        ...
        $JWT.sign($P,...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign(Object.assign(...,{$U:{password:...}},...),...);
  severity: ERROR
- id: javascript.jsonwebtoken.security.jwt-hardcode.hardcoded-jwt-secret
  message: |
    Hardcoded JWT secret or private key is used.
    This is a Insufficiently Protected Credentials weakness: https://cwe.mitre.org/data/definitions/522.html
    Consider using an appropriate security mechanism to protect the credentials (e.g. keeping secrets in environment variables: process.env.SECRET)
  metadata:
    cwe: 'CWE-522: Insufficiently Protected Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  patterns:
  - pattern-either:
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.sign($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.verify($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.sign($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.verify($P, "...", ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        var $T = $JWT.sign($P, $SECRET, ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        var $T = $JWT.verify($P, $SECRET, ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        $JWT.sign($P, $SECRET, ...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $SECRET = "...";
        ...
        $JWT.verify($P, $SECRET, ...);
  languages:
  - javascript
  severity: ERROR
- id: javascript.jsonwebtoken.security.jwt-none-alg.jwt-none-alg
  message: |
    Detected use of the 'none' algorithm in a JWT token.
    The 'none' algorithm assumes the integrity of the token has already
    been verified. This would allow a malicious actor to forge a JWT token
    that will automatically be verified. Do not explicitly use the 'none'
    algorithm. Instead, use an algorithm such as 'HS256'.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
  languages:
  - javascript
  severity: ERROR
  patterns:
  - pattern-either:
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        var $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
    - pattern: |
        var $JWT = require("jsonwebtoken");
        ...
        $T = $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
    - pattern: |-
        var $JWT = require("jsonwebtoken");
        ...
        $JWT.verify($P, $X, {algorithms:[...,'none',...]},...);
- id: javascript.lang.security.detect-buffer-noassert.detect-buffer-noassert
  metadata:
    cwe: 'CWE-119: Improper Restriction of Operations within the Bounds of a Memory
      Buffer'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-buffer-noassert.js
  message: |
    Detected usage of noassert in Buffer API, which allows the offset the be beyond the
    end of the buffer. This could result in writing or reading beyond the end of the buffer.
  patterns:
  - pattern: $OBJ.$API(..., true)
  - metavariable-regex:
      metavariable: $API
      regex: (read|write)(U?Int8|(U?Int(16|32)|Float|Double)(LE|BE))
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.detect-child-process.detect-child-process
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js
  message: |
    Detected non-literal calls to child_process.exec(). This could lead to a command
    injection vulnerability.
  patterns:
  - pattern: child_process.exec(...)
  - pattern-not: child_process.exec('...')
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.detect-disable-mustache-escape.detect-disable-mustache-escape
  metadata:
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    owasp: 'A7: Cross-Site Scripting XSS'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-disable-mustache-escape.js
  message: |
    Markup escaping disabled. This can be used with some template engines to escape
    disabling of HTML entities, which can lead to XSS attacks.
  pattern: $OBJ.escapeMarkup = false
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.detect-eval-with-expression.detect-eval-with-expression
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-eval-with-expression.js
  message: |
    Detected eval(variable), which could allow a malicious actor to run arbitrary code.
  patterns:
  - pattern: eval($OBJ)
  - pattern-not: eval("...")
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.detect-no-csrf-before-method-override.detect-no-csrf-before-method-override
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-no-csrf-before-method-override.js
    references:
    - https://github.com/nodesecurity/eslint-plugin-security/blob/master/docs/bypass-connect-csrf-protection-by-abusing.md
  message: |
    Detected use of express.csrf() middleware before express.methodOverride(). This can
    allow GET requests (which are not checked by csrf) to turn into POST requests later.
  pattern: |
    express.csrf();
    ...
    express.methodOverride();
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.detect-non-literal-require.detect-non-literal-require
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-require.js
  message: |
    Detected the use of require(variable). Calling require with a non-literal argument might
    allow an attacker to load an run arbitrary code, or access arbitrary files.
  patterns:
  - pattern: require($OBJ)
  - pattern-not: require('...')
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.detect-pseudorandombytes.detect-pseudoRandomBytes
  metadata:
    cwe: 'CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)'
    owasp: 'A9: Using Components with Known Vulnerabilities'
    source-rule-url: https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-pseudoRandomBytes.js
  message: |
    Detected usage of crypto.pseudoRandomBytes, which does not produce secure random numbers.
  pattern: crypto.pseudoRandomBytes
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.lang.security.spawn-git-clone.spawn-git-clone
  message: |
    Git allows shell commands to be specified in ext URLs for remote repositories.
    For example, git clone 'ext::sh -c whoami% >&2' will execute the whoami command to try to connect to a remote repository.
    Make sure that the URL is not controlled by external input.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
  languages:
  - javascript
  - typescript
  severity: ERROR
  patterns:
  - pattern-either:
    - pattern: spawn('git', ['clone',...,$F])
    - pattern: $X.spawn('git', ['clone',...,$F])
    - pattern: spawn('git', ['clone',...,$P,$F])
    - pattern: $X.spawn('git', ['clone',...,$P,$F])
  - pattern-not: spawn('git', ['clone',...,"..."])
  - pattern-not: $X.spawn('git', ['clone',...,"..."])
  - pattern-not: spawn('git', ['clone',...,"...","..."])
  - pattern-not: $X.spawn('git', ['clone',...,"...","..."])
- id: javascript.node-expat.security.audit.expat-xxe.expat-xxe
  message: |
    If unverified user data can reach the XML Parser it can result in XML External or
    Internal Entity (XXE) Processing vulnerabilities
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
  severity: WARNING
  languages:
  - javascript
  patterns:
  - pattern-either:
    - pattern: |
        var $EXPAT = require('node-expat');
        ...
        new $EXPAT.Parser(...);
        ...
        $PARSER.parse(...);
    - pattern: |
        var $EXPAT = require('node-expat');
        ...
        new $EXPAT.Parser(...);
        ...
        $PARSER.write(...);
    - pattern: |
        require('node-expat');
        ...
        new Parser(...);
        ...
        $PARSER.parse(...);
    - pattern: |
        require('node-expat');
        ...
        new Parser(...);
        ...
        $PARSER.write(...);
  - pattern-not: |
      var $EXPAT = require('node-expat');
      ...
      new $EXPAT.Parser(...);
      ...
      $PARSER.parse("...");
  - pattern-not: |
      var $EXPAT = require('node-expat');
      ...
      new $EXPAT.Parser(...);
      ...
      $PARSER.write("...");
  - pattern-not: |
      require('node-expat');
      ...
      new Parser(...);
      ...
      $PARSER.parse("...");
  - pattern-not: |
      require('node-expat');
      ...
      new Parser(...);
      ...
      $PARSER.write("...");
  - pattern-not: |
      $X = "...";
      ...
      $PARSER.parse($X);
  - pattern-not: |-
      $X = "...";
      ...
      $PARSER.write($X);
- id: javascript.sax.security.audit.sax-xxe.sax-xxe
  message: |
    Use of 'ondoctype' in 'sax' library detected. By default, 'sax'
    won't do anything with custom DTD entity definitions. If you're
    implementing a custom DTD entity definition, be sure not to introduce
    XML External Entity (XXE) vulnerabilities, or be absolutely sure that
    external entities received from a trusted source while processing XML.
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    references:
    - https://github.com/Leonidas-from-XIV/node-xml2js/issues/415
    - https://github.com/isaacs/sax-js
  severity: WARNING
  languages:
  - javascript
  pattern-either:
  - pattern: |
      require('sax');
      ...
      $PARSER.ondoctype = ...;
  - pattern: |-
      require('sax');
      ...
      $PARSER.on('doctype',...);
- id: javascript.xml2json.security.audit.xml2json-xxe.xml2json-xxe
  message: |
    If unverified user data can reach the XML Parser it can result in XML External or
    Internal Entity (XXE) Processing vulnerabilities
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
  severity: WARNING
  languages:
  - javascript
  patterns:
  - pattern: |
      var $XML = require('xml2json');
      ...
      $XML.toJson(...);
  - pattern-not: |
      var $XML = require('xml2json');
      ...
      $XML.toJson("...",...);
  - pattern-not: |-
      var $XML = require('xml2json');
      ...
      var $S = "...";
      ...
      $XML.toJson($S,...);
- id: javascript.lang.security.audit.unknown-value-with-script-tag.unknown-value-with-script-tag
  patterns:
  - pattern-inside: |
      $UNK = $ANYFUNC(...);
      ...
      $OTHERFUNC(..., <... $UNK ...>, ...);
  - pattern: $OTHERFUNC(..., <... "=~/.*<script.*/" ...>, ...)
  message: |
    Cannot determine what '$UNK' is and it is used with a '<script>' tag. This
    could be susceptible to cross-site scripting (XSS). Ensure '$UNK' is not
    externally controlled, or sanitize this data.
  metadata:
    owasp: 'A7: Cross-site Scripting (XSS)'
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    references:
    - https://www.developsec.com/2017/11/09/xss-in-a-script-tag/
    - https://github.com/bkimminich/juice-shop/blob/master/routes/videoHandler.js#L64
  severity: WARNING
  languages:
  - javascript
  - typescript
- id: javascript.express.security.audit.possible-user-input-redirect.unknown-value-in-redirect
  patterns:
  - pattern-either:
    - pattern-inside: |
        $UNK = query.$B;
        ...
    - pattern-inside: |
        $UNK = $A.query.$B;
        ...
    - pattern-inside: |
        $UNK = req.$SOMETHING;
        ...
  - pattern: $RES.redirect(..., <... $UNK ...>, ...)
  message: |
    It looks like '$UNK' is read from user input and it is used to as a redirect. Ensure
    '$UNK' is not externally controlled, otherwise this is an open redirect.
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-601: URL Redirection to Untrusted Site (''Open Redirect'')'
  severity: WARNING
  languages:
  - javascript
- id: python.airflow.security.audit.formatted-string-bashoperator.formatted-string-bashoperator
  patterns:
  - pattern-either:
    - pattern: |
        airflow.operators.bash_operator.BashOperator(..., bash_command="..." + $CONCAT, ...)
    - pattern: |
        airflow.operators.bash_operator.BashOperator(..., bash_command="...".format(...), ...)
    - pattern: |
        airflow.operators.bash_operator.BashOperator(..., bash_command=f"...", ...)
    - pattern: |
        airflow.operators.bash_operator.BashOperator(..., bash_command="..." % $PARAMS, ...)
    - pattern: |
        $CMD = "..." % $PARAMS
        ...
        airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
    - pattern: |
        $CMD = $STR.format(...)
        ...
        airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
    - pattern: |
        $CMD = f"..."
        ...
        airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
    - pattern: |
        $CMD = "..." + $CONCAT
        ...
        airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
    - pattern: |
        $CMD = "..."
        ...
        $CMD += $CONCAT
        ...
        airflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)
  message: |
    Found a formatted string in BashOperator: $CMD.
    This could be vulnerable to injection.
    Be extra sure your variables are not controllable by external sources.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
  languages:
  - python
  severity: WARNING
- id: python.boto3.security.hardcoded-token.hardcoded-token
  message: |
    Hardcoded AWS access token detected. Use environment variables
    to access tokens (e.g., os.environ.get(...)) or use non version-controlled
    configuration files.
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://pypi.org/project/flake8-boto3/
    references:
    - https://bento.dev/checks/boto3/hardcoded-access-token/
    - https://aws.amazon.com/blogs/security/what-to-do-if-you-inadvertently-expose-an-aws-access-key/
  patterns:
  - pattern-either:
    - pattern: $W(..., aws_secret_access_key="=~/^[A-Za-z0-9/+=]+$/", ...)
    - pattern: $W(..., aws_access_key_id="=~/^AKI/", ...)
    - pattern: $W(..., aws_session_token="...", ...)
  languages:
  - python
  severity: WARNING
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-blowfish
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.Blowfish(...)
  message: |
    Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L96
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-idea
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.IDEA(...)
  message: |
    Detected IDEA cipher algorithm which is considered insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://tools.ietf.org/html/rfc5469
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-rc4
  pattern: cryptography.hazmat.primitives.ciphers.algorithms.ARC4(...)
  message: |
    Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L94
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb
  pattern: cryptography.hazmat.primitives.ciphers.modes.ECB(...)
  message: |
    Detected ECB cipher mode which is considered insecure. The algorithm can
    potentially leak information about the plaintext. Use CBC mode instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L101
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B305
    references:
    - https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  pattern: cryptography.hazmat.primitives.hashes.MD5(...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  pattern: cryptography.hazmat.primitives.hashes.SHA1(...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.cryptography.security.insufficient-ec-key-size.insufficient-ec-key-size
  patterns:
  - pattern-inside: cryptography.hazmat.primitives.asymmetric.ec.generate_private_key(...)
  - pattern-either:
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECP192R1
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163K1
    - pattern: cryptography.hazmat.primitives.asymmetric.ec.SECT163R2
  message: |
    Detected an insufficient curve size for EC. NIST recommends
    a key size of 224 or higher. For example, use 'ec.SECP256R1'.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py
    references:
    - https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf
    - https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#elliptic-curves
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references: https://docs.python.org/3/library/pickle.html
  message: Avoid using insecure deserialization library, backed by `pickle`, `_pickle`,
    `cpickle`, `dill`, `shelve`, or `yaml`, which are known to lead to remote code
    execution vulnerabilities.
  languages:
  - python
  severity: ERROR
  patterns:
  - pattern-inside: |
      def $X(..., request, ...):
        ...
  - pattern-either:
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        pickle.$FUNC(<... $VAR ...>)
    - pattern: pickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        _pickle.$FUNC(<... $VAR ...>)
    - pattern: _pickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        cPickle.$FUNC(<... $VAR ...>)
    - pattern: cPickle.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        dill.$FUNC(<... $VAR ...>)
    - pattern: dill.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        shelve.$FUNC(<... $VAR ...>)
    - pattern: shelve.$FUNC(<... request.$Y.get(...) ...>)
    - pattern: |
        $VAR = <... request.$Y.get(...) ...>
        ...
        yaml.$FUNC(<... $VAR ...>)
    - pattern: yaml.$FUNC(<... request.$Y.get(...) ...>)
- id: python.django.security.audit.avoid-mark-safe.avoid-mark-safe
  patterns:
  - pattern-not-inside: django.utils.html.format_html(...)
  - pattern-not: django.utils.safestring.mark_safe("...")
  - pattern: django.utils.safestring.mark_safe(...)
  message: |
    'mark_safe()' is used to mark a string as "safe" for HTML output.
    This disables escaping and could therefore subject the content to
    XSS attacks. Use 'django.utils.html.format_html()' to build HTML
    for rendering instead.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/utils/#django.utils.safestring.mark_safe
    - https://docs.djangoproject.com/en/3.0/ref/utils/#django.utils.html.format_html
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.csrf-exempt.no-csrf-exempt
  pattern: |
    @django.views.decorators.csrf.csrf_exempt
    def $R(...):
      ...
  message: There is rarely a good reason to use @csrf_exempt as is used for `$R`.
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.custom-expression-as-sql.custom-expression-as-sql
  languages:
  - python
  message: Detected a Custom Expression ''$EXPRESSION'' calling ''as_sql(...).'' Ensure
    no user input enters this function because it is susceptible to SQL injection.
    See https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.Func.as_sql
    for more information.
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.Func.as_sql
    - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
  pattern: $EXPRESSION.as_sql(...)
  severity: WARNING
- id: python.django.security.audit.extends-custom-expression.extends-custom-expression
  languages:
  - python
  message: |
    Found extension of custom expression: $CLASS. Extending expressions
    in this way could inadvertently expose a SQL injection vulnerability.
    See https://docs.djangoproject.com/en/3.0/ref/models/expressions/#avoiding-sql-injection
    for more information.
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#avoiding-sql-injection
    - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
  patterns:
  - pattern-either:
    - pattern: |
        class $CLASS(..., django.db.models.Func, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Func, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Expression, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Expression, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Value, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Value, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.DurationValue, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.DurationValue, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.RawSQL, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.RawSQL, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Star, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Star, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Random, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Random, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Col, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Col, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Ref, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Ref, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.ExpressionList, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.ExpressionList, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.ExpressionWrapper, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.ExpressionWrapper, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.When, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.When, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Case, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Case, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Subquery, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Subquery, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Exists, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Exists, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.Window, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.Window, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.WindowFrame, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.WindowFrame, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.RowRange, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.RowRange, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.ValueRange, ...):
            ...
    - pattern: |
        class $CLASS(..., django.db.models.expressions.ValueRange, ...):
            ...
  severity: WARNING
- id: python.django.security.audit.query-set-extra.avoid-query-set-extra
  patterns:
  - pattern-either:
    - pattern: $X.objects.$FUNC(...).extra(...)
    - pattern: $X.objects.$FUNC(...).$FILTER(...).extra(...)
    - pattern: $X.objects.$FUNC(...).$FILTER(...).$UPDATE(...).extra(...)
  message: This is a last resort. You should be careful when using QuerySet.extra
    due to SQLi https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.extra
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.extra
    - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
  languages:
  - python
  severity: ERROR
- id: python.django.security.audit.raw-query.avoid-raw-sql
  patterns:
  - pattern-either:
    - pattern: $MODEL.objects.raw($QUERY, ...)
    - pattern: django.db.models.expressions.RawSQL(...)
  message: You should be very careful whenever you write raw SQL. Consider using Django
    ORM before raw SQL. See https://docs.djangoproject.com/en/3.0/topics/db/sql/#passing-parameters-into-raw
  metadata:
    cwe: 'CWE-89: Improper Neutralization of Special Elements used in an SQL Command
      (''SQL Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/models/expressions/#raw-sql-expressions
    - https://blog.r2c.dev/2020/preventing-sql-injection-a-django-authors-perspective/
  languages:
  - python
  severity: ERROR
- id: python.django.security.audit.secure-cookies.django-secure-set-cookie
  patterns:
  - pattern-either:
    - pattern-inside: |
        import django.http.HttpResponse
        ...
    - pattern-inside: |
        import django.shortcuts.render
        ...
  - pattern-not-inside: |
      LANGUAGE_QUERY_PARAMETER = 'language'
      ...
      def set_language(request):
          ...
      # Exclude vendored contrib/messages/storage/cookie.py
  - pattern-not-inside: |
      class CookieStorage(django.contrib.messages.storage.base.BaseStorage):
          ...
      # Exclude cookies handled by vendored middleware
  - pattern-not: response.set_cookie(django.conf.settings.SESSION_COOKIE_NAME, ...)
  - pattern-not: response.set_cookie(django.conf.settings.CSRF_COOKIE_NAME, ...)
  - pattern-not: response.set_cookie(django.conf.settings.LANGUAGE_COOKIE_NAME, ...)
  - pattern-not: response.set_cookie(rest_framework_jwt.settings.api_settings.JWT_AUTH_COOKIE,
      ...)
  - pattern-not: response.set_cookie(..., secure=$A, httponly=$B, samesite=$C, ...)
  - pattern-not: response.set_cookie(..., **$A)
  - pattern: response.set_cookie(...)
  message: |
    Django cookies should be handled securely by setting secure=True, httponly=True, and samesite='Lax' in
    response.set_cookie(...). If your situation calls for different settings, explicitly disable the setting.
    If you want to send the cookie over http, set secure=False.  If you want to let client-side JavaScript
    read the cookie, set httponly=False. If you want to attach cookies to requests for external sites,
    set samesite=None.
  metadata:
    cwe: 'CWE-614: Sensitive Cookie in HTTPS Session Without ''Secure'' Attribute'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/request-response/#django.http.HttpResponse.set_cookie
    - https://blog.r2c.dev/2020/bento-check-keeping-cookies-safe-in-flask/
    - https://bento.dev/checks/flask/secure-set-cookie/
  languages:
  - python
  severity: WARNING
- id: python.django.security.audit.unvalidated-password.unvalidated-password
  patterns:
  - pattern-not-inside: |
      if <... django.contrib.auth.password_validation.validate_password(...) ...>:
          ...
  - pattern-not-inside: |
      django.contrib.auth.password_validation.validate_password(...)
      ...
  - pattern-not-inside: |
      try:
        ...
        django.contrib.auth.password_validation.validate_password(...)
        ...
      except $EX:
        ...
      ...
  - pattern-not-inside: |
      try:
        ...
        django.contrib.auth.password_validation.validate_password(...)
        ...
      except $EX as $E:
        ...
      ...
  - pattern-not: UserModel().set_password($X)
  - pattern: $MODEL.set_password($X)
  fix: |
    if django.contrib.auth.password_validation.validate_password($X, user=$MODEL):
        $MODEL.set_password($X)
  message: |
    The password on '$MODEL' is being set without validating the password.
    Call django.contrib.auth.password_validation.validate_password() with
    validation functions before setting the password. See
    https://docs.djangoproject.com/en/3.0/topics/auth/passwords/
    for more information.
  metadata:
    cwe: 'CWE-521: Weak Password Requirements'
    owasp: 'A2: Broken Authentication'
    references:
    - https://docs.djangoproject.com/en/3.0/topics/auth/passwords/#module-django.contrib.auth.password_validation
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.code.globals-misuse-code-execution.globals-misuse-code-execution
  message: |
    Found request data as an index to 'globals()'. This is extremely
    dangerous because it allows an attacker to execute arbitrary code
    on the system. Refactor your code not to use 'globals()'.
  metadata:
    cwe: 'CWE-96: Improper Neutralization of Directives in Statically Saved Code (''Static
      Code Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://github.com/mpirnat/lets-be-bad-guys/blob/d92768fb3ade32956abd53bd6bb06e19d634a084/badguys/vulnerable/views.py#L181-L186
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get($DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get("..." % $DATA, ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get(f"...{$DATA}...", ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals().get("...".format(..., $DATA, ...), ...)
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()[$DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()["..." % $DATA]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()[f"...{$DATA}..."]
        ...
        $INTERM(...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = globals()["...".format(..., $DATA, ...)]
        ...
        $INTERM(...)
- id: python.django.security.injection.code.user-eval.user-eval
  message: |
    Found user data in a call to 'eval'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: eval(..., request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        eval(..., $V, ...)
    - pattern: eval(..., request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        eval(..., $V, ...)
    - pattern: eval(..., request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        eval(..., $V, ...)
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.code.user-exec.user-exec
  message: |
    Found user data in a call to 'exec'. This is extremely dangerous because
    it can enable an attacker to execute remote code. See
    https://owasp.org/www-community/attacks/Code_Injection for more information.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-either:
    - pattern: exec(..., request.$W.get(...), ...)
    - pattern: |
        $V = request.$W.get(...)
        ...
        exec(..., $V, ...)
    - pattern: exec(..., request.$W(...), ...)
    - pattern: |
        $V = request.$W(...)
        ...
        exec(..., $V, ...)
    - pattern: exec(..., request.$W[...], ...)
    - pattern: |
        $V = request.$W[...]
        ...
        exec(..., $V, ...)
  languages:
  - python
  severity: WARNING
- id: python.django.security.injection.mass-assignment.mass-assignment
  languages:
  - python
  severity: WARNING
  message: |
    Mass assignment detected. This can result in assignment to
    model fields that are unintended and can be exploited by
    an attacker. Instead of using '**request.$W', assign each field you
    want to edit individually to prevent mass assignment. You can read
    more about mass assignment at
    https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html.
  metadata:
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    owasp: 'A1: Injection'
    owaspapi: 'API6: Mass Assignment'
    references:
    - https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html
  patterns:
  - pattern-either:
    - pattern: $MODEL.objects.create(**request.$W)
    - pattern: |
        $OBJ.update(**request.$W)
        ...
        $OBJ.save()
- id: python.django.security.injection.email.xss-html-email-body.xss-html-email-body
  message: |
    Found request data in an EmailMessage that is set to use HTML.
    This is dangerous because HTML emails are susceptible to XSS.
    An attacker could inject data into this HTML email, causing XSS.
  metadata:
    cwe: 'CWE-74: Improper Neutralization of Special Elements in Output Used by a
      Downstream Component (''Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://www.damonkohler.com/2008/12/email-injection.html
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
        $EMAIL.content_subtype = "html"
        ...
  - pattern-either:
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)
    - pattern: django.core.mail.EmailMessage($SUBJ, request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $B.$C(..., $DATA, ...)
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.EmailMessage($SUBJ, f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.EmailMessage($SUBJ, $INTERM, ...)
    - pattern: $A = django.core.mail.EmailMessage($SUBJ, request.$W, ...)
    - pattern: return django.core.mail.EmailMessage($SUBJ, request.$W, ...)
- id: python.django.security.injection.email.xss-send-mail-html-message.xss-send-mail-html-message
  message: |
    Found request data in 'send_mail(...)' that uses 'html_message'.
    This is dangerous because HTML emails are susceptible to XSS.
    An attacker could inject data into this HTML email, causing XSS.
  metadata:
    cwe: 'CWE-74: Improper Neutralization of Special Elements in Output Used by a
      Downstream Component (''Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://www.damonkohler.com/2008/12/email-injection.html
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: django.core.mail.send_mail(..., html_message=request.$W.get(...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W.get(...),
        ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W.get(...),
        ...)
    - pattern: django.core.mail.send_mail(..., html_message=request.$W(...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W(...),
        ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W(...),
        ...)
    - pattern: django.core.mail.send_mail(..., html_message=request.$W[...], ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W[...],
        ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W[...],
        ...)
    - pattern: django.core.mail.send_mail(..., html_message=request.$W, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        django.core.mail.send_mail(..., html_message=$STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        django.core.mail.send_mail(..., html_message=$INTERM, ...)
    - pattern: $A = django.core.mail.send_mail(..., html_message=request.$W, ...)
    - pattern: return django.core.mail.send_mail(..., html_message=request.$W, ...)
- id: python.django.security.injection.command.command-injection-os-system.command-injection-os-system
  message: Request data detected in os.system. This could be vulnerable to a command
    injection and should be avoided. If this must be done, use the 'subprocess' module
    instead and pass the arguments as a list. See https://owasp.org/www-community/attacks/Command_Injection
    for more information.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Command_Injection
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-inside: |
      def $FUNC(...):
        ...
  - pattern-either:
    - pattern: os.system(..., request.$W.get(...), ...)
    - pattern: os.system(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: os.system(..., $S % request.$W.get(...), ...)
    - pattern: os.system(..., f"...{request.$W.get(...)}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W.get(...)
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W.get(...), ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: $A = os.system(..., $S % request.$W.get(...), ...)
    - pattern: $A = os.system(..., f"...{request.$W.get(...)}...", ...)
    - pattern: return os.system(..., request.$W.get(...), ...)
    - pattern: return os.system(..., $S.format(..., request.$W.get(...), ...), ...)
    - pattern: return os.system(..., $S % request.$W.get(...), ...)
    - pattern: return os.system(..., f"...{request.$W.get(...)}...", ...)
    - pattern: os.system(..., request.$W(...), ...)
    - pattern: os.system(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: os.system(..., $S % request.$W(...), ...)
    - pattern: os.system(..., f"...{request.$W(...)}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W(...)
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W(...), ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: $A = os.system(..., $S % request.$W(...), ...)
    - pattern: $A = os.system(..., f"...{request.$W(...)}...", ...)
    - pattern: return os.system(..., request.$W(...), ...)
    - pattern: return os.system(..., $S.format(..., request.$W(...), ...), ...)
    - pattern: return os.system(..., $S % request.$W(...), ...)
    - pattern: return os.system(..., f"...{request.$W(...)}...", ...)
    - pattern: os.system(..., request.$W[...], ...)
    - pattern: os.system(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: os.system(..., $S % request.$W[...], ...)
    - pattern: os.system(..., f"...{request.$W[...]}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W[...]
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W[...], ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: $A = os.system(..., $S % request.$W[...], ...)
    - pattern: $A = os.system(..., f"...{request.$W[...]}...", ...)
    - pattern: return os.system(..., request.$W[...], ...)
    - pattern: return os.system(..., $S.format(..., request.$W[...], ...), ...)
    - pattern: return os.system(..., $S % request.$W[...], ...)
    - pattern: return os.system(..., f"...{request.$W[...]}...", ...)
    - pattern: os.system(..., request.$W, ...)
    - pattern: os.system(..., $S.format(..., request.$W, ...), ...)
    - pattern: os.system(..., $S % request.$W, ...)
    - pattern: os.system(..., f"...{request.$W}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $STR.format(..., $DATA, ...), ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR.format(..., $DATA, ...)
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $STR % $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR % $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., f"...{$DATA}...", ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = f"...{$DATA}..."
        ...
        os.system(..., $INTERM, ...)
    - pattern: |
        $DATA = request.$W
        ...
        os.system(..., $STR + $DATA, ...)
    - pattern: |
        $DATA = request.$W
        ...
        $INTERM = $STR + $DATA
        ...
        os.system(..., $INTERM, ...)
    - pattern: $A = os.system(..., request.$W, ...)
    - pattern: $A = os.system(..., $S.format(..., request.$W, ...), ...)
    - pattern: $A = os.system(..., $S % request.$W, ...)
    - pattern: $A = os.system(..., f"...{request.$W}...", ...)
    - pattern: return os.system(..., request.$W, ...)
    - pattern: return os.system(..., $S.format(..., request.$W, ...), ...)
    - pattern: return os.system(..., $S % request.$W, ...)
    - pattern: return os.system(..., f"...{request.$W}...", ...)
- id: python.django.security.injection.path-traversal.path-traversal-file-name.path-traversal-file-name
  message: |
    Data from request is passed to a file name `$FILE`.
    This is a path traversal vulnerability: https://owasp.org/www-community/attacks/Path_Traversal
    To mitigate, consider using os.path.abspath or os.path.realpath or Path library.
  metadata:
    cwe: 'CWE-22: Improper Limitation of a Pathname to a Restricted Directory (''Path
      Traversal'')'
    owasp: 'A1: Injection'
    references:
    - https://owasp.org/www-community/attacks/Path_Traversal
  patterns:
  - pattern-inside: |
      def $F(...):
        ...
  - pattern-not: |
      ...
      os.path.realpath(...)
      ...
  - pattern-not: |
      ...
      os.path.abspath(...)
      ...
  - pattern-either:
    - pattern: |
        $V = request.$W.get($X)
        ...
        $FILE % ($V)
    - pattern: |
        $V = request.$W[$X]
        ...
        $FILE % ($V)
    - pattern: |
        $V = request.$W($X)
        ...
        $FILE % ($V)
    - pattern: |
        $V = request.$W
        ...
        $FILE % ($V)
        # match format use cases
    - pattern: |
        $V = request.$W.get($X)
        ...
        $FILE.format(..., $V, ...)
    - pattern: |
        $V = request.$W[$X]
        ...
        $FILE.format(..., $V, ...)
    - pattern: |
        $V = request.$W($X)
        ...
        $FILE.format(..., $V, ...)
    - pattern: |
        $V = request.$W
        ...
        $FILE.format(..., $V, ...)
  - metavariable-regex:
      metavariable: $FILE
      regex: .*\.(log|zip|txt|csv|xml|html).*
  languages:
  - python
  severity: WARNING
- id: python.django.security.passwords.use-none-for-password-default.use-none-for-password-default
  message: |
    '$VAR' is using the empty string as its default and is being used to set
    the password on '$MODEL'. If you meant to set an unusable password, set
    the default value to 'None' or call 'set_unusable_password()'.
  metadata:
    cwe: 'CWE-521: Weak Password Requirements'
    owasp: 'A2: Broken Authentication'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/contrib/auth/#django.contrib.auth.models.User.set_password
  patterns:
  - pattern-either:
    - pattern: |
        $VAR = request.$W.get($X, "")
        ...
        $MODEL.set_password($VAR)
        ...
        $MODEL.save(...)
    - pattern: |
        def $F(..., $VAR="", ...):
          ...
          $MODEL.set_password($VAR)
  fix-regex:
    regex: (def.*|request.*)(""|'')
    replacement: \1None
  languages:
  - python
  severity: ERROR
- id: python.django.security.audit.xss.context-autoescape-off.context-autoescape-off
  message: |
    Detected a Context with autoescape diabled. If you are
    rendering any web pages, this exposes your application to cross-site
    scripting (XSS) vulnerabilities. Remove 'autoescape: False' or set it
    to 'True'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.1/ref/settings/#templates
    - https://docs.djangoproject.com/en/3.1/topics/templates/#django.template.backends.django.DjangoTemplates
  languages:
  - python
  severity: WARNING
  patterns:
  - pattern-either:
    - pattern: '{..., "autoescape": False, ...}'
    - pattern: $D["autoescape"] = False
  fix-regex:
    regex: (autoescape.*?)False
    replacement: \1True
- id: python.django.security.audit.xss.global-autoescape-off.global-autoescape-off
  message: |
    Autoescape is globally disbaled for this Django application. If you are
    rendering any web pages, this exposes your application to cross-site
    scripting (XSS) vulnerabilities. Remove 'autoescape: False' or set it
    to 'True'.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.1/ref/settings/#templates
    - https://docs.djangoproject.com/en/3.1/topics/templates/#django.template.backends.django.DjangoTemplates
  languages:
  - python
  severity: WARNING
  pattern: |
    {..., 'BACKEND': ..., 'OPTIONS': {..., 'autoescape': False, ...}, ...}
  fix-regex:
    regex: (autoescape.*?)False
    replacement: \1True
- id: python.django.security.audit.xss.template-autoescape-off.template-autoescape-off
  message: |
    Detected a template block where autoescaping is explicitly
    disabled with '{% autoescape off %}'. This allows rendering of raw HTML
    in this segment. Turn autoescaping on to prevent cross-site scripting (XSS).
    If you must do this, consider instead, using `mark_safe` in Python code.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#autoescape
  languages:
  - none
  paths:
    include:
    - '*.html'
  severity: WARNING
  pattern-regex: '{%\s+autoescape\s+off\s+%}'
- id: python.django.security.audit.xss.template-blocktranslate-no-escape.template-blocktranslate-no-escape
  languages:
  - generic
  severity: INFO
  message: |
    Translated strings will not be escaped when rendered in a template.
    This leads to a vulnerability where translators could include malicious script tags in their translations.
    Consider using `force_escape` to explicitly escape a translated text.
  patterns:
  - pattern-either:
    - pattern: |
        {% blocktranslate...%}
    - pattern: |
        {% blocktrans...%}
  - pattern-not-inside: |
      {%...filter...force_escape...%}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {%...endfilter...%}
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates
    - https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code
- id: python.django.security.audit.xss.template-translate-as-no-escape.template-translate-as-no-escape
  languages:
  - generic
  severity: INFO
  message: |
    Translated strings will not be escaped when rendered in a template.
    This leads to a vulnerability where translators could include malicious script tags in their translations.
    Consider using `force_escape` to explicitly escape a transalted text.
  patterns:
  - pattern-either:
    - pattern: |
        {% translate ... as $TRANS ... %}
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        {{ ... $TRANS ... }}
    - pattern: |
        {% trans ... as $TRANS ... %}
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        ...
        {{ ... $TRANS ... }}
  - pattern-not: |
      {% translate ... as $TRANS ... %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {{ ... $TRANS ... | ... force_escape ... }}
  - pattern-not: |
      {% trans ... as $TRANS ... %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {{ ... $TRANS ... | ... force_escape ... }}
  - pattern-not: |
      {% translate ... as $TRANS ... %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {% filter force_escape %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {{ ... $TRANS ... }}
  - pattern-not: |
      {% trans ... as $TRANS ... %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {% filter force_escape %}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {{ ... $TRANS ... }}
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates
    - https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code
- id: python.django.security.audit.xss.template-translate-no-escape.template-translate-no-escape
  languages:
  - generic
  severity: INFO
  message: |
    Translated strings will not be escaped when rendered in a template.
    This leads to a vulnerability where translators could include malicious script tags in their translations.
    Consider using `force_escape` to explicitly escape a transalted text.
  patterns:
  - pattern-either:
    - pattern: |
        {% translate...%}
    - pattern: |
        {% trans...%}
  - pattern-not: |
      {% translate...as...%}
  - pattern-not: |
      {% trans...as...%}
  - pattern-not-inside: |
      {%...filter...force_escape...%}
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      ...
      {%...endfilter...%}
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates
    - https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code
- id: python.django.security.audit.xss.template-var-unescaped-with-safeseq.template-var-unescaped-with-safeseq
  message: |
    Detected a template variable where autoescaping is explicitly
    disabled with '| safeseq' filter. This allows rendering of raw HTML
    in this segment. Ensure no user data is rendered here, otherwise this
    is a cross-site scripting (XSS) vulnerability. If you must do this,
    use `mark_safe` in your Python code.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://docs.djangoproject.com/en/3.0/ref/templates/builtins/#safeseq
  languages:
  - none
  paths:
    include:
    - '*.html'
  severity: WARNING
  pattern-regex: '{{.*?\|\s+safeseq(\s+}})?'
- id: python.flask.security.audit.app-run-param-config.avoid_app_run_with_bad_host
  patterns:
  - pattern-either:
    - pattern: app.run(..., host="0.0.0.0", ...)
    - pattern: app.run(..., "0.0.0.0", ...)
  message: Running flask app with host 0.0.0.0 could expose the server publicly.
  metadata:
    cwe: 'CWE-668: Exposure of Resource to Wrong Sphere'
    owasp: 'A6: Security Misconfiguration'
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.app-run-security-config.avoid_using_app_run_directly
  patterns:
  - pattern-not-inside: |
      if __name__ == '__main__':
        ...
  - pattern-not-inside: |
      def $X(...):
        ...
  - pattern: app.run(...)
  message: top-level app.run(...) is ignored by flask. Consider putting app.run(...)
    behind a guard, like inside a function
  metadata:
    cwe: 'CWE-668: Exposure of Resource to Wrong Sphere'
    owasp: 'A6: Security Misconfiguration'
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.debug-enabled.debug-enabled
  patterns:
  - pattern-inside: |
      import flask
      ...
  - pattern: $APP.run(..., debug=True, ...)
  message: |
    Detected Flask app with debug=True. Do not deploy to production with this flag enabled
    as it will leak sensitive information. Instead, consider using Flask configuration
    variables or setting 'debug' using system environment variables.
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://labs.detectify.com/2015/10/02/how-patreon-got-hacked-publicly-exposed-werkzeug-debugger/
  severity: WARNING
  languages:
  - python
- id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_DEBUG
  pattern-either:
  - pattern: $M.update(DEBUG=True)
  - pattern: $M.update(DEBUG=False)
  - pattern: $M.config['DEBUG'] = True
  - pattern: $M.config['DEBUG'] = False
  message: Hardcoded variable `DEBUG` detected. Set this by using FLASK_DEBUG environment
    variable
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://bento.dev/checks/flask/avoid-hardcoded-config/
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_ENV
  pattern-either:
  - pattern: $M.update(ENV="=~/^development|production$/")
  - pattern: $M.config['ENV'] = "=~/^development|production$/"
  message: Hardcoded variable `ENV` detected. Set this by using FLASK_ENV environment
    variable
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://bento.dev/checks/flask/avoid-hardcoded-config/
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_SECRET_KEY
  pattern-either:
  - pattern: $M.update(SECRET_KEY="=~/.*/")
  - pattern: $M.config['SECRET_KEY'] = "=~/.*/"
  message: Hardcoded variable `SECRET_KEY` detected. Use environment variables or
    config files instead
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A2: Broken Authentication'
    references:
    - https://bento.dev/checks/flask/avoid-hardcoded-config/
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
  languages:
  - python
  severity: ERROR
- id: python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_TESTING
  pattern-either:
  - pattern: $M.config['TESTING'] = True
  - pattern: $M.config['TESTING'] = False
  - pattern: $M.update(TESTING=True, ...)
  - pattern: $M.update(TESTING=False, ...)
  message: Hardcoded variable `TESTING` detected. Use environment variables or config
    files instead
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://bento.dev/checks/flask/avoid-hardcoded-config/
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values
    - https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.render-template-string.render-template-string
  pattern: flask.render_template_string(...)
  metadata:
    cwe: 'CWE-96: Improper Neutralization of Directives in Statically Saved Code (''Static
      Code Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html
  message: Found a template created with string formatting. This is susceptible to
    server-side template injection and cross-site scripting attacks.
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.secure-set-cookie.secure-set-cookie
  patterns:
  - pattern-either:
    - pattern-inside: |
        $RESP = flask.make_response(...)
        ...
    - pattern-inside: |
        $RESP = flask.Response(...)
        ...
  - pattern-not: $RESPONSE.set_cookie(..., secure=$A, httponly=$B, samesite=$C, ...)
  - pattern-not: $RESPONSE.set_cookie(..., **$A)
  - pattern: $RESPONSE.set_cookie(...)
  message: |
    Flask cookies should be handled securely by setting secure=True, httponly=True, and samesite='Lax' in
    response.set_cookie(...). If your situation calls for different settings, explicitly disable the setting.
    If you want to send the cookie over http, set secure=False.  If you want to let client-side JavaScript
    read the cookie, set httponly=False. If you want to attach cookies to requests for external sites,
    set samesite=None.
  metadata:
    cwe: 'CWE-614: Sensitive Cookie in HTTPS Session Without ''Secure'' Attribute'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://blog.r2c.dev/2020/bento-check-keeping-cookies-safe-in-flask/
    - https://bento.dev/checks/flask/secure-set-cookie/
    - https://flask.palletsprojects.com/en/1.1.x/security/#set-cookie-options
  languages:
  - python
  severity: WARNING
- id: python.flask.security.audit.wtf-csrf-disabled.flask-wtf-csrf-disabled
  patterns:
  - pattern: |
      $APP.config['WTF_CSRF_ENABLED'] = False
  message: |
    `$APP.config['WTF_CSRF_ENABLED'] = False` is probably not what you want in production because it disables https://flask-wtf.readthedocs.io/en/stable/csrf.html CSRF protection
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://flask-wtf.readthedocs.io/en/stable/csrf.html
  severity: WARNING
  languages:
  - python
- id: python.flask.security.dangerous-template-string.dangerous-template-string
  patterns:
  - pattern-either:
    - pattern: |
        $V = "...".format(...)
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = "...".format(...)
        ...
        return flask.render_template_string($V, ...), $MORE
    - pattern: |
        $V = "..." % $S
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = "..." % $S
        ...
        return flask.render_template_string($V, ...), $MORE
    - pattern: |
        $V = "..."
        ...
        $V += $O
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = "..."
        ...
        $V += $O
        ...
        return flask.render_template_string($V, ...), $MORE
    - pattern: |
        $V = f"...{$X}..."
        ...
        flask.render_template_string($V, ...)
    - pattern: |
        $V = f"...{$X}..."
        ...
        return flask.render_template_string($V, ...), $CODE
  message: |
    Found a template created with string formatting.
    This is susceptible to server-side template injection
    and cross-site scripting attacks.
  metadata:
    cwe: 'CWE-96: Improper Neutralization of Directives in Statically Saved Code (''Static
      Code Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html
    - https://pequalsnp-team.github.io/cheatsheet/flask-jinja2-ssti
  languages:
  - python
  severity: ERROR
- id: python.flask.security.injection.user-eval.eval-injection
  languages:
  - python
  severity: ERROR
  message: Detected user data flowing into eval. This is code injection and should
    be avoided.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: eval(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            eval(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: eval(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: eval(..., <... flask.request.$W[...] ...>, ...)
        - pattern: eval(..., <... flask.request.$W(...) ...>, ...)
        - pattern: eval(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
              eval(..., <... $INTERM ...>, ...)
          - pattern: eval(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
              eval(..., <... $INTERM ...>, ...)
          - pattern: eval(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
              eval(..., <... $INTERM ...>, ...)
          - pattern: eval(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
              eval(..., <... $INTERM ...>, ...)
          - pattern: eval(...)
- id: python.flask.security.injection.user-exec.exec-injection
  languages:
  - python
  severity: ERROR
  message: Detected user data flowing into exec. This is code injection and should
    be avoided.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
    references:
    - https://nedbatchelder.com/blog/201206/exec_really_is_dangerous.html
  patterns:
  - pattern-either:
    - patterns:
      - pattern-inside: |
          @$APP.route($ROUTE, ...)
          def $FUNC(..., $ROUTEVAR, ...):
            ...
      - pattern-either:
        - pattern: exec(..., <... $ROUTEVAR ...>, ...)
        - pattern: |
            $INTERM = <... $ROUTEVAR ...>
            ...
            exec(..., <... $INTERM ...>, ...)
    - patterns:
      - pattern-either:
        - pattern: exec(..., <... flask.request.$W.get(...) ...>, ...)
        - pattern: exec(..., <... flask.request.$W[...] ...>, ...)
        - pattern: exec(..., <... flask.request.$W(...) ...>, ...)
        - pattern: exec(..., <... flask.request.$W ...>, ...)
    - patterns:
      - pattern-either:
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W.get(...) ...>
              ...
              exec(..., <... $INTERM ...>, ...)
          - pattern: exec(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W[...] ...>
              ...
              exec(..., <... $INTERM ...>, ...)
          - pattern: exec(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W(...) ...>
              ...
              exec(..., <... $INTERM ...>, ...)
          - pattern: exec(...)
        - patterns:
          - pattern-inside: |
              $INTERM = <... flask.request.$W ...>
              ...
              exec(..., <... $INTERM ...>, ...)
          - pattern: exec(...)
- id: python.flask.security.insecure-deserialization.insecure-deserialization
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
  message: |
    Detected the use of an insecure deserizliation library in a Flask route. These libraries
    are prone to code execution vulnerabilities. Ensure user data does not enter this function.
    To fix this, try to avoid serializing whole objects. Consider instead using a serializer
    such as JSON.
  languages:
  - python
  severity: ERROR
  patterns:
  - pattern-inside: |
      @app.route(...)
      def $X(...):
        ...
  - pattern-not: $MODULE.$FUNC("...")
  - pattern-not: $MODULE.$FUNC(open("...", ...))
  - pattern-either:
    - pattern: pickle.$FUNC(...)
    - pattern: _pickle.$FUNC(...)
    - pattern: cPickle.$FUNC(...)
    - pattern: dill.$FUNC(...)
    - pattern: shelve.$FUNC(...)
    - pattern: yaml.load(...)
- id: python.flask.security.open-redirect.open-redirect
  patterns:
  - pattern-inside: |
      @$APP.route(...)
      def $X():
        ...
  - pattern-not-inside: |
      ...
      if <... werkzeug.urls.url_parse($V) ...>:
        ...
  - pattern-either:
    - pattern: flask.redirect(<... flask.request.$W.get(...) ...>, ...)
    - pattern: flask.redirect(<... flask.request.$W[...] ...>, ...)
    - pattern: flask.redirect(<... flask.request.$W(...) ...>, ...)
    - pattern: flask.redirect(<... flask.request.$W ...>, ...)
    - pattern: |
        $V = flask.request.$W.get(...)
        ...
        flask.redirect(<... $V ...>, ...)
    - pattern: |
        $V = flask.request.$W[...]
        ...
        flask.redirect(<... $V ...>, ...)
    - pattern: |
        $V = flask.request.$W(...)
        ...
        flask.redirect(<... $V ...>, ...)
    - pattern: |
        $V = flask.request.$W
        ...
        flask.redirect(<... $V ...>, ...)
  message: |
    Data from request is passed to redirect().
    This is an open redirect and could be exploited.
    Consider using 'url_for()' to generate links to known locations.
    If you must use a URL to unknown pages, consider using 'urlparse()'
    or similar and checking if the 'netloc' property is the same as
    your site's host name. See the references for more information.
  metadata:
    cwe: 'CWE-601: URL Redirection to Untrusted Site (''Open Redirect'')'
    owasp: 'A1: Injection'
    references:
    - https://flask-login.readthedocs.io/en/latest/#login-example
    - https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html#dangerous-url-redirect-example-1
    - https://docs.python.org/3/library/urllib.parse.html#url-parsing
  languages:
  - python
  severity: ERROR
- id: python.flask.security.secure-static-file-serve.avoid_send_file_without_path_sanitization
  patterns:
  - pattern-inside: |
      @app.route(...)
      def $X(filename):
        ...
  - pattern-either:
    - pattern: flask.send_file(filename, ...)
  message: Looks like `filename` could flow to `flask.send_file()` function. Make
    sure to properly sanitize filename or use `flask.send_from_directory`
  metadata:
    cwe: 'CWE-73: External Control of File Name or Path'
    owasp: 'A1: Injection'
  languages:
  - python
  severity: WARNING
- id: python.flask.security.unescaped-template-extension.unescaped-template-extension
  message: |
    Flask does not automatically escape Jinja templates unless they have
    .html, .htm, .xml, or .xhtml extensions. This could lead to XSS attacks.
    Use .html, .htm, .xml, or .xhtml for your template extensions.
    See https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup
    for more information.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    source-rule-url: https://pypi.org/project/flake8-flask/
    references:
    - https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup
    - https://blog.r2c.dev/2020/bento-check-unescaped-template-extensions-in-flask/
    - https://bento.dev/checks/flask/unescaped-file-extension/
  patterns:
  - pattern-not: flask.render_template("=~/.+\.html$/", ...)
  - pattern-not: flask.render_template("=~/.+\.xml$/", ...)
  - pattern-not: flask.render_template("=~/.+\.htm$/", ...)
  - pattern-not: flask.render_template("=~/.+\.xhtml$/", ...)
  - pattern-not: flask.render_template($X + "=~/\.html$/", ...)
  - pattern-not: flask.render_template($X + "=~/\.xml$/", ...)
  - pattern-not: flask.render_template($X + "=~/\.htm$/", ...)
  - pattern-not: flask.render_template($X + "=~/\.xhtml$/", ...)
  - pattern-not: flask.render_template("=~/.+\.html$/" % $X, ...)
  - pattern-not: flask.render_template("=~/.+\.xml$/" % $X, ...)
  - pattern-not: flask.render_template("=~/.+\.htm$/" % $X, ...)
  - pattern-not: flask.render_template("=~/.+\.xhtml$/" % $X, ...)
  - pattern-not: flask.render_template("=~/.+\.html$/".format(...), ...)
  - pattern-not: flask.render_template("=~/.+\.xml$/".format(...), ...)
  - pattern-not: flask.render_template("=~/.+\.htm$/".format(...), ...)
  - pattern-not: flask.render_template("=~/.+\.xhtml$/".format(...), ...)
  - pattern-not: flask.render_template($TEMPLATE)
  - pattern-either:
    - pattern: flask.render_template("...", ...)
    - pattern: flask.render_template($X + "...", ...)
    - pattern: flask.render_template("..." % $Y, ...)
    - pattern: flask.render_template("...".format(...), ...)
  languages:
  - python
  severity: WARNING
- id: python.flask.security.unsanitized-input.response-contains-unsanitized-input
  patterns:
  - pattern-either:
    - pattern: |
        $X = flask.request.args.get(...)
        ...
        flask.make_response("...".format($X))
    - pattern: |
        $X = flask.request.args.get(...)
        ...
        flask.make_response(f"...{$X}...")
    - pattern: |
        $X = flask.request.args.get(...)
        ...
        flask.make_response(f"...{$X}")
    - pattern: |
        $X = flask.request.args.get(...)
        ...
        flask.make_response(f"{$X}...")
  message: |
    Flask response reflects unsanitized user input. This could lead to a
    cross-site scripting vulnerability (https://owasp.org/www-community/attacks/xss/)
    in which an attacker causes arbitrary code to be executed in the user's browser.
    To prevent, please sanitize the user input, e.g. by rendering the response
    in a Jinja2 template (see considerations in https://flask.palletsprojects.com/en/1.0.x/security/).
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.0.x/security/
    - https://owasp.org/www-community/attacks/xss/
  languages:
  - python
  severity: WARNING
- id: python.flask.security.xss.audit.template-autoescape-off.template-autoescape-off
  message: Detected a segment of a Flask template where autoescaping is explicitly
    disabled with '{% autoescape off %}'. This allows rendering of raw HTML in this
    segment. Ensure no user data is rendered here, otherwise this is a cross-site
    scripting (XSS) vulnerability, or turn autoescape on.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/templating/#controlling-autoescaping
    - https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup
  languages:
  - none
  paths:
    include:
    - '*.html'
  severity: WARNING
  pattern-regex: '{%\s*autoescape\s+false\s*%}'
- id: python.flask.security.xss.audit.template-unescaped-with-safe.template-unescaped-with-safe
  message: Detected a segment of a Flask template where autoescaping is explicitly
    disabled with '| safe' filter. This allows rendering of raw HTML in this segment.
    Ensure no user data is rendered here, otherwise this is a cross-site scripting
    (XSS) vulnerability.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss
  languages:
  - none
  paths:
    include:
    - '*.html'
  severity: WARNING
  pattern-regex: '{{.*?\|\s*safe(\s*}})?'
- id: python.jinja2.security.audit.autoescape-disabled.autoescape-disabled
  patterns:
  - pattern-not: jinja2.Environment(..., autoescape=True, ...)
  - pattern-not: jinja2.Environment(..., autoescape=jinja2.select_autoescape(...),
      ...)
  - pattern: jinja2.Environment(...)
  fix-regex:
    regex: (.*)\)
    replacement: \1, autoescape=True)
  message: Detected a Jinja2 environment without autoescaping. Jinja2 does not autoescape
    by default. This is dangerous if you are rendering to a browser because this allows
    for cross-site scripting (XSS) attacks. If you are in a web context, enable autoescaping
    by setting 'autoescape=True.' You may also consider using 'jinja2.select_autoescape()'
    to only enable automatic escaping for certain file extensions.
  metadata:
    cwe: 'CWE-116: Improper Encoding or Escaping of Output'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://jinja.palletsprojects.com/en/2.11.x/api/#basics
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.conn_recv.multiprocessing-recv
  languages:
  - python
  message: 'The Connection.recv() method automatically unpickles the data it receives,
    which can be a security risk unless you can trust the process which sent the message.
    Therefore, unless the connection object was produced using Pipe() you should only
    use the recv() and send() methods after performing some sort of authentication.
    See more dettails: https://docs.python.org/3/library/multiprocessing.html?highlight=security#multiprocessing.connection.Connection'
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://docs.python.org/3/library/multiprocessing.html?highlight=security#multiprocessing.connection.Connection
  pattern-either:
  - pattern: multiprocessing.connection.Connection.recv(...)
  - pattern: multiprocessing.connection.Client.recv(...)
  - pattern: |
      $C = multiprocessing.connection.Client(...)
      ...
      $C.recv(...)
  severity: WARNING
- id: python.lang.security.audit.dangerous-spawn-process.dangerous-spawn-process
  patterns:
  - pattern-either:
    - patterns:
      - pattern-not: os.$W("...", ...)
      - pattern-either:
        - pattern: os.execl(...)
        - pattern: os.execle(...)
        - pattern: os.execlp(...)
        - pattern: os.execlpe(...)
        - pattern: os.execv(...)
        - pattern: os.execve(...)
        - pattern: os.execvp(...)
        - pattern: os.execvpe(...)
        - pattern: os.startfile(...)
    - patterns:
      - pattern-not: os.$W($MODE, "...", ...)
      - pattern-either:
        - pattern: os.spawnl(...)
        - pattern: os.spawnle(...)
        - pattern: os.spawnlp(...)
        - pattern: os.spawnlpe(...)
        - pattern: os.spawnv(...)
        - pattern: os.spawnve(...)
        - pattern: os.spawnvp(...)
        - pattern: os.spawnvpe(...)
  message: |
    Found dynamic content when spawning a process. This is dangerous if external
    data can reach this function call because it allows a malicious actor to
    execute commands. Ensure no external data reaches here.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.dangerous-system-call.dangerous-system-call
  patterns:
  - pattern-not: os.$W("...", ...)
  - pattern-either:
    - pattern: os.system(...)
    - pattern: os.popen(...)
    - pattern: os.popen2(...)
    - pattern: os.popen3(...)
    - pattern: os.popen4(...)
  message: Found dynamic content used in a system call. This is dangerous if external
    data can reach this function call because it allows a malicious actor to execute
    commands. Use the 'subprocess' module instead, which is easier to use without
    accidentally exposing a command injection vulnerability.
  metadata:
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    owasp: 'A1: Injection'
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected
  patterns:
  - pattern-not: urllib.$W("...")
  - pattern-not: urllib.request.$W("...")
  - pattern-not: $OPENER.$W("...")
  - pattern-either:
    - patterns:
      - pattern-either:
        - pattern: urllib.urlopen(...)
        - pattern: urllib.request.urlopen(...)
        - pattern: urllib.urlretrieve(...)
        - pattern: urllib.request.urlretrieve(...)
    - patterns:
      - pattern-either:
        - pattern-inside: |
            $OPENER = urllib.URLopener(...)
            ...
        - pattern-inside: |
            $OPENER = urllib.request.URLopener(...)
            ...
        - pattern-inside: |
            $OPENER = urllib.FancyURLopener(...)
            ...
        - pattern-inside: |
            $OPENER = urllib.request.FancyURLopener(...)
            ...
      - pattern-either:
        - pattern: $OPENER.open(...)
        - pattern: $OPENER.retrieve(...)
  message: Detected a dynamic value being used with urllib. urllib supports 'file://'
    schemes, so a dynamic value controlled by a malicious actor may allow them to
    read arbitrary files. Audit uses of urllib calls to ensure user data cannot control
    the URLs, or consider using the 'requests' library instead.
  metadata:
    cwe: 'CWE-939: Improper Authorization in Handler for Custom URL Scheme'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/blacklists/calls.py#L163
    bandit-code: B310
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.eval-detected.eval-detected
  patterns:
  - pattern-not: eval("...")
  - pattern: eval(...)
  message: |
    Detected the use of eval(). eval() can be dangerous if used to evaluate
    dynamic content. If this content can be input from outside the program, this
    may be a code injection vulnerability. Ensure evaluated content is not definable
    by external sources.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.exec-detected.exec-detected
  patterns:
  - pattern-not: exec("...")
  - pattern: exec(...)
  message: |
    Detected the use of exec(). exec() can be dangerous if used to evaluate
    dynamic content. If this content can be input from outside the program, this
    may be a code injection vulnerability. Ensure evaluated content is not definable
    by external sources.
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A1: Injection'
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.ftplib.ftplib
  pattern: ftplib.$ANYTHING(...)
  message: |
    FTP does not encrypt communications by default. This can lead to sensitive
    data being exposed. Ensure use of FTP here does not expose sensitive data.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L265
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B321
    references:
    - https://docs.python.org/3/library/telnetlib.html
  severity: WARNING
  languages:
  - python
- id: python.lang.security.audit.hardcoded-password-default-argument.hardcoded-password-default-argument
  patterns:
  - pattern: |
      def $FUNC(..., password="...", ...):
        ...
  message: |
    Hardcoded password is used as a default argument to '$FUNC'. This could be dangerous if
    a real password is not supplied.
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.httpsconnection-detected.httpsconnection-detected
  patterns:
  - pattern-either:
    - pattern: httplib.HTTPSConnection(...)
    - pattern: http.client.HTTPSConnection(...)
    - pattern: six.moves.http_client.HTTPSConnection(...)
  message: |
    The HTTPSConnection API has changed frequently with minor releases of Python.
    Ensure you are using the API for your version of Python securely.
    For example, Python 3 versions prior to 3.4.3 will not verify SSL certificates by default.
    See https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
    for more information.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-295: Improper Certificate Validation'
    references:
    - https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
  severity: WARNING
  languages:
  - python
- id: python.lang.security.audit.logging.listeneval.listen-eval
  languages:
  - python
  message: |
    Because portions of the logging configuration are passed through eval(),
    use of this function may open its users to a security risk. While the
    function only binds to a socket on localhost, and so does not accept
    connections from remote machines, there are scenarios where untrusted
    code could be run under the account of the process which calls listen().
    See more details at https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
  metadata:
    cwe: 'CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code
      (''Eval Injection'')'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen
  patterns:
  - pattern: logging.config.listen(...)
  severity: WARNING
- id: python.lang.security.audit.mako-templates-detected.mako-templates-detected
  pattern: mako.template.Template(...)
  message: |
    Mako templates do not provide a global HTML escaping mechanism.
    This means you must escape all sensitive data in your templates
    using '| u' for URL escaping or '| h' for HTML escaping.
    If you are using Mako to serve web content, consider using
    a system such as Jinja2 which enables global escaping.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-Site Scripting (XSS)'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/mako_templates.py
    references:
    - https://docs.makotemplates.org/en/latest/syntax.html#expression-escaping
    - https://jinja.palletsprojects.com/en/2.11.x/intro/#
  languages:
  - python
  severity: INFO
- id: python.lang.security.audit.marshal.marshal-usage
  languages:
  - python
  message: |
    The marshal module is not intended to be secure against erroneous or maliciously constructed data.
    Never unmarshal data received from an untrusted or unauthenticated source.
    See more details: https://docs.python.org/3/library/marshal.html?highlight=security
  metadata:
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    owasp: 'A8: Insecure Deserialization'
    references:
    - https://docs.python.org/3/library/marshal.html?highlight=security
  pattern-either:
  - pattern: marshal.dump(...)
  - pattern: marshal.dumps(...)
  - pattern: marshal.load(...)
  - pattern: marshal.loads(...)
  severity: WARNING
- id: python.lang.security.audit.network.bind.avoid-bind-to-all-interfaces
  patterns:
  - pattern-either:
    - pattern: |
        $S = socket.socket(...)
        ...
        $S.bind(("0.0.0.0", ...))
    - pattern: |
        $S = socket.socket(...)
        ...
        $S.bind(("::", ...))
    - pattern: |
        $S = socket.socket(...)
        ...
        $S.bind(("", ...))
  message: |
    Running `socket.bind` to 0.0.0.0, ::, or empty string could unexpectedly
    expose the server publicly as it binds to all available interfaces. Consider
    instead getting correct address from an environment variable or
    configuration file.
  metadata:
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    owasp: 'A6: Security Misconfiguration'
  languages:
  - python
  severity: INFO
- id: python.lang.security.audit.network.http-not-https-connection.http-not-https-connection
  patterns:
  - pattern-either:
    - pattern: urllib3.HTTPConnectionPool(...)
    - pattern: urllib3.connectionpool.HTTPConnectionPool(...)
  message: |
    Detected HTTPConnectionPool. This will transmit data in cleartext.
    It is recommended to use HTTPSConnectionPool instead for to encrypt
    communications.
  metadata:
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://urllib3.readthedocs.io/en/1.2.1/pools.html#urllib3.connectionpool.HTTPSConnectionPool
  languages:
  - python
  severity: ERROR
- id: python.lang.security.audit.paramiko-implicit-trust-host-key.paramiko-implicit-trust-host-key
  patterns:
  - pattern-inside: |
      $CLIENT = paramiko.client.SSHClient(...)
      ...
      $CLIENT.set_missing_host_key_policy(...)
  - pattern-either:
    - pattern: paramiko.client.AutoAddPolicy
    - pattern: paramiko.client.WarningPolicy
  message: |
    Detected a paramiko host key policy that implicitly trusts a server's
    host key. Host keys should be verified to ensure the connection
    is not to a malicious server. Use RejectPolicy or a custom subclass
    instead.
  metadata:
    cwe: 'CWE-322: Key Exchange without Entity Authentication'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/ssh_no_host_key_verification.py
    references:
    - http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.AutoAddPolicy
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.paramiko.paramiko-exec-command.paramiko-exec-command
  patterns:
  - pattern-inside: |
      import paramiko
      ...
  - pattern: $CLIENT.exec_command(...)
  message: |
    Unverified SSL context detected. This will permit insecure connections without verifying
    SSL certificates. Use 'ssl.create_default_context()' instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/plugins/injection_paramiko.py
    owasp: 'A1: Injection'
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    references:
    - http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.exec_command
    - https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/plugins/injection_paramiko.py
  severity: WARNING
  languages:
  - python
- id: python.lang.security.audit.ssl-wrap-socket-is-deprecated.ssl-wrap-socket-is-deprecated
  pattern: ssl.wrap_socket(...)
  message: |
    'ssl.wrap_socket()' is deprecated. This function creates an insecure socket
    without server name indication or hostname matching. Instead, create an SSL
    context using 'ssl.SSLContext()' and use that to wrap a socket.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://docs.python.org/3/library/ssl.html#ssl.wrap_socket
    - https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.subprocess-shell-true.subprocess-shell-true
  pattern: subprocess.$FUNC(..., shell=True, ...)
  message: |
    Found 'subprocess' function '$FUNC' with 'shell=True'. This is dangerous because this call will spawn
    the command using a shell process. Doing so propagates current shell settings and variables, which
    makes it much easier for a malicious actor to execute commands. Use 'shell=False' instead.
  fix-regex:
    regex: (shell\s*=\s*)True
    replacement: \1False
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-78: Improper Neutralization of Special Elements used in an OS Command
      (''OS Command Injection'')'
    references:
    - https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess
    - https://docs.python.org/3/library/subprocess.html
  languages:
  - python
  severity: ERROR
- id: python.lang.security.audit.system-wildcard-detected.system-wildcard-detected
  patterns:
  - pattern-either:
    - pattern-inside: os.system("...")
    - pattern-inside: os.popen("...")
    - pattern-inside: os.popen2("...")
    - pattern-inside: os.popen3("...")
    - pattern-inside: os.popen4("...")
    - pattern-inside: subprocess.$W(..., shell=True, ...)
  - pattern-regex: (tar|chmod|chown|rsync)(.*?)\*
  message: |
    Detected use of the wildcard character in a system call that spawns a shell.
    This subjects the wildcard to normal shell expansion, which can have unintended consequences
    if there exist any non-standard file names. Consider a file named '-e sh script.sh' -- this
    will execute a script when 'rsync' is called. See
    https://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt
    for more information.
  metadata:
    cwe: 'CWE-155: Improper Neutralization of Wildcards or Matching Symbols'
    owasp: 'A1: Injection'
    source-url-open: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/injection_wildcard.py
    references:
    - https://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt
  languages:
  - python
  severity: WARNING
- id: python.lang.security.audit.telnetlib.telnetlib
  pattern: telnetlib.$ANYTHING(...)
  message: |
    Telnet does not encrypt communications. Use SSH instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L208
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B312
    references:
    - https://docs.python.org/3/library/telnetlib.html
  severity: WARNING
  languages:
  - python
- id: python.lang.security.audit.weak-ssl-version.weak-ssl-version
  patterns:
  - pattern-either:
    - pattern: ssl.PROTOCOL_SSLv2
    - pattern: ssl.PROTOCOL_SSLv3
    - pattern: ssl.PROTOCOL_TLSv1
    - pattern: ssl.PROTOCOL_TLSv1_1
    - pattern: pyOpenSSL.SSL.SSLv2_METHOD
    - pattern: pyOpenSSL.SSL.SSLv23_METHOD
    - pattern: pyOpenSSL.SSL.SSLv3_METHOD
    - pattern: pyOpenSSL.SSL.TLSv1_METHOD
    - pattern: pyOpenSSL.SSL.TLSv1_1_METHOD
  message: |
    An insecure SSL version was detected. TLS versions 1.0, 1.1, and all SSL versions
    are considered weak encryption and are deprecated.
    Use 'ssl.PROTOCOL_TLSv1_2' or higher.
  metadata:
    cwe: 'CWE-326: Inadequate Encryption Strength'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/insecure_ssl_tls.py#L30
    references:
    - https://tools.ietf.org/html/rfc7568
    - https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html
    - https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLSv1_2
  languages:
  - python
  severity: WARNING
- id: python.lang.security.deserialization.avoid-pyyaml-load.avoid-pyyaml-load
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://github.com/yaml/pyyaml/wiki/PyYAML-yaml.load(input)-Deprecation
    - https://nvd.nist.gov/vuln/detail/CVE-2017-18342
  languages:
  - python
  message: |
    Avoid using `load()`. `PyYAML.load` can create arbitrary Python
    objects. A malicious actor could exploit this to run arbitrary
    code. Use `safe_load()` instead.
  fix-regex:
    regex: load
    replacement: safe_load
    count: 1
  severity: ERROR
  patterns:
  - pattern-inside: |
      import yaml
      ...
  - pattern-not-inside: |
      $YAML = ruamel.yaml.YAML(...)
      ...
      $YAML.load(...)
  - pattern-not: yaml.load(..., Loader=yaml.CSafeLoader, ...)
  - pattern-not: yaml.load(..., Loader=yaml.SafeLoader, ...)
  - pattern: yaml.load(...)
- id: python.lang.security.deserialization.pickle.avoid-cPickle
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
  languages:
  - python
  message: |
    Avoid using `cPickle`, which is known to lead to code execution vulnerabilities.
    When unpickling, the serialized data could be manipulated to run arbitrary code.
    Instead, consider serializing the relevant data as JSON or a similar text-based
    serialization format.
  severity: WARNING
  pattern: cPickle.$FUNC(...)
- id: python.lang.security.deserialization.pickle.avoid-dill
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
  languages:
  - python
  message: |
    Avoid using `dill`, which uses `pickle`, which is known to lead to code execution vulnerabilities.
    When unpickling, the serialized data could be manipulated to run arbitrary code.
    Instead, consider serializing the relevant data as JSON or a similar text-based
    serialization format.
  severity: WARNING
  pattern-either:
  - pattern: dill.$FUNC(...)
- id: python.lang.security.deserialization.pickle.avoid-pickle
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
    - https://davidhamann.de/2020/04/05/exploiting-python-pickle/
  languages:
  - python
  message: |
    Avoid using `pickle`, which is known to lead to code execution vulnerabilities.
    When unpickling, the serialized data could be manipulated to run arbitrary code.
    Instead, consider serializing the relevant data as JSON or a similar text-based
    serialization format.
  severity: WARNING
  pattern-either:
  - pattern: pickle.$FUNC(...)
  - pattern: _pickle.$FUNC(...)
- id: python.lang.security.deserialization.pickle.avoid-shelve
  metadata:
    owasp: 'A8: Insecure Deserialization'
    cwe: 'CWE-502: Deserialization of Untrusted Data'
    references:
    - https://docs.python.org/3/library/pickle.html
  languages:
  - python
  message: |
    Avoid using `shelve`, which uses `pickle`, which is known to lead to code execution vulnerabilities.
    When unpickling, the serialized data could be manipulated to run arbitrary code.
    Instead, consider serializing the relevant data as JSON or a similar text-based
    serialization format.
  severity: WARNING
  pattern-either:
  - pattern: shelve.$FUNC(...)
- id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-md5
  pattern: hashlib.md5(...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1
  pattern: hashlib.sha1(...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B303
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.lang.security.insecure-hash-function.insecure-hash-function
  patterns:
  - pattern-either:
    - pattern: hashlib.new("=~/[M|m][D|d][4|5]/", ...)
    - pattern: hashlib.new(..., name="=~/[M|m][D|d][4|5]/", ...)
  message: |
    Detected use of an insecure MD4 or MD5 hash function.
    These functions have known vulnerabilities and are considered deprecated.
    Consider using 'SHA256' or a similar function instead.
  metadata:
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/hashlib_new_insecure_functions.py
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  languages:
  - python
  severity: WARNING
- id: python.lang.security.unquoted-csv-writer.unquoted-csv-writer
  patterns:
  - pattern-not: csv.writer(..., quoting=csv.QUOTE_ALL, ...)
  - pattern: csv.writer(...)
  message: Found an unquoted CSV writer. This is susceptible to injection. Use 'quoting=csv.QUOTE_ALL'.
  metadata:
    cwe: 'CWE-1236: Improper Neutralization of Formula Elements in a CSV File'
    owasp: 'A1: Injection'
    references:
    - https://affinity-it-security.com/how-to-prevent-csv-injection/
  fix-regex:
    regex: (.*)\)
    replacement: \1, quoting=csv.QUOTE_ALL)
  languages:
  - python
  severity: ERROR
- id: python.lang.security.unverified-ssl-context.unverified-ssl-context
  pattern: ssl._create_unverified_context(...)
  message: |
    Unverified SSL context detected. This will permit insecure connections without verifying
    SSL certificates. Use 'ssl.create_default_context()' instead.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: 'CWE-295: Improper Certificate Validation'
    references:
    - https://docs.python.org/3/library/ssl.html#ssl-security
    - https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection
  severity: ERROR
  languages:
  - python
- id: python.lang.security.use-defused-xml.use-defused-xml
  pattern-either:
  - pattern: import xml
  fix-regex:
    regex: xml
    replacement: defusedxml
  metadata:
    owasp: 'A4: XML External Entities (XXE)'
    cwe: 'CWE-611: Improper Restriction of XML External Entity Reference'
    references:
    - https://docs.python.org/3/library/xml.html
    - https://github.com/tiran/defusedxml
  message: |
    Found use of the native Python XML libraries, which is vulnerable to XML external entity (XXE)
    attacks. The Python documentation recommends the 'defusedxml' library instead. Use 'defusedxml'.
    See https://github.com/tiran/defusedxml for more information.
  languages:
  - python
  severity: ERROR
- id: python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc
  pattern-either:
  - pattern: import xmlrpclib
  - pattern: import SimpleXMLRPCServer
  - pattern: import xmlrpc
  message: |
    Detected use of xmlrpc. xmlrpc is not inherently safe from vulnerabilities.
    Use defusedxml.xmlrpc instead.
  metadata:
    cwe: 'CWE-776: Improper Restriction of Recursive Entity References in DTDs (''XML
      Entity Expansion'')'
    owasp: 'A4: XML External Entities (XXE)'
    source-rule-url: https://github.com/PyCQA/bandit/blob/07f84cb5f5e7c1055e6feaa0fe93afa471de0ac3/bandit/blacklists/imports.py#L160
    references:
    - https://pypi.org/project/defusedxml/
    - https://docs.python.org/3/library/xml.html#xml-vulnerabilities
  severity: ERROR
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-blowfish
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.Blowfish.new(...)
    - pattern: Crypto.Cipher.Blowfish.new(...)
  message: |
    Detected Blowfish cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-des
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.DES.new(...)
    - pattern: Crypto.Cipher.DES.new(...)
  message: |
    Detected DES cipher algorithm which is considered insecure. The algorithm is
    considered weak and has been deprecated. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://tools.ietf.org/html/rfc5469
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc2
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.ARC2.new(...)
    - pattern: Crypto.Cipher.ARC2.new
  message: |
    Detected RC2 cipher algorithm which is considered insecure. The algorithm has known vulnerabilities and is difficult to use securely. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://security.stackexchange.com/questions/93924/is-rc2-cbc-at-all-secure
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-rc4
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.ARC4.new(...)
    - pattern: Crypto.Cipher.ARC4.new(...)
  message: |
    Detected RC4 cipher algorithm which is considered insecure. The algorithm has many
    known vulnerabilities. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://crypto.stackexchange.com/questions/853/google-is-using-rc4-but-isnt-rc4-considered-unsafe
    - https://sweet32.info/
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-xor
  patterns:
  - pattern-either:
    - pattern: Cryptodome.Cipher.XOR.new(...)
    - pattern: Crypto.Cipher.XOR.new(...)
  message: |
    Detected XOR cipher algorithm which is considered insecure. This algorithm
    is not cryptographically secure and can be reversed easily. Use AES instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    bandit-code: B304
    references:
    - https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md2
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD2.new(...)
    - pattern: Cryptodome.Hash.MD2.new (...)
  message: |
    Detected MD2 hash algorithm which is considered insecure. This algorithm
    has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6149
    - https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2409
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md4
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD4.new(...)
    - pattern: Cryptodome.Hash.MD4.new (...)
  message: |
    Detected MD4 hash algorithm which is considered insecure. This algorithm
    has many known vulnerabilities and has been deprecated. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6150
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-md5
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.MD5.new(...)
    - pattern: Cryptodome.Hash.MD5.new (...)
  message: |
    Detected MD5 hash algorithm which is considered insecure. MD5 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://tools.ietf.org/html/rfc6151
    - https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-sha1
  patterns:
  - pattern-either:
    - pattern: Crypto.Hash.SHA.new(...)
    - pattern: Cryptodome.Hash.SHA.new (...)
  message: |
    Detected SHA1 hash algorithm which is considered insecure. SHA1 is not
    collision resistant and is therefore not suitable as a cryptographic
    signature. Use SHA256 or SHA3 instead.
  metadata:
    source-rule-url: https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59
    cwe: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html
    - https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability
    - http://2012.sharcs.org/slides/stevens.pdf
    - https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html
  severity: WARNING
  languages:
  - python
- id: python.requests.security.disabled-cert-validation.disabled-cert-validation
  patterns:
  - pattern-either:
    - pattern: requests.put(..., verify=False, ...)
    - pattern: requests.patch(..., verify=False, ...)
    - pattern: requests.delete(..., verify=False, ...)
    - pattern: requests.head(..., verify=False, ...)
    - pattern: requests.options(..., verify=False, ...)
    - pattern: requests.request(..., verify=False, ...)
    - pattern: requests.get(..., verify=False, ...)
    - pattern: requests.post(..., verify=False, ...)
  message: |
    Certificate verification has been explicitly disabled. This
    permits insecure connections to insecure servers. Re-enable
    certification validation.
  metadata:
    cwe: 'CWE-295: Improper Certificate Validation'
    owasp: 'A3: Sensitive Data Exposure'
    references:
    - https://stackoverflow.com/questions/41740361/is-it-safe-to-disable-ssl-certificate-verification-in-pythonss-requests-lib
  languages:
  - python
  severity: ERROR
- id: python.requests.security.no-auth-over-http.no-auth-over-http
  patterns:
  - pattern-either:
    - pattern: requests.$W("=~/http:\/\/.*/", ..., auth=$X, ...)
    - pattern: |
        $URL = "=~/http:\/\/.../"
        ...
        requests.$W($URL, ..., auth=$X, ...)
  fix-regex:
    regex: http:\/\/
    replacement: https://
    count: 1
  message: |
    Authentication detected over HTTP. HTTP does not provide any
    encryption or protection for these authentication credentials.
    This may expose these credentials to unauthhorized parties.
    Use 'https://' instead.
  metadata:
    cwe: 'CWE-523: Unprotected Transport of Credentials'
    owasp: 'A2: Broken Authentication'
    source-rule-url: https://pypi.org/project/flake8-flask/
    references:
    - https://blog.r2c.dev/2020/bento-check-no-auth-over-http/
    - https://bento.dev/checks/requests/no-auth-over-http/
  languages:
  - python
  severity: ERROR
- id: python.sqlalchemy.security.sqlalchemy-sql-injection.sqlalchemy-sql-injection
  patterns:
  - pattern-either:
    - pattern: |
        def $FUNC(...,$VAR,...):
          ...
          $SESSION.query(...).$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
    - pattern: |
        def $FUNC(...,$VAR,...):
          ...
          $SESSION.query.join(...).$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
    - pattern: |
        def $FUNC(...,$VAR,...):
          ...
          $SESSION.query.$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
    - pattern: |
        def $FUNC(...,$VAR,...):
          ...
          query.$SQLFUNC("...".$FORMATFUNC(...,$VAR,...))
  - metavariable-regex:
      metavariable: $SQLFUNC
      regex: (group_by|order_by|distinct|having|filter)
  - metavariable-regex:
      metavariable: $FORMATFUNC
      regex: (?!bindparams)
  message: |
    Distinct, Having, Group_by, Order_by, and Filter in SQLAlchemy can cause sql injections
    if the developer inputs raw SQL into the before-mentioned clauses.
    This pattern captures relevant cases in which the developer inputs raw SQL into the distinct, having, group_by, order_by or filter clauses and
    injects user-input into the raw SQL with any function besides "bindparams". Use bindParams to securely bind user-input
    to SQL statements.
  fix-regex:
    regex: format
    replacement: bindparams
  languages:
  - python
  severity: WARNING
- id: ruby.lang.security.no-eval.ruby-eval
  patterns:
  - pattern-either:
    - pattern: eval(...)
    - pattern: |
        $CLASS.class_eval do
          ...
        end
    - pattern: |
        $CLASS.instance_eval do
          ...
        end
    - pattern: |
        $CLASS.module_eval do
          ...
        end
    - pattern: |
        $CLASS.class_eval(...)
    - pattern: |
        $CLASS.instance_eval(...)
    - pattern: |
        $CLASS.module_eval(...)
  message: |
    Use of eval detected. This can run arbitrary code. Ensure external data
    does not reach here, otherwise this is a security vulnerability.
    Consider other ways to do this without eval.
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.filter-skipping.filter-skipping
  patterns:
  - pattern-not: |
      $CALL "=~/.*(/:action.*).*/", $ACTION
  - pattern: |
      $CALL "=~/.*(/:action.*).*/"
  message: |
    Checks for use of action in Ruby routes. This can cause Rails to render an arbitrary view if an
    attacker creates an URL accurately. Affects 3.0 applications. Can avoid the vulnerability by providing
    additional constraints.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_filter_skipping.rb
    - https://groups.google.com/g/rubyonrails-security/c/NCCsca7TEtY
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.bad-deserialization.bad-deserialization
  patterns:
  - pattern-either:
    - pattern: |
        YAML.load(...)
    - pattern: |
        CSV.load(...)
    - pattern: |
        Marshal.load(...)
    - pattern: |
        Marshal.restore(...)
    - pattern: |
        $OBJ.object_load(...)
  - pattern-not: |
      YAML.load(..., safe: true, ...)
  message: |
    Checks for unsafe deserialization. Objects in Ruby can be serialized into strings,
    then later loaded from strings. However, uses of load and object_load can cause remote code execution.
    Loading user input with YAML, MARSHAL, or CSV can potentially be dangerous. Use JSON securely instead.
  metadata:
    references:
    - https://groups.google.com/g/rubyonrails-security/c/61bkgvnSGTQ/m/nehwjA8tQ8EJ
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_deserialize.rb
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.divide-by-zero.divide-by-zero
  patterns:
  - pattern-either:
    - pattern: |
        $X / 0
    - pattern: |
        $ZERO = 0
        ...
        $X / $ZERO
  message: |
    Checks for divide by zero. Best practice involves not dividing a variable by zero, as this leads to a Ruby
    ZeroDivisionError.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_divide_by_zero.rb
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.hardcoded-http-auth-in-controller.hardcoded-http-auth-in-controller
  pattern: |
    class $CONTROLLER < ApplicationController
      ...
      http_basic_authenticate_with ..., :password => "...", ...
    end
  message: |
    Detected hardcoded password used in basic authentication in a controller
    class. Including this password in version control could expose this
    credential. Consider refactoring to use environment variables or
    configuration files.
  severity: ERROR
  metadata:
    cwe: 'CWE-798: Use of Hard-coded Credentials'
    owasp: 'A3: Sensitive Data Exposure'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/basic_auth/index.markdown
  languages:
  - ruby
- id: ruby.lang.security.force-ssl-false.force-ssl-false
  patterns:
  - pattern: |
      config.force_ssl = false
  message: |
    Checks for configuration setting of force_ssl to false. Force_ssl forces usage of HTTPS, which
    could lead to network interception of unencrypted application traffic. To fix, set config.force_ssl = true.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_force_ssl.rb
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.cookie-serialization.cookie-serialization
  patterns:
  - pattern-either:
    - pattern: |
        Rails.application.config.action_dispatch.cookies_serializer = :marshal
    - pattern: |
        Rails.application.config.action_dispatch.cookies_serializer = :hybrid
  message: |
    Checks if code allows cookies to be deserialized using Marshal. If the attacker can craft a valid cookie, this could lead to
    remote code execution. The hybrid check is just to warn users to migrate to :json for best practice.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_cookie_serialization.rb
    - https://robertheaton.com/2013/07/22/how-to-hack-a-rails-app-using-its-secret-token/
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.file-disclosure.file-disclosure
  patterns:
  - pattern: |
      config.serve_static_assets = true
  message: |
    Special requests can determine whether a file exists on a filesystem that's outside the Ruby app's
    root directory. To fix this, set config.serve_static_assets = false.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_file_disclosure.rb
    - https://groups.google.com/g/rubyonrails-security/c/23fiuwb1NBA/m/MQVM1-5GkPMJ
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.create-with.create-with
  patterns:
  - pattern-not: |
      $FUNC.create_with($PARAMSB.permit(...))
  - pattern: |
      $FUNC.create_with($PARAMSA)
  message: |
    Checks for strong parameter bypass through usage of create_with. Create_with bypasses strong parameter protection, which
    could allow attackers to set arbitrary attributes on models. To fix this vulnerability, either remove all create_with calls
    or use the permit function to specify tags that are allowed to be set.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_create_with.rb
    - https://groups.google.com/g/rubyonrails-security/c/M4chq5Sb540/m/CC1Fh0Y_NWwJ
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.no-send.bad-send
  patterns:
  - pattern-either:
    - pattern: |
        $PARAM = params[...]
        ...
        $RES = $MOD.send($PARAM.$FUNC)
    - pattern: |
        $PARAM = params[...]
        ...
        $RES = $MOD.try($PARAM.$FUNC)
    - pattern: |
        $PARAM = params[...]
        ...
        $RES = $MOD.__send__($PARAM.$FUNC)
    - pattern: |
        $PARAM = params[...]
        ...
        $RES = $MOD.public_send($PARAM.$FUNC)
  message: |
    Checks for unsafe use of Object#send, try, __send__, and public_send. These only account for unsafe
    use of a method, not target. This can lead to arbitrary calling of exit, along with arbitrary code     execution.
    Please be sure to sanitize input in order to avoid this.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_send.rb
    - https://the.igreque.info/posts/2016/01-object-send-considered-harmful-en.html
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.mass-assignment-protection-disabled.mass-assignment-protection-disabled
  pattern: $MODEL.new(params[...], ..., :without_protection => true, ...)
  message: |
    Mass assignment protection disabled for '$MODEL'. This could
    permit assignment to sensitive model fields without intention. Instead,
    use 'attr_accessible' for the model or disable mass assigment using
    'config.active_record.whitelist_attributes = true'.
    ':without_protection => true' must be removed for this to take effect.
  metadata:
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    owasp: 'A1: Injection'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/mass_assignment/index.markdown
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.ssl-mode-no-verify.ssl-mode-no-verify
  pattern: OpenSSL::SSL::VERIFY_NONE
  message: |
    Detected SSL that will accept an unverified connection.
    This makes the connections susceptible to man-in-the-middle attacks.
    Use 'OpenSSL::SSL::VERIFY_PEER' intead.
  fix-regex:
    regex: VERIFY_NONE
    replacement: VERIFY_PEER
  severity: WARNING
  languages:
  - ruby
- id: ruby.lang.security.timing-attack.timing-attack
  patterns:
  - pattern: |
      http_basic_authenticate_with ...
  message: |
    Checks for unsafe use of method http_basic_authenticate_with, which is vulnerable to timing attacks as it
    does not use constant-time checking when comparing passwords. Affected Rails versions include:
    5.0.0.beta1.1, 4.2.5.1, 4.1.14.1, 3.2.22.1. Avoid this function if possible.
  metadata:
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_basic_auth_timing_attack.rb
    - https://groups.google.com/g/rubyonrails-security/c/ANv0HDHEC3k/m/mt7wNGxbFQAJ
  languages:
  - ruby
  severity: ERROR
- id: ruby.lang.security.missing-csrf-protection.missing-csrf-protection
  patterns:
  - pattern: |
      class $CONTROLLER < ActionController::Base
        ...
      end
  - pattern-not: |
      class $CONTROLLER < ActionController::Base
        ...
        protect_from_forgery :with => :exception
      end
  - pattern-not: |
      class $CONTROLLER < ActionController::Base
        ...
        protect_from_forgery prepend: true, with: :exception
      end
  message: |
    Detected controller which does not enable cross-site request forgery
    protections using 'protect_from_forgery'. Add
    'protect_from_forgery :with => :exception' to your controller class.
  severity: ERROR
  metadata:
    cwe: 'CWE-352: Cross-Site Request Forgery (CSRF)'
    owasp: 'A6: Security Misconfiguration'
    source-rule-url: https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross-site_request_forgery/index.markdown
  languages:
  - ruby
- id: ruby.lang.security.weak-hashes-md5.weak-hashes-md5
  patterns:
  - pattern-either:
    - pattern: Digest::MD5.base64digest $X
    - pattern: Digest::MD5.hexdigest $X
    - pattern: Digest::MD5.digest $X
    - pattern: Digest::MD5.new
    - pattern: OpenSSL::Digest::MD5.base64digest $X
    - pattern: OpenSSL::Digest::MD5.hexdigest $X
    - pattern: OpenSSL::Digest::MD5.digest $X
    - pattern: OpenSSL::Digest::MD5.new
  message: |
    Should not use md5 to generate hashes. md5 is proven to be vulnerable through the use of brute-force attacks.
    Could also result in collisions,leading to potential collision attacks. Use SHA256 or other hashing functions instead.
  metadata:
    references:
    - https://www.ibm.com/support/pages/security-bulletin-vulnerability-md5-signature-and-hash-algorithm-affects-sterling-integrator-and-sterling-file-gateway-cve-2015-7575
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.weak-hashes-sha1.weak-hashes-sha1
  patterns:
  - pattern-either:
    - pattern: Digest::SHA1.$FUNC $X
    - pattern: Digest::SHA1.$FUNC
    - pattern: OpenSSL::Digest::SHA1.$FUNC $X
    - pattern: OpenSSL::Digest::SHA1.$FUNC
    - pattern: OpenSSL::HMAC.$FUNC("sha1",...)
  message: |
    Should not use SHA1 to generate hashes. There is a proven SHA1 hash collision by Google, which could lead to vulnerabilities.
    Use SHA256, SHA3 or other hashing functions instead.
  metadata:
    references:
    - https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html
    - https://shattered.io/
  languages:
  - ruby
  severity: WARNING
- id: ruby.lang.security.unprotected-mass-assign.mass-assignment-vuln
  patterns:
  - pattern-either:
    - pattern: |
        $MOD.new(params[$CODE])
    - pattern: |
        $MOD.new(..., params[$CODE], :without_protection => true, ...)
  - pattern-not-inside: |
      attr_accessible $VAR
      ...
      $MOD.new(params[$CODE])
  message: |
    Checks for calls to without_protection during mass assignment (which allows record creation from hash values).
    This can lead to users bypassing permissions protections. For Rails 4 and higher, mass protection is on by default.
    Fix: Don't use :without_protection => true. Instead, configure attr_acessible to control attribute access.
  metadata:
    owasp: 'A1: Injection'
    cwe: 'CWE-915: Improperly Controlled Modification of Dynamically-Determined Object
      Attributes'
    references:
    - https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_without_protection.rb
    - https://www.acunetix.com/vulnerabilities/web/rails-mass-assignment/
  languages:
  - ruby
  severity: WARNING
- id: typescript.react.security.react-controlled-component-password.react-controlled-component-password
  pattern-either:
  - pattern: <$EL type="password" value={this.state.$X} onChange=...  />
  - pattern: |
      React.createElement($EL,{type: 'password', value: this.state.$X, onChange:...},...)
  - pattern: |
      $PARAMS = {type: 'password', value: this.state.$X, onChange:...};
      ...
      React.createElement($EL,$PARAMS,...);
  message: |
    Password can be leaked if CSS injection exists on the page.
  metadata:
    references:
    - https://no-csp-css-keylogger.badsite.io/
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.react-insecure-request.react-insecure-request
  patterns:
  - pattern-either:
    - patterns:
      - pattern-either:
        - pattern-inside: |
            import $AXIOS from 'axios';
            ...
        - pattern-inside: |
            $AXIOS = require('axios');
            ...
      - pattern-either:
        - pattern: $AXIOS.$METHOD($URL,...)
        - pattern: |
            $VAR = $URL;
            ...
            $AXIOS.$METHOD($VAR,...);
        - pattern: |
            $AXIOS({url: $URL},...)
        - pattern: |
            $VAR = {url: $URL};
            ...
            $AXIOS($VAR,...);
    - pattern: fetch($URL,...)
    - pattern: |
        $VAR = $URL;
        ...
        fetch($VAR,...);
  - metavariable-regex:
      metavariable: $URL
      regex: '["''](http://).*[''"]'
  message: |
    Unencrypted request over HTTP detected.
  metadata:
    vulnerability: Insecure Transport
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-319: Cleartext Transmission of Sensitive Information'
    references:
    - https://www.npmjs.com/package/axios
  languages:
  - typescript
  - javascript
  severity: ERROR
- id: typescript.react.security.react-markdown-insecure-html.react-markdown-insecure-html
  patterns:
  - pattern-either:
    - pattern-inside: |
        $X = require('react-markdown/with-html');
        ...
    - pattern-inside: |
        $X = require('react-markdown');
        ...
    - pattern-inside: |
        import 'react-markdown/with-html';
        ...
    - pattern-inside: |
        import 'react-markdown';
        ...
  - pattern-either:
    - pattern: |
        <$EL allowDangerousHtml />
    - pattern: |
        <$EL transformLinkUri=... />
    - pattern: |
        <$EL transformImageUri=... />
  message: |
    Overwriting `transformLinkUri` or `transformImageUri` to something insecure or turning `allowDangerousHtml` on, will open code up to XSS vectors.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://www.npmjs.com/package/react-markdown#security
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-dangerouslysetinnerhtml.react-dangerouslysetinnerhtml
  pattern-either:
  - pattern: |
      <$X dangerouslySetInnerHTML=... />
  - pattern: |
      {dangerouslySetInnerHTML: ...}
  message: "Setting HTML from code is risky because it\u2019s easy to inadvertently
    expose your users to a cross-site scripting (XSS) attack.\n"
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://reactjs.org/docs/dom-elements.html#dangerouslysetinnerhtml
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-css-injection.react-css-injection
  patterns:
  - pattern-either:
    - pattern-inside: |
        import $STYLE from "...";
        ...
    - pattern-inside: |
        $STYLE = $METHOD(...);
        ...
    - pattern-inside: |
        function $FUNC(...,{$STYLE},...) {
          ...
        }
    - pattern-inside: |
        function $FUNC(...,$STYLE,...) {
          ...
        }
  - pattern-inside: |
      <$EL style={$STYLE} />
  - pattern-not-inside: |
      <$EL style={{$X:...}} />
  - pattern: $STYLE
  message: |
    User controlled data in a `style` attribute is an anti-pattern than can lead to XSS vulnerabilities
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: typescript.react.security.audit.react-http-leak.react-http-leak
  pattern-either:
  - patterns:
    - pattern: |
        <$EL codebase=... />
    - metavariable-regex:
        metavariable: $EL
        regex: applet|object
    - pattern-not: |
        <$EL codebase="..." />
  - patterns:
    - pattern: |
        <$EL cite=... />
    - metavariable-regex:
        metavariable: $EL
        regex: blockquote|del|ins|q
    - pattern-not: |
        <$EL cite="..." />
  - patterns:
    - pattern: |
        <$EL longdesc=... />
    - metavariable-regex:
        metavariable: $EL
        regex: frame|iframe|img
    - pattern-not: |
        <$EL longdesc="..." />
  - patterns:
    - pattern: |
        <$EL src={$INJECT} />
    - metavariable-regex:
        metavariable: $EL
        regex: frame|iframe|img|input|script|audio|source|track|embed|video
    - pattern-not: |
        <$EL src="..." />
    - pattern-not-inside: |
        import $INJECT from "...";
        ...
  - patterns:
    - pattern: |
        <$EL usemap=... />
    - metavariable-regex:
        metavariable: $EL
        regex: img|input|object
    - pattern-not: |
        <$EL usemap="..." />
  - patterns:
    - pattern: |
        <$EL formaction=... />
    - metavariable-regex:
        metavariable: $EL
        regex: button|input
    - pattern-not: |
        <$EL formaction="..." />
  - patterns:
    - pattern: |
        <$EL srcset=... />
    - metavariable-regex:
        metavariable: $EL
        regex: img|source
    - pattern-not: |
        <$EL srcset="..." />
  - patterns:
    - pattern: |
        <$EL archive=... />
    - metavariable-regex:
        metavariable: $EL
        regex: object|applet
    - pattern-not: |
        <$EL archive="..." />
  - patterns:
    - pattern: |
        <body background=... />
    - pattern-not: |
        <body background="..." />
  - patterns:
    - pattern: |
        <form action=... />
    - pattern-not: |
        <form action="..." />
  - patterns:
    - pattern: |
        <head profile=... />
    - pattern-not: |
        <head profile="..." />
  - patterns:
    - pattern: |
        <object $ATTR=... />
    - metavariable-regex:
        metavariable: $ATTR
        regex: classid|data
    - pattern-not: |
        <object $ATTR="..." />
  - patterns:
    - pattern: |
        <video poster=... />
    - pattern-not: |
        <video poster="..." />
  - patterns:
    - pattern: |
        <command icon=... />
    - pattern-not: |
        <command icon="..." />
  - patterns:
    - pattern: |
        <html manifest=... />
    - pattern-not: |
        <html manifest="..." />
  - patterns:
    - pattern: |
        <meta content=... />
    - pattern-not: |
        <meta content="..." />
  message: This HTML element '$EL' and attribute '$ATTR' together may load an external
    resource. This means that if dynamic content can enter this attribute it may be
    possible for an attacker to send HTTP requests to unintended locations which may
    leak data about your users. If this element is reaching out to a known host, consider
    hardcoding the host (or loading from a configuration) and appending the dynamic
    path. See https://github.com/cure53/HTTPLeaks for more information.
  metadata:
    owasp: 'A3: Sensitive Data Exposure'
    cwe: 'CWE-200: Exposure of Sensitive Information to an Unauthorized Actor'
    references:
    - https://github.com/cure53/HTTPLeaks
  languages:
  - typescript
  - javascript
  severity: WARNING
- id: json.aws.security.public-s3-policy-statement.public-s3-policy-statement
  pattern: |
    {
      "Effect": "Allow",
      "Principal": "*",
      "Resource": [
        ..., "=~/arn:aws:s3.*/", ...
      ],
      ...
    }
  message: |
    Detected public s3 bucket policy. This policy allows anyone to access
    certain properties of or items in the bucket. Do not do this unless you
    will never have sensitive data inside the bucket.
  metadata:
    owasp: 'A6: Security Misconfiguration'
    cwe: CWE-264 - Permissions, Privileges, and Access Controls
    references:
    - https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteAccessPermissionsReqd.html
  severity: WARNING
  languages:
  - json
- id: terraform.lang.security.ebs-unencrypted-volume.unencrypted-ebs-volume
  patterns:
  - pattern-either:
    - pattern: |
        {...}
  - pattern-not-inside: |
      resource "aws_ebs_volume" "..." {... encrypted=true ...}
  - pattern-inside: |
      resource "aws_ebs_volume" "..." {...}
  languages:
  - generic
  paths:
    include:
    - '*.tf'
  message: |
    An EBS volume is configured without encryption enabled.
  severity: WARNING
- id: terraform.lang.security.eks-public-endpoint-enabled.eks-public-endpoint-enabled
  patterns:
  - pattern-either:
    - pattern: |
        {...}
  - pattern-inside: |
      resource "aws_eks_cluster" "..." {...}
  - pattern-not-inside: |
      {... vpc_config{... endpoint_public_access = false ...} ...}
  languages:
  - generic
  paths:
    include:
    - '*.tf'
  message: |
    The vpc_config resource inside the eks cluster has not explicitly disabled public endpoint access
  severity: WARNING
- id: terraform.lang.security.s3-cors-all-origins.all-origins-allowed
  patterns:
  - pattern-inside: cors_rule { ... }
  - pattern: allowed_origins = ["*"]
  languages:
  - generic
  paths:
    include:
    - '*.tf'
  severity: WARNING
  message: CORS rule on bucket permits any origin
  metadata:
    references:
    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#using-cors
- id: terraform.lang.security.s3-public-rw-bucket.s3-public-rw-bucket
  pattern: acl = "public-read-write"
  languages:
  - generic
  paths:
    include:
    - '*.tf'
  severity: ERROR
  message: S3 bucket with public read-write access detected.
  metadata:
    references:
    - https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#acl
    - https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl
- id: html.security.missing-noopener.missing-noopener
  patterns:
  - pattern: |
      <a ... target="_blank" ... >
  - pattern-not-inside: |
      <a ... rel="... noopener ..." ... >
  paths:
    include:
    - '*.html'
  message: This anchor tag with 'target="_blank"' is missing 'noopener'. A page opened
    with 'target="_blank"' can access the window object of the origin page. This means
    it can manipulate the 'window.opener' property, which could redirect the origin
    page to a malicious URL. This is called reverse tabnabbing. To prevent this, include
    'rel=noopener' on this tag
  severity: WARNING
  languages:
  - generic
- id: html.security.missing-noreferrer.missing-noreferrer
  patterns:
  - pattern: |
      <a ... target="_blank" ...>
  - pattern-not-inside: |
      <a ... rel="... noreferrer ..." ... >
  paths:
    include:
    - '*.html'
  message: This anchor tag with 'target="_blank"' is missing 'noreferrer'. A page
    opened with 'target="_blank"' can access the window object of the origin page.
    This means it can manipulate the 'window.opener' property, which could redirect
    the origin page to a malicious URL. This is called reverse tabnabbing. To prevent
    this, include 'rel=noreferrer' on this tag.
  severity: WARNING
  languages:
  - generic
- id: generic.html-templates.security.unquoted-attribute-var.unquoted-attribute-var
  message: 'Detected a unquoted template variable as an attribute. If unquoted, a
    malicious actor could inject custom JavaScript handlers. To fix this, add quotes
    around the template expression, like this: "{{ expr }}".'
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss
  languages:
  - generic
  paths:
    include:
    - '*.html'
    - '*.mustache'
    - '*.hbs'
  severity: WARNING
  patterns:
  - pattern-inside: <$TAG ...>
  - pattern-not-inside: ="..."
  - pattern-not-inside: ='...'
  - pattern: '{{ ... }}'
  fix-regex:
    regex: '{{(.*?)}}'
    replacement: '"{{\1}}"'
- id: generic.html-templates.security.var-in-href.var-in-href
  message: Detected a template variable used in an anchor tag with the 'href' attribute.
    This allows a malicious actor to input the 'javascript:' URI and is subject to
    cross- site scripting (XSS) attacks. If using Flask, use 'url_for()' to safely
    generate a URL. If using Django, use the 'url' filter to safely generate a URL.
    If using Mustache, use a URL encoding library, or prepend a slash '/' to the variable
    for relative links (`href="/{{link}}"`). You may also consider setting the Content
    Security Policy (CSP) header.
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss#:~:text=javascript:%20URI
    - https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#url
    - https://github.com/pugjs/pug/issues/2952
    - https://content-security-policy.com/
  languages:
  - generic
  paths:
    include:
    - '*.html'
    - '*.mustache'
    - '*.hbs'
  severity: WARNING
  patterns:
  - pattern-inside: <a ...>
  - pattern-either:
    - pattern: href = {{ ... }}
    - pattern: href = "{{ ... }}"
    - pattern: href = '{{ ... }}'
  - pattern-not-inside: href = {{ url_for(...) ... }}
  - pattern-not-inside: href = "{{ url_for(...) ... }}"
  - pattern-not-inside: href = '{{ url_for(...) ... }}'
  - pattern-not-inside: href = "/{{ ... }}"
  - pattern-not-inside: href = '/{{ ... }}'
- id: generic.html-templates.security.var-in-script-tag.var-in-script-tag
  message: Detected a template variable used in a script tag. Although template variables
    are HTML escaped, HTML escaping does not always prevent cross-site scripting (XSS)
    attacks when used directly in JavaScript. If you need this data on the rendered
    page, consider placing it in the HTML portion (outside of a script tag). Alternatively,
    use a JavaScript-specific encoder, such as the one available in OWASP ESAPI. For
    Django, you may also consider using the 'json_script' template tag and retrieving
    the data in your script by using the element ID (e.g., `document.getElementById`).
  metadata:
    cwe: 'CWE-79: Improper Neutralization of Input During Web Page Generation (''Cross-site
      Scripting'')'
    owasp: 'A7: Cross-site Scripting (XSS)'
    references:
    - https://adamj.eu/tech/2020/02/18/safely-including-data-for-javascript-in-a-django-template/?utm_campaign=Django%2BNewsletter&utm_medium=rss&utm_source=Django_Newsletter_12A
    - https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough
    - https://github.com/ESAPI/owasp-esapi-js
  languages:
  - generic
  paths:
    include:
    - '*.mustache'
    - '*.hbs'
    - '*.html'
  severity: WARNING
  patterns:
  - pattern-inside: <script ...> ... </script>
  - pattern: '{{ ... }}'
- id: generic.dockerfile.security.last-user-is-root.last-user-is-root
  patterns:
  - pattern: USER $ROOT
  - pattern-not-inside: |
      USER $ROOT
      ...
      ...
      USER $OTHER
  - metavariable-regex:
      metavariable: $ROOT
      regex: root
  message: The last user in the container is 'root'. This is a security hazard because
    if an attacker gains control of the container they will have root access. Switch
    back to another user after running commands as 'root'.
  severity: ERROR
  languages:
  - generic
  metadata:
    source-rule-url: https://github.com/hadolint/hadolint/wiki/DL3002
    references:
    - https://github.com/hadolint/hadolint/wiki/DL3002
  paths:
    include:
    - '*dockerfile*'
    - '*Dockerfile*'
- id: generic.nginx.security.alias-path-traversal.alias-path-traversal
  patterns:
  - pattern: |
      location ... {
        ...
        alias ...;
        ...
      }
  - pattern-not-inside: location /.../ { ... ... }
  paths:
    include:
    - '*.conf'
    - '*.vhost'
    - sites-available/*
    - sites-enabled/*
  fix-regex:
    regex: location\s+([A-Za-z0-9/-_\.]+)
    replacement: location \1/
  languages:
  - generic
  severity: WARNING
  message: The alias in this location block is subject to a path traversal because
    the location path does not end in a path separator (e.g., '/'). To fix, add a
    path separator to the end of the path.
  metadata:
    references:
    - https://github.com/yandex/gixy/blob/master/docs/en/plugins/aliastraversal.md
- id: generic.nginx.security.dynamic-proxy-host.dynamic-proxy-host
  patterns:
  - pattern-either:
    - pattern: proxy_pass $SCHEME://$$HOST ...;
    - pattern: proxy_pass $$SCHEME://$$HOST ...;
  paths:
    include:
    - '*.conf'
    - '*.vhost'
    - sites-available/*
    - sites-enabled/*
  languages:
  - generic
  severity: WARNING
  message: The host for this proxy URL is dynamically determined. This can be dangerous
    if the host can be injected by an attacker because it may forcibly alter destination
    of the proxy. Consider hardcoding acceptable destinations and retrieving them
    with 'map' or something similar.
  metadata:
    references:
    - https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md
    - https://nginx.org/en/docs/http/ngx_http_map_module.html
- id: generic.nginx.security.dynamic-proxy-scheme.dynamic-proxy-scheme
  patterns:
  - pattern: proxy_pass $$SCHEME:// ...;
  paths:
    include:
    - '*.conf'
    - '*.vhost'
    - sites-available/*
    - sites-enabled/*
  languages:
  - generic
  severity: WARNING
  message: The protocol shceme for this proxy is dynamically determined. This can
    be dangerous if the scheme can be injected by an attacker because it may forcibly
    alter the connection scheme. Consider hardcoding a scheme for this proxy.
  metadata:
    references:
    - https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md
- id: generic.nginx.security.header-injection.header-injection
  pattern: |
    location ... <$VARIABLE> ... {
      ...
      add_header ... $$VARIABLE
      ...
    }
  paths:
    include:
    - '*.conf'
    - '*.vhost'
    - sites-available/*
    - sites-enabled/*
  languages:
  - generic
  severity: ERROR
  message: 'The $$VARIABLE path parameter is added as a header in the response. This
    could allow an attacker to inject a newline and add a new header into the response.
    This is called HTTP response splitting. To fix, do not allow whitespace in the
    path parameter: ''[^\s]+''.'
  metadata:
    references:
    - https://github.com/yandex/gixy/blob/master/docs/en/plugins/httpsplitting.md
    - https://owasp.org/www-community/attacks/HTTP_Response_Splitting
- id: generic.nginx.security.header-redefinition.header-redefinition
  patterns:
  - pattern-inside: |
      server {
        ...
        add_header ...;
        ...
        ...
      }
  - pattern-inside: |
      location ... {
        ...
        ...
      }
  - pattern: add_header ...;
  paths:
    include:
    - '*.conf'
    - '*.vhost'
    - sites-available/*
    - sites-enabled/*
  languages:
  - generic
  severity: WARNING
  message: The 'add_header' directive is called in a 'location' block after headers
    have been set at the server block. Calling 'add_header' in the location block
    will actually overwrite the headers defined in the server block, no matter which
    headers are set. To fix this, explicitly set all headers or set all headers in
    the server block.
  metadata:
    references:
    - https://github.com/yandex/gixy/blob/master/docs/en/plugins/addheaderredefinition.md
- id: generic.nginx.security.insecure-redirect.insecure-redirect
  patterns:
  - pattern-either:
    - pattern: rewrite ... redirect
    - pattern: rewrite ... permanent
  - pattern-not-inside: rewrite ... https ... $host ... redirect
  - pattern-not-inside: rewrite ... https ... $host ... permanent
  paths:
    include:
    - '*.conf'
    - '*.vhost'
    - sites-available/*
    - sites-enabled/*
  message: |
    Detected an insecure redirect in this nginx configuration.
    If no scheme is specified, nginx will forward the request with the
    incoming scheme. This could result in unencrypted communications.
    To fix this, include the 'https' scheme.
  languages:
  - generic
  severity: WARNING
- id: generic.nginx.security.insecure-ssl-version.insecure-ssl-version
  patterns:
  - pattern-not: ssl_protocols TLSv1.2 TLSv1.3;
  - pattern-not: ssl_protocols TLSv1.3 TLSv1.2;
  - pattern-not: ssl_protocols TLSv1.2;
  - pattern-not: ssl_protocols TLSv1.3;
  - pattern: ssl_protocols ...;
  paths:
    include:
    - '*.conf'
    - '*.vhost'
    - sites-available/*
    - sites-enabled/*
  languages:
  - generic
  severity: WARNING
  message: Detected use of an insecure SSL version. Secure SSL versions are TLSv1.2
    and TLS1.3; older versions are known to be broken and are susceptible to attacks.
    Prefer use of TLSv1.2 or later.
  metadata:
    references:
    - https://www.acunetix.com/blog/web-security-zone/hardening-nginx/
    - https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/
- id: generic.nginx.security.missing-internal.missing-internal
  patterns:
  - pattern-inside: |
      location ... {
        ...
        ...
      }
  - pattern-not-inside: |
      location ... {
        ...
        internal;
        ...
      }
  - pattern: proxy_pass ...;
  paths:
    include:
    - '*.conf'
    - '*.vhost'
    - sites-available/*
    - sites-enabled/*
  languages:
  - generic
  severity: WARNING
  message: This location block contains a 'proxy_pass' directive but does not contain
    the 'internal' directive. The 'internal' directive restricts access to this location
    to internal requests. Without 'internal', an attacker could use your server for
    server-side request forgeries (SSRF). Include the 'internal' directive in this
    block to limit exposure.
  metadata:
    references:
    - https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md
    - https://nginx.org/en/docs/http/ngx_http_core_module.html#internal
- id: generic.nginx.security.missing-ssl-version.missing-ssl-version
  patterns:
  - pattern: server { ... listen $PORT ssl; ... }
  - pattern-not-inside: server { ... ssl_protocols ... }
  paths:
    include:
    - '*.conf'
    - '*.vhost'
    - sites-available/*
    - sites-enabled/*
  languages:
  - generic
  severity: WARNING
  message: This server configuration is missing the 'ssl_protocols' directive. By
    default, this server will use 'ssl_protocols TLSv1 TLSv1.1 TLSv1.2', and versions
    older than TLSv1.2 are known to be broken. Explicitly specify 'ssl_protocols TLSv1.2
    TLSv1.3' to use secure TLS versions.
  metadata:
    references:
    - https://www.acunetix.com/blog/web-security-zone/hardening-nginx/
    - https://nginx.org/en/docs/http/configuring_https_servers.html
