taint-mode: In 0.94.0 we made that when a `pattern-source` (or `pattern-sanitizer`)
matched a variable exactly, this was understood as that variable being tainted
(sanitized, resp.) by side-effect. For example, given `tainted(x)` we would taint `x`
by side-effect, and subsequent occurrences of `x` were also considered tainted.
This allowed to write rules like `c.lang.security.use-after-free.use-after-free`
in a very succint way, and it also addressed some limitations of the workarounds that
were being used to simulate this until then.

This worked well initially, or so we thought, until in 0.113.0 we added
field-sensitivity to taint-mode, and in subsequent versions we made sources and
sanitizers apply by side-effect to more kinds of l-values than just simple variables.
It was then that we started to see regressions that were fairly unintuitive for users.
For example, if `$_GET['foo']` was a taint source, this would make `$_GET` itself to
be tainted by side-effect, and a subsequent expression like `$_GET['bar']` was also
considered tainted.

We now correct the situation by adding the `by-side-effect` option to sources and
sanitizers, and requiring this option to be explicitly enabled
(that is, `by-side-effect: true`) in order to apply the source or the sanitizer by
side-effect. Otherwise, the default is that sources and sanitizers matching l-values
apply only to the precise occurrences that they match.
