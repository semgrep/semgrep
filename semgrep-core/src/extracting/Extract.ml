(* Cooper Pierce
 *
 * Copyright (c) 2022 r2c
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)

module In = Input_to_core_j

let logger = Logging.get_logger [ __MODULE__ ]

(*****************************************************************************)
(* Purpose *)
(*****************************************************************************)
(* This module implements the logic for performing extractions dictated by any
   extract mode rules.

   This entails:
    - finding any matches in the provided targets generated by the given
      extract rules
    - combining (or not) these matches depending on the settings in the extract
      rule
    - producing new targets from the combined/processed matches
    - producing a mechanism for the caller to map matches found in the
      generated targets to matches in the original file
*)

let ( let* ) = Option.bind

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

(* from Run_semgrep *)
let mk_rule_table rules =
  let rule_pairs = Common.map (fun r -> (fst r.Rule.id, r)) rules in
  Common.hash_of_list rule_pairs

(*****************************************************************************)
(* Main logic *)
(*****************************************************************************)

(** This is the main function which performs extraction of the matches
   generated by extract mode rules.

   The resulting extracted regions will be combined appropiate to the rule's
   settings, and (a) target(s) along with a function to translate results back
   to the original file will be produced.
 *)
let extract_nested_lang ~match_hook ~timeout ~timeout_threshold
    (erules : Rule.extract_rule list) xtarget rule_ids =
  let erule_table = mk_rule_table erules in
  let res =
    Match_rules.check ~match_hook ~timeout ~timeout_threshold
      (Config_semgrep.default_config, [] (* no equiv *))
      (erules :> Rule.rules)
      xtarget
  in
  (* mode for combination *)
  (* match combine with
     | "separate" -> *)
  res.Report.matches
  |> List.filter_map (fun m ->
         match
           Common.find_some_opt
             (fun (x, mvar) ->
               match
                 Hashtbl.find_opt erule_table m.Pattern_match.rule_id.id
               with
               | None -> None
               | Some r ->
                   let (`Extract { Rule.extract; _ }) = r.mode in
                   if x = extract then Some (r, Some mvar) else Some (r, None))
             m.Pattern_match.env
         with
         | Some (erule, Some extract_mvalue) ->
             (* Note: char/line offset should be relative to the extracted
              * portion, _not_ the whole pattern!
              *)
             let* ( (char_offset, line_offset, col_offset),
                    (start_extract_pos, end_extract_pos) ) =
               match
                 Metavariable.mvalue_to_any extract_mvalue
                 |> Visitor_AST.range_of_any_opt
                 |> Option.map (fun (start_loc, end_loc) ->
                        let end_len = String.length end_loc.Parse_info.str in
                        ( ( start_loc.Parse_info.charpos,
                            (* subtract 1 because lines are 1-indexed, so the offset is
                             * one less than the current line *)
                            start_loc.line - 1,
                            start_loc.column ),
                          (start_loc.charpos, end_loc.charpos + end_len) ))
               with
               | Some x -> Some x
               | None ->
                   logger#error
                     "In rule %s the extract metavariable (%s) did not have a \
                      corresponding source range"
                     (fst erule.id)
                     (let (`Extract { Rule.extract; _ }) = erule.mode in
                      extract);
                   None
             in
             let source_file = open_in_bin m.file in
             let extract_size = end_extract_pos - start_extract_pos in
             seek_in source_file start_extract_pos;
             let contents = really_input_string source_file extract_size in
             logger#trace
               "Extract rule %s extracted the following from %s at  bytes %d-%d\n\
                %s"
               m.rule_id.id m.file start_extract_pos end_extract_pos contents;
             let f : Common.dirname = Common.new_temp_file "extracted" m.file in
             Common2.write_file ~file:f contents;
             let target =
               {
                 In.path = f;
                 language =
                   (let (`Extract { Rule.dst_lang; _ }) = erule.mode in
                    dst_lang)
                   |> Lang.show;
                 rule_ids;
               }
             in
             (* Make result mapping function *)
             let map_loc (loc : Parse_info.token_location) =
               (* this _shouldn't_ be a fake location *)
               {
                 loc with
                 charpos = loc.charpos + char_offset;
                 line = loc.line + line_offset;
                 column =
                   (if loc.line = 1 then loc.column + col_offset
                   else loc.column);
                 file = xtarget.file;
               }
             in
             let map_res (mr : Report.partial_profiling Report.match_result) =
               {
                 Report.matches =
                   Common.map
                     (fun (m : Pattern_match.t) ->
                       {
                         m with
                         file = xtarget.file;
                         range_loc = Common2.pair map_loc m.range_loc;
                       })
                     mr.matches;
                 errors =
                   Common.map
                     (fun (e : Semgrep_error_code.error) ->
                       { e with loc = map_loc e.loc })
                     mr.errors;
                 skipped_targets =
                   Common.map
                     (fun (st : Output_from_core_t.skipped_target) ->
                       {
                         st with
                         path = (if st.path = f then xtarget.file else st.path);
                       })
                     mr.skipped_targets;
                 profiling = { mr.profiling with Report.file = xtarget.file };
               }
             in
             Some (target, map_res)
         | Some ({ mode = `Extract { extract; _ }; id = id, _; _ }, None) ->
             logger#warning
               "The extract metavariable for rule %s (%s) wasn't bound in a \
                match; skipping extraction for this match"
               id extract;
             None
         | None ->
             (* Cannot fail to lookup rule in hashtable just created from rules used for query *)
             raise Common.Impossible)
