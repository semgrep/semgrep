(* Nat Mote
 *
 * Copyright (C) 2019-2022 r2c
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file LICENSE.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * LICENSE for more details.
 *)

open Common
module G = AST_generic
module B = Immutable_buffer

let b = B.of_string
let combine = B.combine

(******************************************************************************)
(* UglyPrinter prints syntactically-correct code without attempting to format it
 * nicely (as opposed to a pretty printer such as those based on Wadler's "A
 * prettier printer" [1]). It would be difficult, if not impossible, to print
 * code that conforms to everyone's style guides, linters, and formatters, so
 * the prettifying of code is left to other tools.
 *
 * UglyPrinter can print code snippets, not just full programs. Any of the
 * `print_` methods can be used by consumers.
 *
 * If UglyPrinter encounters a construct that it is unable to handle, it returns
 * `None`. It is crucial that maintainers preserve this property, since
 * otherwise it is possible that we could present syntactically-incorrect code
 * as part of, for example, an autofix.
 *
 * Classes are used here so that we can take advantage of inheritance for
 * implementation-sharing and dynamic dispatch. Dynamic dispatch allows for the
 * hybrid printer used for autofix, where we use the original text from the
 * target or pattern for nodes that have been lifted unchanged. This is
 * implemented by inheriting from the plain printer. With a different
 * architecture, printer authors would need to deal with the logic for this.
 * This way, printer authors need only focus on printing AST correctly.
 *
 * OCaml's powerful object system will also allow us to share implementation
 * between printers to whatever extent is appropriate. `Pretty_print_AST`, for
 * example, gates on language within each function. We could replicate that here
 * if we like.
 *
 * This module should replace `Pretty_print_AST`. The main motivator for
 * creating a new printer module is that the use of classes allows for the
 * hybrid printer in autofix, as described above. `Pretty_print_AST` also does
 * not consistently report when it is unable to print a node correctly. We can
 * address that as we migrate it here.
 *
 * [1] https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf *)
(******************************************************************************)

class type printer_t =
  object
    method print_any : G.any -> Immutable_buffer.t option
    method print_expr : G.expr -> Immutable_buffer.t option
    method print_expr_kind : G.expr_kind -> Immutable_buffer.t option
    method print_argument : G.argument -> Immutable_buffer.t option
    method print_arguments : G.arguments -> Immutable_buffer.t option

    (* TODO Add more nodes as needed. *)
  end

(* Some if and only if `f` returns `Some` for all elements. Short circuits when
 * the first `None` is encountered.
 *
 * TODO Make tail recursive?
 * TODO Move to Common?
 *)
let rec map_all f = function
  | [] -> Some []
  | hd :: tl ->
      let* hd = f hd in
      let* tl = map_all f tl in
      Some (hd :: tl)

(* We could consider partially replacing this with an autogenerated reduce
 * visitor, where `plus` simply returns None. That could cut down on the
 * boilerplate of handling e.g. the any case, but since every node needs to be
 * handled explicitly for complete pretty-printing, it might be more trouble
 * than it's worth. *)
class base_printer : printer_t =
  object (self)
    method print_any =
      function
      | G.E expr -> self#print_expr expr
      | G.Ar arg -> self#print_argument arg
      (* TODO Handle other kinds *)
      | _ -> None

    method print_expr { e; _ } = self#print_expr_kind e
    method print_expr_kind _ = None
    method print_argument _ = None
    method print_arguments _ = None

    (* TODO Add more nodes as needed. *)
  end

class python_printer : printer_t =
  object (self)
    inherit base_printer

    method! print_arguments (_b1, args, _b2) =
      let* args = map_all self#print_argument args in
      (* TODO Consider using original tokens for parens when available? *)
      Some (combine [ b "("; combine ~sep:", " args; b ")" ])

    method! print_expr_kind =
      function
      | G.Call (e, args) ->
          let* e = self#print_expr e in
          let* args = self#print_arguments args in
          Some (combine [ e; args ])
      | G.N (G.Id ((str, _), _)) -> Some (b str)
      | _ -> None
  end
