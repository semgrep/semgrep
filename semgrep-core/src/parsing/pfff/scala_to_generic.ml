(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_visitor.cmo  pr_o.cmo /tmp/xxx.ml  *)

open AST_scala

[@@@warning "-27-26-32"]

let v_tok v =
  (* Parse_info.v_t v *)
  ()

let v_string _ = ()

let v_int _ = ()

let v_float _ = ()

let v_bool _ = ()

let v_list f xs = List.iter f xs

let v_option f x = Common.do_option f x

let v_wrap _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = v_tok v2 in
  ()

let v_bracket _of_a (v1, v2, v3) =
  let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in
  ()

let v_ident v = v_wrap v_string v

let v_op v = v_wrap v_string v

let v_varid v = v_wrap v_string v

let v_ident_or_wildcard v = v_ident v

let v_varid_or_wildcard v = v_ident v

let v_ident_or_this v = v_ident v

let v_dotted_ident v = v_list v_ident v

let v_qualified_ident v = v_dotted_ident v

let v_selectors v = v_dotted_ident v

let v_simple_ref = function
  | Id v1 ->
      let v1 = v_ident v1 in
      ()
  | This (v1, v2) ->
      let v1 = v_option v_ident v1 and v2 = v_tok v2 in
      ()
  | Super (v1, v2, v3, v4) ->
      let v1 = v_option v_ident v1
      and v2 = v_tok v2
      and v3 = v_option (v_bracket v_ident) v3
      and v4 = v_ident v4 in
      ()

let v_path (v1, v2) =
  let v1 = v_simple_ref v1 and v2 = v_selectors v2 in
  ()

let v_stable_id v = v_path v

let v_todo_category v = v_wrap v_string v

let rec v_import_selector (v1, v2) =
  let v1 = v_ident_or_wildcard v1 and v2 = v_option v_alias v2 in
  ()

and v_alias (v1, v2) =
  let v1 = v_tok v1 and v2 = v_ident_or_wildcard v2 in
  ()

let rec v_import_expr (v1, v2) =
  let v1 = v_stable_id v1 and v2 = v_import_spec v2 in
  ()

and v_import_spec = function
  | ImportId v1 ->
      let v1 = v_ident v1 in
      ()
  | ImportWildcard v1 ->
      let v1 = v_tok v1 in
      ()
  | ImportSelectors v1 ->
      let v1 = v_bracket (v_list v_import_selector) v1 in
      ()

let v_import (v1, v2) =
  let v1 = v_tok v1 and v2 = v_list v_import_expr v2 in
  ()

let v_package (v1, v2) =
  let v1 = v_tok v1 and v2 = v_qualified_ident v2 in
  ()

let rec v_literal = function
  | Int v1 ->
      let v1 = v_wrap (v_option v_int) v1 in
      ()
  | Float v1 ->
      let v1 = v_wrap (v_option v_float) v1 in
      ()
  | Char v1 ->
      let v1 = v_wrap v_string v1 in
      ()
  | String v1 ->
      let v1 = v_wrap v_string v1 in
      ()
  | Bool v1 ->
      let v1 = v_wrap v_bool v1 in
      ()
  | Null v1 ->
      let v1 = v_tok v1 in
      ()
  | Interpolated (v1, v2, v3) ->
      let v1 = v_ident v1 and v2 = v_list v_encaps v2 and v3 = v_tok v3 in
      ()

and v_encaps = function
  | EncapsStr v1 ->
      let v1 = v_wrap v_string v1 in
      ()
  | EncapsDollarIdent v1 ->
      let v1 = v_ident v1 in
      ()
  | EncapsExpr v1 ->
      let v1 = v_expr v1 in
      ()

and v_type_ = function
  | TyLiteral v1 ->
      let v1 = v_literal v1 in
      ()
  | TyName v1 ->
      let v1 = v_stable_id v1 in
      ()
  | TyProj (v1, v2, v3) ->
      let v1 = v_type_ v1 and v2 = v_tok v2 and v3 = v_ident v3 in
      ()
  | TyApplied (v1, v2) ->
      let v1 = v_type_ v1 and v2 = v_bracket (v_list v_type_) v2 in
      ()
  | TyInfix (v1, v2, v3) ->
      let v1 = v_type_ v1 and v2 = v_ident v2 and v3 = v_type_ v3 in
      ()
  | TyFunction1 (v1, v2, v3) ->
      let v1 = v_type_ v1 and v2 = v_tok v2 and v3 = v_type_ v3 in
      ()
  | TyFunction2 (v1, v2, v3) ->
      let v1 = v_bracket (v_list v_type_) v1
      and v2 = v_tok v2
      and v3 = v_type_ v3 in
      ()
  | TyTuple v1 ->
      let v1 = v_bracket (v_list v_type_) v1 in
      ()
  | TyRepeated (v1, v2) ->
      let v1 = v_type_ v1 and v2 = v_tok v2 in
      ()
  | TyAnnotated (v1, v2) ->
      let v1 = v_type_ v1 and v2 = v_list v_annotation v2 in
      ()
  | TyRefined (v1, v2) ->
      let v1 = v_option v_type_ v1 and v2 = v_refinement v2 in
      ()
  | TyExistential (v1, v2, v3) ->
      let v1 = v_type_ v1 and v2 = v_tok v2 and v3 = v_refinement v3 in
      ()
  | TyWith (v1, v2, v3) ->
      let v1 = v_type_ v1 and v2 = v_tok v2 and v3 = v_type_ v3 in
      ()
  | TyWildcard (v1, v2) ->
      let v1 = v_tok v1 and v2 = v_type_bounds v2 in
      ()

and v_param_type = function
  | PT v1 ->
      let v1 = v_type_ v1 in
      ()
  | PTByNameApplication (v1, v2) ->
      let v1 = v_tok v1 and v2 = v_type_ v2 in
      ()
  | PTRepeatedApplication (v1, v2) ->
      let v1 = v_type_ v1 and v2 = v_tok v2 in
      ()

and v_refinement v = v_bracket (v_list v_refine_stat) v

and v_refine_stat v = v_definition v

and v_type_bounds { supertype = v_supertype; subtype = v_subtype } =
  let arg =
    v_option
      (fun (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_type_ v2 in
        ())
      v_supertype
  in
  let arg =
    v_option
      (fun (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_type_ v2 in
        ())
      v_subtype
  in
  ()

and v_ascription v = v_type_ v

and v_pattern = function
  | PatLiteral v1 ->
      let v1 = v_literal v1 in
      ()
  | PatName v1 ->
      let v1 = v_stable_id v1 in
      ()
  | PatTuple v1 ->
      let v1 = v_bracket (v_list v_pattern) v1 in
      ()
  | PatVarid v1 ->
      let v1 = v_varid_or_wildcard v1 in
      ()
  | PatTypedVarid (v1, v2, v3) ->
      let v1 = v_varid_or_wildcard v1 and v2 = v_tok v2 and v3 = v_type_ v3 in
      ()
  | PatBind (v1, v2, v3) ->
      let v1 = v_varid v1 and v2 = v_tok v2 and v3 = v_pattern v3 in
      ()
  | PatApply (v1, v2, v3) ->
      let v1 = v_stable_id v1
      and v2 = v_option (v_bracket (v_list v_type_)) v2
      and v3 = v_option (v_bracket (v_list v_pattern)) v3 in
      ()
  | PatInfix (v1, v2, v3) ->
      let v1 = v_pattern v1 and v2 = v_ident v2 and v3 = v_pattern v3 in
      ()
  | PatUnderscoreStar (v1, v2) ->
      let v1 = v_tok v1 and v2 = v_tok v2 in
      ()
  | PatDisj (v1, v2, v3) ->
      let v1 = v_pattern v1 and v2 = v_tok v2 and v3 = v_pattern v3 in
      ()

and v_expr = function
  | L v1 ->
      let v1 = v_literal v1 in
      ()
  | Tuple v1 ->
      let v1 = v_bracket (v_list v_expr) v1 in
      ()
  | Name v1 ->
      let v1 = v_path v1 in
      ()
  | ExprUnderscore v1 ->
      let v1 = v_tok v1 in
      ()
  | InstanciatedExpr (v1, v2) ->
      let v1 = v_expr v1 and v2 = v_bracket (v_list v_type_) v2 in
      ()
  | TypedExpr (v1, v2, v3) ->
      let v1 = v_expr v1 and v2 = v_tok v2 and v3 = v_ascription v3 in
      ()
  | DotAccess (v1, v2, v3) ->
      let v1 = v_expr v1 and v2 = v_tok v2 and v3 = v_ident v3 in
      ()
  | Apply (v1, v2) ->
      let v1 = v_expr v1 and v2 = v_list v_arguments v2 in
      ()
  | Infix (v1, v2, v3) ->
      let v1 = v_expr v1 and v2 = v_ident v2 and v3 = v_expr v3 in
      ()
  | Prefix (v1, v2) ->
      let v1 = v_op v1 and v2 = v_expr v2 in
      ()
  | Postfix (v1, v2) ->
      let v1 = v_expr v1 and v2 = v_ident v2 in
      ()
  | Assign (v1, v2, v3) ->
      let v1 = v_lhs v1 and v2 = v_tok v2 and v3 = v_expr v3 in
      ()
  | Match (v1, v2, v3) ->
      let v1 = v_expr v1
      and v2 = v_tok v2
      and v3 = v_bracket v_case_clauses v3 in
      ()
  | Lambda v1 ->
      let v1 = v_function_definition v1 in
      ()
  | New (v1, v2) ->
      let v1 = v_tok v1 and v2 = v_template_definition v2 in
      ()
  | BlockExpr v1 ->
      let v1 = v_block_expr v1 in
      ()
  | S v1 ->
      let v1 = v_stmt v1 in
      ()

and v_lhs v = v_expr v

and v_arguments = function
  | Args v1 ->
      let v1 = v_bracket (v_list v_argument) v1 in
      ()
  | ArgBlock v1 ->
      let v1 = v_block_expr v1 in
      ()

and v_argument v = v_expr v

and v_case_clauses v = v_list v_case_clause v

and v_case_clause
    {
      casetoks = v_casetoks;
      casepat = v_casepat;
      caseguard = v_caseguard;
      casebody = v_casebody;
    } =
  let arg =
    match v_casetoks with
    | v1, v2 ->
        let v1 = v_tok v1 and v2 = v_tok v2 in
        ()
  in
  let arg = v_pattern v_casepat in
  let arg = v_option v_guard v_caseguard in
  let arg = v_block v_casebody in
  ()

and v_guard (v1, v2) =
  let v1 = v_tok v1 and v2 = v_expr v2 in
  ()

and v_block_expr v = v_bracket v_block_expr_kind v

and v_block_expr_kind = function
  | BEBlock v1 ->
      let v1 = v_block v1 in
      ()
  | BECases v1 ->
      let v1 = v_case_clauses v1 in
      ()

and v_stmt = function
  | Block v1 ->
      let v1 = v_bracket v_block v1 in
      ()
  | If (v1, v2, v3, v4) ->
      let v1 = v_tok v1
      and v2 = v_bracket v_expr v2
      and v3 = v_expr v3
      and v4 =
        v_option
          (fun (v1, v2) ->
            let v1 = v_tok v1 and v2 = v_expr v2 in
            ())
          v4
      in
      ()
  | While (v1, v2, v3) ->
      let v1 = v_tok v1 and v2 = v_bracket v_expr v2 and v3 = v_expr v3 in
      ()
  | DoWhile (v1, v2, v3, v4) ->
      let v1 = v_tok v1
      and v2 = v_expr v2
      and v3 = v_tok v3
      and v4 = v_bracket v_expr v4 in
      ()
  | For (v1, v2, v3) ->
      let v1 = v_tok v1
      and v2 = v_bracket v_enumerators v2
      and v3 = v_for_body v3 in
      ()
  | Return (v1, v2) ->
      let v1 = v_tok v1 and v2 = v_option v_expr v2 in
      ()
  | Try (v1, v2, v3, v4) ->
      let v1 = v_tok v1
      and v2 = v_expr v2
      and v3 = v_option v_catch_clause v3
      and v4 = v_option v_finally_clause v4 in
      ()
  | Throw (v1, v2) ->
      let v1 = v_tok v1 and v2 = v_expr v2 in
      ()

and v_enumerators v = v_list v_enumerator v

and v_enumerator = function
  | G v1 ->
      let v1 = v_generator v1 in
      ()
  | GIf v1 ->
      let v1 = v_list v_guard v1 in
      ()

and v_generator
    {
      genpat = v_genpat;
      gentok = v_gentok;
      genbody = v_genbody;
      genguards = v_genguards;
    } =
  let arg = v_pattern v_genpat in
  let arg = v_tok v_gentok in
  let arg = v_expr v_genbody in
  let arg = v_list v_guard v_genguards in
  ()

and v_for_body = function
  | Yield (v1, v2) ->
      let v1 = v_tok v1 and v2 = v_expr v2 in
      ()
  | NoYield v1 ->
      let v1 = v_expr v1 in
      ()

and v_catch_clause (v1, v2) =
  let v1 = v_tok v1 and v2 = v_expr v2 in
  ()

and v_finally_clause (v1, v2) =
  let v1 = v_tok v1 and v2 = v_expr v2 in
  ()

and v_block v = v_list v_block_stat v

and v_block_stat = function
  | D v1 ->
      let v1 = v_definition v1 in
      ()
  | I v1 ->
      let v1 = v_import v1 in
      ()
  | E v1 ->
      let v1 = v_expr v1 in
      ()
  | Package v1 ->
      let v1 = v_package v1 in
      ()
  | Packaging (v1, v2) ->
      let v1 = v_package v1 and v2 = v_bracket (v_list v_top_stat) v2 in
      ()

and v_template_stat v = v_block_stat v

and v_top_stat v = v_block_stat v

and v_modifier v = v_wrap v_modifier_kind v

and v_modifier_kind = function
  | Abstract -> ()
  | Final -> ()
  | Sealed -> ()
  | Implicit -> ()
  | Lazy -> ()
  | Private v1 ->
      let v1 = v_option (v_bracket v_ident_or_this) v1 in
      ()
  | Protected v1 ->
      let v1 = v_option (v_bracket v_ident_or_this) v1 in
      ()
  | Override -> ()
  | CaseClassOrObject -> ()
  | PackageObject -> ()
  | Val -> ()
  | Var -> ()

and v_annotation (v1, v2, v3) =
  let v1 = v_tok v1 and v2 = v_type_ v2 and v3 = v_list v_arguments v3 in
  ()

and v_attribute = function
  | A v1 ->
      let v1 = v_annotation v1 in
      ()
  | M v1 ->
      let v1 = v_modifier v1 in
      ()

and v_type_parameter
    {
      tpname = v_tpname;
      tpvariance = v_tpvariance;
      tpannots = v_tpannots;
      tpparams = v_tpparams;
      tpbounds = v_tpbounds;
      tpviewbounds = v_tpviewbounds;
      tpcolons = v_tpcolons;
    } =
  let arg = v_ident_or_wildcard v_tpname in
  let arg = v_option (v_wrap v_variance) v_tpvariance in
  let arg = v_list v_annotation v_tpannots in
  let arg = v_type_parameters v_tpparams in
  let arg = v_type_bounds v_tpbounds in
  let arg = v_list v_type_ v_tpviewbounds in
  let arg = v_list v_type_ v_tpcolons in
  ()

and v_variance = function Covariant -> () | Contravariant -> ()

and v_type_parameters v = v_option (v_bracket (v_list v_type_parameter)) v

and v_definition = function
  | DefEnt (v1, v2) ->
      let v1 = v_entity v1 and v2 = v_definition_kind v2 in
      ()
  | VarDefs v1 ->
      let v1 = v_variable_definitions v1 in
      ()

and v_variable_definitions
    {
      vpatterns = v_vpatterns;
      vattrs = v_vattrs;
      vtype = v_vtype;
      vbody = v_vbody;
    } =
  let arg = v_list v_pattern v_vpatterns in
  let arg = v_list v_attribute v_vattrs in
  let arg = v_option v_type_ v_vtype in
  let arg = v_option v_expr v_vbody in
  ()

and v_entity { name = v_name; attrs = v_attrs; tparams = v_tparams } =
  let arg = v_ident v_name in
  let arg = v_list v_attribute v_attrs in
  let arg = v_type_parameters v_tparams in
  ()

and v_definition_kind = function
  | FuncDef v1 ->
      let v1 = v_function_definition v1 in
      ()
  | TypeDef v1 ->
      let v1 = v_type_definition v1 in
      ()
  | Template v1 ->
      let v1 = v_template_definition v1 in
      ()

and v_function_definition
    {
      fkind = v_fkind;
      fparams = v_fparams;
      frettype = v_frettype;
      fbody = vfbody;
    } =
  let arg = v_wrap v_function_kind v_fkind in
  let arg = v_list v_bindings v_fparams in
  let arg = v_option v_type_ v_frettype in
  let arg = v_option v_fbody vfbody in
  ()

and v_function_kind = function LambdaArrow -> () | Def -> ()

and v_fbody = function
  | FBlock v1 ->
      let v1 = v_block_expr v1 in
      ()
  | FExpr (v1, v2) ->
      let v1 = v_tok v1 and v2 = v_expr v2 in
      ()

and v_bindings v = v_bracket (v_list v_binding) v

and v_binding
    {
      p_name = v_p_name;
      p_attrs = v_p_attrs;
      p_type = v_p_type;
      p_default = v_p_default;
    } =
  let arg = v_ident_or_wildcard v_p_name in
  let arg = v_list v_attribute v_p_attrs in
  let arg = v_option v_param_type v_p_type in
  let arg = v_option v_expr v_p_default in
  ()

and v_template_definition
    {
      ckind = v_ckind;
      cparams = v_cparams;
      cparents = v_cparents;
      cbody = v_cbody;
    } =
  let arg = v_wrap v_template_kind v_ckind in
  let arg = v_list v_bindings v_cparams in
  let arg = v_template_parents v_cparents in
  let arg = v_option v_template_body v_cbody in
  ()

and v_template_parents { cextends = v_cextends; cwith = v_cwith } =
  let arg =
    v_option
      (fun (v1, v2) ->
        let v1 = v_type_ v1 and v2 = v_list v_arguments v2 in
        ())
      v_cextends
  in
  let arg = v_list v_type_ v_cwith in
  ()

and v_template_body v =
  v_bracket
    (fun (v1, v2) ->
      let v1 = v_option v_self_type v1 and v2 = v_block v2 in
      ())
    v

and v_self_type (v1, v2, v3) =
  let v1 = v_ident_or_this v1 and v2 = v_option v_type_ v2 and v3 = v_tok v3 in
  ()

and v_template_kind = function
  | Class -> ()
  | Trait -> ()
  | Object -> ()
  | Singleton -> ()

and v_type_definition { ttok = v_ttok; tbody = v_tbody } =
  let arg = v_tok v_ttok in
  let arg = v_type_definition_kind v_tbody in
  ()

and v_type_definition_kind = function
  | TDef (v1, v2) ->
      let v1 = v_tok v1 and v2 = v_type_ v2 in
      ()
  | TDcl v1 ->
      let v1 = v_type_bounds v1 in
      ()

let v_program v = v_list v_top_stat v

let v_any = function
  | Program v1 ->
      let v1 = v_program v1 in
      ()
  | Tk v1 ->
      let v1 = v_tok v1 in
      ()

let program xs = failwith "TODO"

let any x = failwith "TODO"
