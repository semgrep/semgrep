(* Yoann Padioleau
 *
 * Copyright (C) 2021 r2c
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)
open Common
module H = AST_generic_helpers
open Ast_cpp
open OCaml (* for the map_of_xxx *)

module PI = Parse_info
module G = AST_generic

[@@@warning "-26-27"]

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Ast_cpp to AST_generic.
 *
 * See ast_generic.ml for more information.
 *
 * TODO: copy code from ast_c_build.ml, like the ifdef_skipper
 * TODO: copy code from c_to_generic.ml, like DeRef unsugaring
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

type env = unit

let _id x = x

let map_either _env f g x =
  match x with
  | Left x -> Left (f x)
  | Right x -> Right (g x)

let todo _env _x = failwith "TODO"

let complicated _env _x = failwith "TODO"

(* TODO? change AST_generic.ml instead to take more expr option? *)
let expr_option t eopt =
  match eopt with
  | Some e -> e
  | None -> G.L (G.Unit t) |> G.e

(*****************************************************************************)
(* Conversions *)
(*****************************************************************************)

(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_map_todo.cmo  pr_o.cmo /tmp/xxx.ml  *)

let map_tok env v = v

let map_wrap env _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = map_tok env v2 in
  (v1, v2)

let map_paren env _of_a (v1, v2, v3) =
  let v1 = map_tok env v1 and v2 = _of_a v2 and v3 = map_tok env v3 in
  (v1, v2, v3)

let map_brace env _of_a (v1, v2, v3) =
  let v1 = map_tok env v1 and v2 = _of_a v2 and v3 = map_tok env v3 in
  (v1, v2, v3)

let map_bracket env _of_a (v1, v2, v3) =
  let v1 = map_tok env v1 and v2 = _of_a v2 and v3 = map_tok env v3 in
  (v1, v2, v3)

let map_angle env _of_a (v1, v2, v3) = _of_a v2

let map_angle_keep env _of_a (v1, v2, v3) =
  let v1 = map_tok env v1 and v2 = _of_a v2 and v3 = map_tok env v3 in
  (v1, v2, v3)

let map_sc env v = map_tok env v

let map_todo_category env v : G.todo_kind = map_wrap env map_of_string v

let map_ident env v = map_wrap env map_of_string v

let rec map_name env (v1, v2, v3) : G.name =
  let v1 = map_of_option (map_tok env) v1
  and v2 = map_of_list (map_qualifier env) v2
  and v3 = map_ident_or_op env v3 in
  complicated env (v1, v2, v3)

and map_ident_or_op (env : env) = function
  | IdIdent v1 ->
      let v1 = map_ident env v1 in
      complicated env v1
  | IdTemplateId (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_template_arguments env v2 in
      complicated env (v1, v2)
  | IdOperator (v1, v2) ->
      let v1 = map_tok env v1 in
      let v2 = map_wrap env (map_operator env) v2 in
      complicated env (v1, v2)
  | IdDestructor (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_ident env v2 in
      complicated env (v1, v2)
  | IdConverter (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      complicated env (v1, v2)

and map_template_arguments env (l, v, r) : G.type_arguments =
  let xs = (map_of_list (map_template_argument env)) v in
  (l, xs, r)

and map_template_argument env v : G.type_argument =
  match v with
  | Left t ->
      let t = map_type_ env t in
      G.TA t
  | Right e ->
      let e = map_expr env e in
      G.TAExpr e

and map_qualifier env = function
  | QClassname v1 ->
      let v1 = map_ident env v1 in
      complicated env v1
  | QTemplateId (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_template_arguments env v2 in
      complicated env (v1, v2)

and map_a_class_name env v = map_name env v

and map_a_ident_name env v = map_name env v

and map_type_ env (v1, v2) : G.type_ =
  let v1 = map_type_qualifiers env v1 and v2 = map_typeC env v2 in
  { v2 with t_attrs = v1 }

and map_typeC env x : G.type_ =
  match x with
  | TBase v1 ->
      let v1 = map_baseType env v1 in
      complicated env v1
  | TPrimitive v1 ->
      let v1 = map_wrap env (map_primitive_type env) v1 in
      G.TyBuiltin v1 |> G.t
  | TSized (v1, v2) ->
      let v1 = map_of_list (map_wrap env (map_sized_type env)) v1
      and v2 = map_of_option (map_type_ env) v2 in
      complicated env (v1, v2)
  | TPointer (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_type_ env v2
      and v3 = map_of_list (map_pointer_modifier env) v3 in
      { t = G.TyPointer (v1, v2); t_attrs = v3 }
  | TReference (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      G.TyRef (v1, v2) |> G.t
  | TRefRef (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      G.OtherType (G.OT_Todo, [ G.TodoK ("&&", v1); G.T v2 ]) |> G.t
  | TArray (v1, v2) ->
      let v1 = map_bracket env (map_of_option (map_a_const_expr env)) v1
      and v2 = map_type_ env v2 in
      G.TyArray (v1, v2) |> G.t
  | TFunction v1 ->
      let ps, tret = map_functionType env v1 in
      G.TyFun (ps, tret) |> G.t
  | EnumName (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_a_ident_name env v2 in
      complicated env (v1, v2)
  | ClassName (v1, v2) ->
      let v1 = map_wrap env (map_class_key env) v1
      and v2 = map_a_class_name env v2 in
      complicated env (v1, v2)
  | TypeName v1 ->
      let v1 = map_a_ident_name env v1 in
      G.TyN v1 |> G.t
  | TypenameKwd (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      complicated env (v1, v2)
  | EnumDef v1 ->
      let v1 = map_enum_definition env v1 in
      complicated env v1
  | ClassDef v1 ->
      let v1 = map_class_definition env v1 in
      complicated env v1
  | TypeOf (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_paren env (map_either env (map_type_ env) (map_expr env)) v2
      in
      complicated env (v1, v2)
  | TAuto v1 ->
      let v1 = map_tok env v1 in
      complicated env v1
  | ParenType v1 ->
      let v1 = map_paren env (map_type_ env) v1 in
      complicated env v1
  | TypeTodo (v1, v2) ->
      let v1 = map_todo_category env v1
      and v2 = map_of_list (map_type_ env) v2 in
      G.OtherType (G.OT_Todo, G.TodoK v1 :: (v2 |> List.map (fun t -> G.T t)))
      |> G.t

(* deprecated *)
and map_baseType env = function
  | Void v1 ->
      let v1 = map_tok env v1 in
      complicated env v1
  | IntType (v1, v2) ->
      let v1 = map_intType env v1 and v2 = map_tok env v2 in
      complicated env (v1, v2)
  | FloatType (v1, v2) ->
      let v1 = map_floatType env v1 and v2 = map_tok env v2 in
      complicated env (v1, v2)

and map_intType env = function
  | CChar -> CChar
  | Si v1 ->
      let v1 = map_signed env v1 in
      complicated env v1
  | CBool -> CBool
  | WChar_t -> WChar_t

and map_signed env (v1, v2) =
  let v1 = map_sign env v1 and v2 = map_base env v2 in
  (v1, v2)

(* deprecated *)
and map_base env = function
  | CChar2 -> CChar2
  | CShort -> CShort
  | CInt -> CInt
  | CLong -> CLong
  | CLongLong -> CLongLong

and map_sign env = function
  | Signed -> Signed
  | UnSigned -> UnSigned

(* deprecated *)
and map_floatType env = function
  | CFloat -> CFloat
  | CDouble -> CDouble
  | CLongDouble -> CLongDouble

and map_primitive_type env = function
  | TVoid -> "void"
  | TBool -> "bool"
  | TChar -> "char"
  | TInt -> "int"
  | TFloat -> "float"
  | TDouble -> "double"

(* deprecated *)
and map_sized_type env = function
  | TSigned -> TSigned
  | TUnsigned -> TUnsigned
  | TShort -> TShort
  | TLong -> TLong

and map_type_qualifiers env v : G.attribute list =
  map_of_list (map_qualifier_wrap env) v

and map_qualifier_wrap env (qu, t) : G.attribute =
  (* (map_wrap env (map_type_qualifier env)) *)
  complicated env (qu, t)

and map_expr env x : G.expr =
  match x with
  | N (v1, v2) ->
      let v1 = map_name env v1 and _v2 = map_ident_info env v2 in
      G.N v1 |> G.e
  | C v1 ->
      let v1 = map_constant env v1 in
      G.L v1 |> G.e
  | IdSpecial v1 ->
      let v1 = map_wrap env (map_special env) v1 in
      complicated env v1
  | Call (v1, v2) ->
      let v1 = map_expr env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2 in
      G.Call (v1, v2) |> G.e
  | CondExpr (v1, v2, v3, v4, v5) ->
      let v1 = map_expr env v1
      and v2 = map_tok env v2
      and ethen = expr_option v2 (map_of_option (map_expr env) v3)
      and _v4 = map_tok env v4
      and v5 = map_expr env v5 in
      G.Conditional (v1, ethen, v5) |> G.e
  | Sequence (v1, v2, v3) ->
      let v1 = map_expr env v1
      and _v2 = map_tok env v2
      and v3 = map_expr env v3 in
      G.Seq [ v1; v3 ] |> G.e
  | Assign (v1, v2, v3) -> (
      let v1 = map_a_lhs env v1
      and v2 = map_assignOp env v2
      and v3 = map_expr env v3 in
      match v2 with
      | Left teq -> G.Assign (v1, teq, v3) |> G.e
      | Right op -> G.AssignOp (v1, op, v3) |> G.e)
  | Prefix (v1, v2) ->
      let op, t = map_wrap env (map_fixOp env) v1 and v2 = map_expr env v2 in
      G.special (G.IncrDecr (op, G.Prefix), t) [ v2 ]
  | Postfix (v1, v2) ->
      let v1 = map_expr env v1 and op, t = map_wrap env (map_fixOp env) v2 in
      G.special (G.IncrDecr (op, G.Postfix), t) [ v1 ]
  | Unary (v1, v2) -> (
      let either, t = map_wrap env (map_unaryOp env) v1
      and v2 = map_expr env v2 in
      match either with
      | Left op -> G.opcall (op, t) [ v2 ]
      | Right f -> f t v2)
  | Binary (v1, v2, v3) ->
      let v1 = map_expr env v1
      and v2 = map_wrap env (map_binaryOp env) v2
      and v3 = map_expr env v3 in
      G.opcall v2 [ v1; v3 ]
  | ArrayAccess (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_bracket env (map_expr env) v2 in
      G.ArrayAccess (v1, v2) |> G.e
  | DotAccess (v1, v2, v3) -> (
      let v1 = map_expr env v1
      and either, tdot = map_wrap env (map_dotOp env) v2
      and v3 = map_name env v3 in
      match either with
      | Left _dot -> G.DotAccess (v1, tdot, G.EN v3) |> G.e
      | Right _arrow -> complicated env tdot)
  | DotStarAccess (v1, v2, v3) -> (
      let v1 = map_expr env v1
      and either, tdot = map_wrap env (map_dotOp env) v2
      and v3 = map_expr env v3 in
      match either with
      | Left _dot -> complicated env tdot
      | Right _arrow -> complicated env tdot)
  | SizeOf (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_either env (map_expr env) (map_paren env (map_type_ env)) v2
      in
      let arg =
        match v2 with
        | Left e -> G.Arg e
        | Right (_l, t, _r) -> G.ArgType t
      in
      let special = G.IdSpecial (G.Sizeof, v1) |> G.e in
      G.Call (special, G.fake_bracket [ arg ]) |> G.e
  | Cast (v1, v2) ->
      let l, t, _r = map_paren env (map_type_ env) v1
      and v2 = map_expr env v2 in
      G.Cast (t, l, v2) |> G.e
  | StatementExpr v1 ->
      let l, (_, xs, _), r = map_paren env (map_compound env) v1 in
      let st = G.Block (l, xs, r) |> G.s in
      G.stmt_to_expr st
  | GccConstructor (v1, v2) ->
      let lpar, t, rpar = map_paren env (map_type_ env) v1
      and lbrace, xs, rbrace =
        map_brace env (map_of_list (map_initialiser env)) v2
      in
      let special = G.IdSpecial (G.New, lpar) |> G.e in
      G.Call (special, (lbrace, G.ArgType t :: (xs |> List.map G.arg), rbrace))
      |> G.e
  | ConstructedObject (v1, v2) ->
      let t = map_type_ env v1 and l, args, r = map_obj_init env v2 in
      let special = G.IdSpecial (G.New, PI.fake_info l "new") |> G.e in
      G.Call (special, (l, G.ArgType t :: args, r)) |> G.e
  | TypeId (v1, v2) ->
      let v1 = map_tok env v1
      and l, either, r =
        map_paren env (map_either env (map_type_ env) (map_expr env)) v2
      in
      complicated env (v1, v2)
  | CplusplusCast (v1, v2, v3) ->
      let optodo, t = map_wrap env (map_cast_operator env) v1
      and langle, typ, rangle = map_angle_keep env (map_type_ env) v2
      and lpar, e, rpar = map_paren env (map_expr env) v3 in
      let e = G.OtherExpr (G.OE_Todo, [ G.TodoK (optodo, t) ]) |> G.e in
      G.Call (e, (langle, [ G.ArgType typ; G.Arg e ], rpar)) |> G.e
  | New (v1, v2, v3, v4, v5) ->
      let v1 = map_of_option (map_tok env) v1
      and v2 = map_tok env v2
      and v3 = map_of_option (map_paren env (map_of_list (map_argument env))) v3
      and v4 = map_type_ env v4
      and v5 = map_of_option (map_obj_init env) v5 in
      complicated env (v1, v2, v3, v4, v5)
  | Delete (v1, v2, v3, v4) ->
      let v1 = map_of_option (map_tok env) v1
      and v2 = map_tok env v2
      and v3 = map_of_option (map_bracket env map_of_unit) v3
      and v4 = map_expr env v4 in
      complicated env (v1, v2, v3, v4)
  | Throw (v1, v2) ->
      let v1 = map_tok env v1
      and v2 = expr_option v1 (map_of_option (map_expr env) v2) in
      let st = G.Throw (v1, v2, G.sc) |> G.s in
      G.stmt_to_expr st
  | Lambda v1 ->
      let v1 = map_lambda_definition env v1 in
      G.Lambda v1 |> G.e
  | ParamPackExpansion (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_tok env v2 in
      G.OtherExpr (G.OE_Todo, [ G.TodoK ("Pack", v2); G.E v1 ]) |> G.e
  | ParenExpr v1 ->
      let _l, v1, _r = map_paren env (map_expr env) v1 in
      v1
  | Ellipses v1 ->
      let v1 = map_tok env v1 in
      G.Ellipsis v1 |> G.e
  | DeepEllipsis v1 ->
      let v1 = map_bracket env (map_expr env) v1 in
      G.DeepEllipsis v1 |> G.e
  | TypedMetavar (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_type_ env v2 in
      G.TypedMetavar (v1, G.fake ":", v2) |> G.e
  | ExprTodo (v1, v2) ->
      let v1 = map_todo_category env v1
      and v2 = map_of_list (map_expr env) v2 in
      G.OtherExpr (G.OE_Todo, G.TodoK v1 :: (v2 |> List.map (fun e -> G.E e)))
      |> G.e

and map_ident_info env { i_scope = _v_i_scope } = ()

and map_special env = function
  | This -> G.This
  | Defined -> G.Defined

and map_argument env x : G.argument =
  match x with
  | Arg v1 ->
      let v1 = map_expr env v1 in
      G.Arg v1
  | ArgType v1 ->
      let v1 = map_type_ env v1 in
      G.ArgType v1
  | ArgAction v1 ->
      let v1 = map_action_macro env v1 in
      G.ArgOther (("ArgMacro", G.fake ""), v1)
  | ArgInits v1 ->
      let l, xs, r = map_brace env (map_of_list (map_initialiser env)) v1 in
      G.Arg (G.Container (G.Dict, (l, xs, r)) |> G.e)

and map_action_macro env x : G.any list =
  match x with
  | ActMisc v1 ->
      let v1 = map_of_list (map_tok env) v1 in
      v1 |> List.map (fun t -> G.Tk t)

and map_constant env x : G.literal =
  match x with
  | Int v1 ->
      let v1 = map_wrap env (map_of_option map_of_int) v1 in
      G.Int v1
  | Float v1 ->
      let v1 =
        match v1 with
        | v1, v2 ->
            let v1 = map_wrap env (map_of_option map_of_float) v1
            and _v2 = map_floatType env v2 in
            v1
      in
      G.Float v1
  | Char v1 ->
      let v1 =
        match v1 with
        | v1, v2 ->
            let v1 = map_wrap env map_of_string v1
            and _v2 = map_isWchar env v2 in
            v1
      in
      G.Char v1
  | String v1 ->
      let v1 =
        match v1 with
        | v1, v2 ->
            let v1 = map_wrap env map_of_string v1
            and _v2 = map_isWchar env v2 in
            v1
      in
      G.String v1
  | MultiString v1 ->
      let v1 = map_of_list (map_wrap env map_of_string) v1 in
      complicated env v1
  | Bool v1 ->
      let v1 = map_wrap env map_of_bool v1 in
      G.Bool v1
  | Nullptr v1 ->
      let v1 = map_tok env v1 in
      G.Null v1

and map_isWchar env = function
  | IsWchar -> ()
  | IsChar -> ()

and map_unaryOp env = function
  | UnPlus -> Left G.Plus
  | UnMinus -> Left G.Minus
  | Tilde -> Left G.BitNot
  | Not -> Left G.Not
  | GetRef -> Right (fun tok e -> G.Ref (tok, e) |> G.e)
  | DeRef -> Right (fun tok e -> G.DeRef (tok, e) |> G.e)
  | GetRefLabel ->
      Right
        (fun tok e ->
          G.OtherExpr (G.OE_GetRefLabel, [ G.Tk tok; G.E e ]) |> G.e)

and map_assignOp env = function
  | SimpleAssign v1 ->
      let v1 = map_tok env v1 in
      Left v1
  | OpAssign v1 ->
      let v1 = map_wrap env (map_arithOp env) v1 in
      Right v1

and map_fixOp env = function
  | Dec -> G.Decr
  | Inc -> G.Incr

and map_dotOp env = function
  | Dot -> Left ()
  | Arrow -> Right ()

and map_binaryOp env x : G.operator =
  match x with
  | Arith v1 ->
      let v1 = map_arithOp env v1 in
      v1
  | Logical v1 ->
      let v1 = map_logicalOp env v1 in
      v1

and map_arithOp env = function
  | Plus -> G.Plus
  | Minus -> G.Minus
  | Mul -> G.Mult
  | Div -> G.Div
  | Mod -> G.Mod
  | DecLeft -> G.LSL
  | DecRight -> G.LSR
  | And -> G.BitAnd
  | Or -> G.BitOr
  | Xor -> G.BitXor

and map_logicalOp env = function
  | Inf -> G.Lt
  | Sup -> G.Gt
  | InfEq -> G.LtE
  | SupEq -> G.GtE
  | Eq -> G.Eq
  | NotEq -> G.NotEq
  | AndLog -> G.And
  | OrLog -> G.Or

and map_ptrOp env = function
  | PtrStarOp -> PtrStarOp
  | PtrOp -> PtrOp

and map_allocOp env = function
  | NewOp -> NewOp
  | DeleteOp -> DeleteOp
  | NewArrayOp -> NewArrayOp
  | DeleteArrayOp -> DeleteArrayOp

and map_accessop env = function
  | ParenOp -> ParenOp
  | ArrayOp -> ArrayOp

and map_operator (env : env) = function
  | BinaryOp v1 ->
      let v1 = map_binaryOp env v1 in
      complicated env v1
  | AssignOp v1 ->
      let v1 = map_assignOp env v1 in
      complicated env v1
  | FixOp v1 ->
      let v1 = map_fixOp env v1 in
      complicated env v1
  | PtrOpOp v1 ->
      let v1 = map_ptrOp env v1 in
      complicated env v1
  | AccessOp v1 ->
      let v1 = map_accessop env v1 in
      complicated env v1
  | AllocOp v1 ->
      let v1 = map_allocOp env v1 in
      complicated env v1
  | UnaryTildeOp -> complicated env ()
  | UnaryNotOp -> complicated env ()
  | CommaOp -> complicated env ()

and map_cast_operator env = function
  | Static_cast -> "Static_cast"
  | Dynamic_cast -> "Dynamic_cast"
  | Const_cast -> "Const_cast"
  | Reinterpret_cast -> "Reinterpret_cast"

and map_a_const_expr env v = map_expr env v

and map_a_lhs env v = map_expr env v

and map_stmt env x : G.stmt =
  match x with
  | Compound v1 ->
      let v1 = map_compound env v1 in
      G.Block v1 |> G.s
  | ExprStmt v1 ->
      let eopt, sc = map_expr_stmt env v1 in
      let e = expr_option sc eopt in
      G.ExprStmt (e, sc) |> G.s
  | MacroStmt v1 ->
      let v1 = map_tok env v1 in
      complicated env v1
  | If (v1, v2, v3, v4, v5) ->
      let v1 = map_tok env v1
      and _v2TODO = map_of_option (map_tok env) v2 (* constexpr *)
      and _, cond, _ = map_paren env (map_condition_clause env) v3
      and v4 = map_stmt env v4
      and v5 =
        map_of_option
          (fun (v1, v2) ->
            let _else = map_tok env v1 and v2 = map_stmt env v2 in
            v2)
          v5
      in
      G.If (v1, cond, v4, v5) |> G.s
  | Switch (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_condition_clause env) v2
      and v3 = map_stmt env v3 in
      complicated env (v1, v2, v3)
  | While (v1, v2, v3) ->
      let v1 = map_tok env v1
      and _, cond, _ = map_paren env (map_condition_clause env) v2
      and v3 = map_stmt env v3 in
      G.While (v1, cond, v3) |> G.s
  | DoWhile (v1, v2, v3, v4, v5) ->
      let v1 = map_tok env v1
      and v2 = map_stmt env v2
      and v3 = map_tok env v3
      and _, cond, _ = map_paren env (map_expr env) v4
      and v5 = map_sc env v5 in
      G.DoWhile (v1, v2, cond) |> G.s
  | For (v1, v2, v3) ->
      let v1 = map_tok env v1
      and _, header, _ = map_paren env (map_for_header env) v2
      and v3 = map_stmt env v3 in
      G.For (v1, header, v3) |> G.s
  | MacroIteration (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2
      and v3 = map_stmt env v3 in
      complicated env (v1, v2, v3)
  | Jump (v1, v2) ->
      let v1 = map_jump env v1 and v2 = map_sc env v2 in
      v1 v2
  | Label (v1, v2, v3) ->
      let v1 = map_a_label env v1
      and _v2 = map_tok env v2
      and v3 = map_stmt env v3 in
      G.Label (v1, v3) |> G.s
  | Case (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_expr env v2
      and v3 = map_tok env v3
      and v4 = map_case_body env v4 in
      complicated env (v1, v2, v3, v4)
  | CaseRange (v1, v2, v3, v4, v5, v6) ->
      let v1 = map_tok env v1
      and v2 = map_expr env v2
      and v3 = map_tok env v3
      and v4 = map_expr env v4
      and v5 = map_tok env v5
      and v6 = map_case_body env v6 in
      complicated env (v1, v2, v3, v4, v5, v6)
  | Default (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_tok env v2
      and v3 = map_case_body env v3 in
      complicated env (v1, v2, v3)
  | Try (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_compound env v2
      and v3 = map_of_list (map_handler env) v3 in
      G.Try (v1, G.Block v2 |> G.s, v3, None) |> G.s
  | StmtTodo (v1, v2) ->
      let v1 = map_todo_category env v1
      and v2 = map_of_list (map_stmt env) v2 in
      complicated env (v1, v2)

and map_expr_stmt env (v1, v2) =
  let v1 = map_of_option (map_expr env) v1 and v2 = map_sc env v2 in
  (v1, v2)

and map_condition_clause env x : G.condition =
  match x with
  | CondClassic v1 ->
      let v1 = map_expr env v1 in
      v1
  | CondDecl (v1, v2) ->
      let _v1TODO = map_vars_decl env v1 and v2 = map_expr env v2 in
      v2
  | CondStmt (v1, v2) ->
      let _v1TODO = map_expr_stmt env v1 and v2 = map_expr env v2 in
      v2
  | CondOneDecl v1 ->
      let v1 = map_var_decl env v1 in
      complicated env v1

and map_for_header env = function
  | ForClassic (v1, v2, v3) ->
      let v1 = map_a_expr_or_vars env v1
      and v2 = map_of_option (map_expr env) v2
      and v3 = map_of_option (map_expr env) v3 in
      G.ForClassic (v1, v2, v3)
  | ForRange (v1, v2, v3) ->
      let ent, vardef = map_var_decl env v1
      and v2 = map_tok env v2
      and v3 = map_initialiser env v3 in
      (* less: or ForEach? *)
      G.ForIn ([ G.ForInitVar (ent, vardef) ], [ v3 ])

and map_a_expr_or_vars env v =
  match v with
  | Left (Some e, _sc) ->
      let e = map_expr env e in
      [ ForInitExpr e ]
  | Left (None, _) -> []
  | Right xs ->
      let xs = map_vars_decl env xs in
      xs
      |> List.map (fun onedecl ->
             let ent, vardef = complicated env onedecl in
             G.ForInitVar (ent, vardef))

and map_a_label env v = map_wrap env map_of_string v

and map_jump env = function
  | Goto (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_a_label env v2 in
      fun sc -> G.Goto (v1, v2, sc) |> G.s
  | Continue v1 ->
      let v1 = map_tok env v1 in
      fun sc -> G.Continue (v1, G.LNone, sc) |> G.s
  | Break v1 ->
      let v1 = map_tok env v1 in
      fun sc -> G.Break (v1, G.LNone, sc) |> G.s
  | Return (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_of_option (map_argument env) v2 in
      let v2 = Common.map_opt H.argument_to_expr v2 in
      fun sc -> G.Return (v1, v2, sc) |> G.s
  | GotoComputed (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_tok env v2
      and v3 = map_expr env v3 in
      (* less: could change G.Goto to take a label instead of label_ident? *)
      fun _sc ->
        G.OtherStmt (G.OS_Todo, [ G.TodoK ("GotoComputed", v1); G.E v3 ]) |> G.s

and map_case_body env v = map_of_list (map_stmt_or_decl env) v

and map_handler env (v1, v2, v3) : G.catch =
  let v1 = map_tok env v1
  and _, xs, _ = map_paren env (map_of_list (map_exception_declaration env)) v2
  and v3 = map_compound env v3 in
  let pat : G.catch_exn = complicated env xs in
  (v1, pat, G.Block v3 |> G.s)

and map_exception_declaration env x : G.catch_exn =
  match x with
  | ExnDecl v1 ->
      let v1 = map_parameter env v1 in
      complicated env v1
  | ExnDeclEllipsis v1 ->
      let v1 = map_tok env v1 in
      G.CatchPattern (G.PatEllipsis v1)

and map_stmt_or_decl env x : G.stmt list =
  match x with
  | S v1 ->
      let v1 = map_stmt env v1 in
      [ v1 ]
  | D v1 ->
      let v1 = map_decl env v1 in
      v1

and map_compound env (l, v, r) : G.stmt list bracket =
  let xs = map_of_list (map_sequencable env (map_stmt_or_decl env)) v in
  (l, List.flatten xs, r)

and map_declarations env (l, v, r) : G.stmt list bracket =
  let xs = map_of_list (map_sequencable env (map_stmt_or_decl env)) v in
  (l, List.flatten xs, r)

and map_entity env { name = v_name; specs = v_specs } : G.entity =
  let v_specs = map_of_list (map_specifier env) v_specs in
  let v_name = map_name env v_name in
  { G.name = G.EN v_name; attrs = v_specs; tparams = [] }

and map_decl env x : G.stmt list =
  match x with
  | DeclList v1 ->
      let v1 = map_vars_decl env v1 in
      v1 |> List.map (fun def -> G.DefStmt def |> G.s)
  | MacroDecl (v1, v2, v3, v4) ->
      let v1 = map_of_list (map_tok env) v1
      and v2 = map_ident env v2
      and v3 = map_paren env (map_of_list (map_argument env)) v3
      and v4 = map_tok env v4 in
      complicated env (v1, v2, v3, v4)
  | UsingDecl v1 ->
      let v1 = map_using env v1 in
      complicated env v1
  | NameSpaceAlias (v1, v2, v3, v4, v5) ->
      let v1 = map_tok env v1
      and v2 = map_ident env v2
      and v3 = map_tok env v3
      and v4 = map_type_ env v4
      and v5 = map_sc env v5 in
      complicated env (v1, v2, v3, v4, v5)
  | Asm (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_tok env) v2
      and v3 = map_paren env (map_asmbody env) v3
      and v4 = map_sc env v4 in
      complicated env (v1, v2, v3, v4)
  | Func v1 ->
      let v1 = map_func_definition env v1 in
      [ G.DefStmt v1 |> G.s ]
  | TemplateDecl (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_template_parameters env v2
      and v3 = map_decl env v3 in
      complicated env (v1, v2, v3)
  | TemplateInstanciation (v1, v2, v3) ->
      let v1 = map_tok env v1
      and ent, vardef = map_var_decl env v2
      and v3 = map_sc env v3 in
      complicated env (v1, ent, vardef, v3)
  | ExternDecl (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_wrap env map_of_string v2
      and v3 = map_decl env v3 in
      complicated env (v1, v2, v3)
  | ExternList (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_wrap env map_of_string v2
      and v3 = map_declarations env v3 in
      complicated env (v1, v2, v3)
  | NameSpace (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_ident env) v2
      and v3 = map_declarations env v3 in
      complicated env (v1, v2, v3)
  | StaticAssert (v1, v2) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2 in
      complicated env (v1, v2)
  | EmptyDef v1 ->
      let v1 = map_sc env v1 in
      [ G.emptystmt v1 ]
  | NotParsedCorrectly v1 ->
      let v1 = map_of_list (map_tok env) v1 in
      complicated env v1
  | DeclTodo v1 ->
      let v1 = map_todo_category env v1 in
      [ G.OtherStmt (G.OS_Todo, [ G.TodoK v1 ]) |> G.s ]

and map_vars_decl env (v1, v2) : G.definition list =
  let v1 = map_of_list (map_onedecl env) v1 and _v2 = map_sc env v2 in
  v1

and map_asmbody env (v1, v2) =
  let v1 = map_of_list (map_wrap env map_of_string) v1
  and v2 = map_of_list (map_colon env) v2 in
  (v1, v2)

and map_colon env = function
  | Colon (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_of_list (map_colon_option env) v2 in
      (v1, v2)

and map_colon_option env = function
  | ColonExpr (v1, v2) ->
      let v1 = map_of_list (map_tok env) v1
      and v2 = map_paren env (map_expr env) v2 in
      (v1, Some v2)
  | ColonMisc v1 ->
      let v1 = map_of_list (map_tok env) v1 in
      (v1, None)

and map_onedecl env x =
  match x with
  | EmptyDecl t ->
      let t = map_type_ env t in
      todo env t
  | TypedefDecl (tk, ty, id) ->
      let tk = map_tok env tk in
      let ty = map_type_ env ty in
      let id = map_ident env id in
      todo env (tk, ty, id)
  | V v1 ->
      let ent, vardef = map_var_decl env v1 in
      todo env (ent, vardef)
  | StructuredBinding (v1, v2, v3) ->
      let v1 = map_type_ env v1 in
      let v2 = map_bracket env (map_of_list (map_ident env)) v2 in
      let v3 = map_init env v3 in
      todo env (v1, v2, v3)

and map_var_decl env (ent, { v_init = v_v_init; v_type = v_v_type }) =
  let ent = map_entity env ent in
  let v_v_type = map_type_ env v_v_type in
  let v_v_init = map_of_option (map_init env) v_v_init in
  complicated env ()

and map_init env = function
  | EqInit (v1, v2) ->
      let _v1 = map_tok env v1 and v2 = map_initialiser env v2 in
      v2
  | ObjInit v1 ->
      let v1 = map_obj_init env v1 in
      complicated env v1
  | Bitfield (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_a_const_expr env v2 in
      complicated env (v1, v2)

and map_obj_init env x : G.argument list bracket =
  match x with
  | Args v1 ->
      let v1 = map_paren env (map_of_list (map_argument env)) v1 in
      v1
  | Inits v1 ->
      let lbrace, xs, rbraces =
        map_brace env (map_of_list (map_initialiser env)) v1
      in
      (lbrace, xs |> List.map G.arg, rbraces)

and map_initialiser env x : G.expr =
  match x with
  | InitExpr v1 ->
      let v1 = map_expr env v1 in
      v1
  | InitList v1 ->
      let v1 = map_brace env (map_of_list (map_initialiser env)) v1 in
      G.Container (G.List, v1) |> G.e
  | InitDesignators (v1, v2, v3) ->
      let v1 = map_of_list (map_designator env) v1
      and v2 = map_tok env v2
      and v3 = map_initialiser env v3 in
      complicated env (v1, v2, v3)
  | InitFieldOld (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_tok env v2
      and v3 = map_initialiser env v3 in
      complicated env (v1, v2, v3)
  | InitIndexOld (v1, v2) ->
      let v1 = map_bracket env (map_expr env) v1
      and v2 = map_initialiser env v2 in
      complicated env (v1, v2)

and map_designator env = function
  | DesignatorField (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_ident env v2 in
      complicated env (v1, v2)
  | DesignatorIndex v1 ->
      let v1 = map_bracket env (map_expr env) v1 in
      complicated env v1
  | DesignatorRange v1 ->
      let v1 =
        map_bracket env
          (fun (v1, v2, v3) ->
            let v1 = map_expr env v1
            and v2 = map_tok env v2
            and v3 = map_expr env v3 in
            (v1, v2, v3))
          v1
      in
      complicated env v1

and map_func_definition env (v1, v2) : G.definition =
  let v1 = map_entity env v1 and v2 = map_function_definition env v2 in
  (v1, FuncDef v2)

and map_function_definition env
    { f_type = v_f_type; f_body = v_f_body; f_specs = v_f_specs } :
    G.function_definition =
  let _v_f_specsTODO = map_of_list (map_specifier env) v_f_specs in
  let fbody = map_function_body env v_f_body in
  let fparams, fret = map_functionType env v_f_type in
  { G.fkind = (G.Function, G.fake ""); fparams; frettype = Some fret; fbody }

and map_functionType env x : G.parameter list * G.type_ =
  match x with
  | {
   ft_ret = v_ft_ret;
   ft_params = v_ft_params;
   ft_specs = v_ft_specs;
   ft_const = v_ft_const;
   ft_throw = v_ft_throw;
  } ->
      let _v_ft_throwTODO = map_of_list (map_exn_spec env) v_ft_throw in
      let _v_ft_constTODO = map_of_option (map_tok env) v_ft_const in
      let _v_ft_specsTODO = map_of_list (map_specifier env) v_ft_specs in
      let _, params, _ =
        map_paren env (map_of_list (map_parameter env)) v_ft_params
      in
      let tret = map_type_ env v_ft_ret in
      (params, tret)

and map_parameter env x : G.parameter =
  match x with
  | P v1 ->
      let v1 = map_parameter_classic env v1 in
      G.ParamClassic v1
  | ParamVariadic (v1, v2, v3) ->
      let _v1TODO = map_of_option (map_tok env) v1
      and v2 = map_tok env v2
      and v3 = map_parameter_classic env v3 in
      G.ParamRest (v2, v3)
  | ParamDots v1 ->
      let v1 = map_tok env v1 in
      G.ParamEllipsis v1

and map_parameter_classic env
    {
      p_name = v_p_name;
      p_type = v_p_type;
      p_specs = v_p_specs;
      p_val = v_p_val;
    } : G.parameter_classic =
  let v_p_val =
    map_of_option
      (fun (v1, v2) ->
        let v1 = map_tok env v1 and v2 = map_expr env v2 in
        (v1, v2))
      v_p_val
  in
  let v_p_specs = map_of_list (map_specifier env) v_p_specs in
  let v_p_type = map_type_ env v_p_type in
  let v_p_name = map_of_option (map_ident env) v_p_name in
  todo env ()

and map_exn_spec env = function
  | ThrowSpec (v1, v2) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_of_list (map_type_ env)) v2 in
      todo env (v1, v2)
  | Noexcept (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_of_option (map_paren env (map_of_option (map_a_const_expr env))) v2
      in
      todo env (v1, v2)

and map_function_body env x : G.function_body =
  match x with
  | FBDef v1 ->
      let v1 = map_compound env v1 in
      todo env v1
  | FBDecl v1 ->
      let v1 = map_sc env v1 in
      todo env v1
  | FBZero (v1, v2, v3) ->
      let v1 = map_tok env v1 and v2 = map_tok env v2 and v3 = map_sc env v3 in
      todo env (v1, v2, v3)
  | FBDefault (v1, v2, v3) ->
      let v1 = map_tok env v1 and v2 = map_tok env v2 and v3 = map_sc env v3 in
      todo env (v1, v2, v3)
  | FBDelete (v1, v2, v3) ->
      let v1 = map_tok env v1 and v2 = map_tok env v2 and v3 = map_sc env v3 in
      todo env (v1, v2, v3)

and map_lambda_definition env (v1, v2) : G.function_definition =
  let v1 = map_bracket env (map_of_list (map_lambda_capture env)) v1
  and v2 = map_function_definition env v2 in
  todo env (v1, v2)

and map_lambda_capture env = function
  | CaptureEq v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | CaptureRef v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | CaptureOther v1 ->
      let v1 = map_expr env v1 in
      todo env v1

and map_enum_definition env
    {
      enum_kind = v_enum_kind;
      enum_name = v_enum_name;
      enum_body = v_enum_body;
    } : G.definition =
  let v_enum_body =
    map_brace env (map_of_list (map_enum_elem env)) v_enum_body
  in
  let v_enum_name = map_of_option (map_name env) v_enum_name in
  let v_enum_kind = map_tok env v_enum_kind in
  todo env ()

and map_enum_elem env { e_name = v_e_name; e_val = v_e_val } =
  let v_e_val =
    map_of_option
      (fun (v1, v2) ->
        let v1 = map_tok env v1 and v2 = map_a_const_expr env v2 in
        (v1, v2))
      v_e_val
  in
  let v_e_name = map_ident env v_e_name in
  todo env ()

and map_class_definition env (v1, v2) : G.definition =
  let v1 = map_of_option (map_a_class_name env) v1
  and v2 = map_class_definition_bis env v2 in
  todo env (v1, v2)

and map_class_definition_bis env
    { c_kind = v_c_kind; c_inherit = v_c_inherit; c_members = v_c_members } =
  let v_c_members =
    map_brace env
      (map_of_list (map_sequencable env (map_class_member env)))
      v_c_members
  in
  let v_c_inherit = map_of_list (map_base_clause env) v_c_inherit in
  let v_c_kind = map_wrap env (map_class_key env) v_c_kind in
  todo env ()

and map_class_key env = function
  | Struct -> Struct
  | Union -> Union
  | Class -> Class

and map_base_clause env
    { i_name = v_i_name; i_virtual = v_i_virtual; i_access = v_i_access } =
  let v_i_access =
    map_of_option (map_wrap env (map_access_spec env)) v_i_access
  in
  let v_i_virtual = map_of_option (map_modifier env) v_i_virtual in
  let v_i_name = map_a_class_name env v_i_name in
  todo env ()

and map_class_member env x (* : G.field list *) =
  match x with
  | Access (v1, v2) ->
      let v1 = map_wrap env (map_access_spec env) v1 and v2 = map_tok env v2 in
      todo env (v1, v2)
  | FieldList (v1, v2) ->
      let v1 = map_of_list (map_fieldkind env) v1 and v2 = map_sc env v2 in
      todo env (v1, v2)
  | Friend (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_decl env v2 in
      todo env (v1, v2)
  | QualifiedIdInClass (v1, v2) ->
      let v1 = map_name env v1 and v2 = map_sc env v2 in
      todo env (v1, v2)
  | MemberDecl v1 ->
      let v1 = map_decl env v1 in
      todo env v1

and map_fieldkind env = function
  | FieldDecl v1 ->
      let v1 = map_onedecl env v1 in
      todo env v1
  | BitField (v1, v2, v3, v4) ->
      let v1 = map_of_option (map_ident env) v1
      and v2 = map_tok env v2
      and v3 = map_type_ env v3
      and v4 = map_a_const_expr env v4 in
      todo env (v1, v2, v3, v4)

and map_template_parameter env x : G.type_parameter =
  match x with
  | TP v1 ->
      let v1 = map_parameter env v1 in
      todo env v1
  | TPClass (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_ident env) v2
      and v3 = map_of_option (map_type_ env) v3 in
      todo env (v1, v2, v3)
  | TPVariadic (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_tok env v2
      and v3 = map_of_option (map_ident env) v3 in
      todo env (v1, v2, v3)
  | TPNested (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_template_parameters env v2
      and v3 = map_template_parameter env v3 in
      todo env (v1, v2, v3)

and map_template_parameters env v : G.type_parameter list =
  map_angle env (map_of_list (map_template_parameter env)) v

and map_specifier env x : G.attribute =
  match x with
  | A v1 ->
      let v1 = map_attribute env v1 in
      todo env v1
  | M v1 ->
      let v1 = map_modifier env v1 in
      todo env v1
  | TQ v1 ->
      let v1 = map_wrap env (map_type_qualifier env) v1 in
      todo env v1
  | ST v1 ->
      let v1 = map_storage env v1 in
      todo env v1

and map_attribute env = function
  | UnderscoresAttr (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_paren env (map_paren env (map_of_list (map_argument env))) v2
      in
      todo env (v1, v2)
  | BracketsAttr v1 ->
      let v1 = map_bracket env (map_of_list (map_expr env)) v1 in
      todo env v1
  | DeclSpec (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_paren env (map_ident env) v2 in
      todo env (v1, v2)

and map_modifier env = function
  | Inline v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Virtual v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Final v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Override v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | MsCall v1 ->
      let v1 = map_wrap env map_of_string v1 in
      todo env v1
  | Explicit (v1, v2) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_paren env (map_expr env)) v2 in
      todo env (v1, v2)

and map_access_spec env = function
  | Public -> G.Public
  | Private -> G.Private
  | Protected -> G.Protected

and map_type_qualifier env x =
  match x with
  | Const -> todo env x
  | Volatile -> todo env x
  | Restrict -> todo env x
  | Atomic -> todo env x
  | Mutable -> todo env x
  | Constexpr -> todo env x

and map_storage env (x, t) : G.attribute =
  match x with
  | Auto -> G.unhandled_keywordattr ("auto", t)
  | Static -> G.attr G.Static t
  | Register -> G.unhandled_keywordattr ("register", t)
  | Extern -> G.attr G.Extern t
  | StoInline -> G.attr G.Inline t

and map_pointer_modifier env x : G.attribute =
  match x with
  | Based (v1, v2) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2 in
      todo env (v1, v2)
  | PtrRestrict v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Uptr v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Sptr v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Unaligned v1 ->
      let v1 = map_tok env v1 in
      todo env v1

and map_using env (v1, v2, v3) =
  let v1 = map_tok env v1
  and v2 = map_using_kind env v2
  and v3 = map_sc env v3 in
  (v1, v2, v3)

and map_using_kind env = function
  | UsingName v1 ->
      let v1 = map_name env v1 in
      todo env v1
  | UsingNamespace (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_a_ident_name env v2 in
      todo env (v1, v2)
  | UsingAlias (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_tok env v2
      and v3 = map_type_ env v3 in
      todo env (v1, v2, v3)

and map_cpp_directive env x : (G.directive, G.definition) either =
  match x with
  | Define (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_ident env v2
      and v3 = map_define_kind env v3
      and v4 = map_define_val env v4 in
      todo env (v1, v2, v3, v4)
  | Include (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_include_kind env v2 in
      todo env (v1, v2)
  | Undef v1 ->
      let v1 = map_ident env v1 in
      todo env v1
  | PragmaAndCo v1 ->
      let v1 = map_tok env v1 in
      todo env v1

and map_define_kind env = function
  | DefineVar -> DefineVar
  | DefineMacro v1 ->
      let v1 = map_paren env (map_of_list (map_ident env)) v1 in
      todo env v1

and map_define_val env = function
  | DefineExpr v1 ->
      let v1 = map_expr env v1 in
      todo env v1
  | DefineStmt v1 ->
      let v1 = map_stmt env v1 in
      todo env v1
  | DefineType v1 ->
      let v1 = map_type_ env v1 in
      todo env v1
  | DefineFunction v1 ->
      let v1 = map_func_definition env v1 in
      todo env v1
  | DefineInit v1 ->
      let v1 = map_initialiser env v1 in
      todo env v1
  | DefineDoWhileZero (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_stmt env v2
      and v3 = map_tok env v3
      and v4 = map_paren env (map_tok env) v4 in
      todo env (v1, v2, v3, v4)
  | DefinePrintWrapper (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_expr env) v2
      and v3 = map_name env v3 in
      todo env (v1, v2, v3)
  | DefineEmpty -> DefineEmpty
  | DefineTodo v1 ->
      let v1 = map_todo_category env v1 in
      todo env v1

and map_include_kind env = function
  | IncLocal v1 ->
      let v1 = map_wrap env map_of_string v1 in
      todo env v1
  | IncSystem v1 ->
      let v1 = map_wrap env map_of_string v1 in
      todo env v1
  | IncOther v1 ->
      let v1 = map_a_cppExpr env v1 in
      todo env v1

and map_a_cppExpr env v = map_expr env v

and map_sequencable :
      'a. env -> ('a -> G.stmt list) -> 'a sequencable -> G.stmt list =
 fun env _of_a -> function
  | X v1 ->
      let v1 = _of_a v1 in
      todo env v1
  | CppDirective v1 ->
      let v1 = map_cpp_directive env v1 in
      todo env v1
  | CppIfdef v1 ->
      let v1 = map_ifdef_directive env v1 in
      todo env v1
  | MacroTop (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2
      and v3 = map_of_option (map_tok env) v3 in
      todo env (v1, v2, v3)
  | MacroVarTop (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_sc env v2 in
      todo env (v1, v2)

and map_ifdef_directive env = function
  | Ifdef v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | IfdefElse v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | IfdefElseif v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | IfdefEndif v1 ->
      let v1 = map_tok env v1 in
      todo env v1

let map_toplevel env v = map_sequencable env (map_stmt_or_decl env) v

let map_program env v : G.program =
  map_of_list (map_toplevel env) v |> List.flatten

let map_any env x : G.any =
  match x with
  | Expr v1 ->
      let v1 = map_expr env v1 in
      G.E v1
  | Stmt v1 ->
      let v1 = map_stmt env v1 in
      G.S v1
  | Stmts v1 ->
      let v1 = map_of_list (map_stmt env) v1 in
      G.Ss v1
  | Toplevel v1 -> (
      let v1 = map_toplevel env v1 in
      match v1 with
      | [ x ] -> G.S x
      | xs -> G.Ss xs)
  | Toplevels v1 ->
      let v1 = map_of_list (map_toplevel env) v1 |> List.flatten in
      G.Ss v1
  | Program v1 ->
      let v1 = map_program env v1 in
      G.Ss v1
  | Cpp v1 ->
      let v1 = map_cpp_directive env v1 in
      todo env v1
  | Type v1 ->
      let v1 = map_type_ env v1 in
      G.T v1
  | Name v1 ->
      let v1 = map_name env v1 in
      todo env v1
  | OneDecl v1 ->
      let v1 = map_onedecl env v1 in
      todo env v1
  | Init v1 ->
      let v1 = map_initialiser env v1 in
      todo env v1
  | ClassMember v1 ->
      let v1 = map_class_member env v1 in
      todo env v1
  | Constant v1 ->
      let v1 = map_constant env v1 in
      todo env v1
  | Argument v1 ->
      let v1 = map_argument env v1 in
      todo env v1
  | Parameter v1 ->
      let v1 = map_parameter env v1 in
      todo env v1
  | Body v1 ->
      let v1 = map_compound env v1 in
      todo env v1
  | Info v1 ->
      let v1 = map_tok env v1 in
      G.Tk v1
  | InfoList v1 ->
      let v1 = map_of_list (map_tok env) v1 in
      todo env v1

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
let any _x =
  ignore map_any;
  failwith "TODO"

let program _cst = failwith "TODO"
