(* Yoann Padioleau
 *
 * Copyright (C) 2021 r2c
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)
open Common

(*
module H = AST_generic_helpers
 *)
open Ast_cpp
open OCaml (* for the map_of_xxx *)

module G = AST_generic

[@@@warning "-26-27"]

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Ast_cpp to AST_generic.
 *
 * See ast_generic.ml for more information.
 *
 * TODO: copy code from ast_c_build.ml, like the ifdef_skipper
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

type env = unit

let _id x = x

let map_either _env _f1 _f2 _x = failwith "TODO"

let todo _env _x = failwith "TODO"

(*****************************************************************************)
(* Conversions *)
(*****************************************************************************)

(* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_map_todo.cmo  pr_o.cmo /tmp/xxx.ml  *)

let map_tok env v = v

let map_wrap env _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = map_tok env v2 in
  (v1, v2)

let map_paren env _of_a (v1, v2, v3) =
  let v1 = map_tok env v1 and v2 = _of_a v2 and v3 = map_tok env v3 in
  (v1, v2, v3)

let map_brace env _of_a (v1, v2, v3) =
  let v1 = map_tok env v1 and v2 = _of_a v2 and v3 = map_tok env v3 in
  (v1, v2, v3)

let map_bracket env _of_a (v1, v2, v3) =
  let v1 = map_tok env v1 and v2 = _of_a v2 and v3 = map_tok env v3 in
  (v1, v2, v3)

let map_angle env _of_a (v1, v2, v3) = _of_a v2

let _map_angle_keep env _of_a (v1, v2, v3) =
  let v1 = map_tok env v1 and v2 = _of_a v2 and v3 = map_tok env v3 in
  (v1, v2, v3)

let map_sc env v = map_tok env v

let map_todo_category env v = map_wrap env map_of_string v

let map_ident env v = map_wrap env map_of_string v

let rec map_name env (v1, v2, v3) : G.name =
  let v1 = map_of_option (map_tok env) v1
  and v2 = map_of_list (map_qualifier env) v2
  and v3 = map_ident_or_op env v3 in
  todo env (v1, v2, v3)

and map_ident_or_op env = function
  | IdIdent v1 ->
      let v1 = map_ident env v1 in
      todo env v1
  | IdTemplateId (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_template_arguments env v2 in
      todo env (v1, v2)
  | IdOperator v1 ->
      let v1 =
        match v1 with
        | v1, v2 ->
            let v1 = map_tok env v1
            and v2 =
              match v2 with
              | v1, v2 ->
                  let v1 = map_operator env v1
                  and v2 = map_of_list (map_tok env) v2 in
                  (v1, v2)
            in
            (v1, v2)
      in
      todo env v1
  | IdDestructor (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_ident env v2 in
      todo env (v1, v2)
  | IdConverter (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      todo env (v1, v2)

and map_template_arguments env (l, v, r) : G.type_arguments =
  let xs = (map_of_list (map_template_argument env)) v in
  todo env xs

and map_template_argument env v : G.type_argument =
  match v with
  | Left t ->
      let t = map_type_ env t in
      todo env t
  | Right e ->
      let e = map_expr env e in
      todo env e

and map_qualifier env = function
  | QClassname v1 ->
      let v1 = map_ident env v1 in
      todo env v1
  | QTemplateId (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_template_arguments env v2 in
      todo env (v1, v2)

and map_a_class_name env v = map_name env v

and map_a_ident_name env v = map_name env v

and map_type_ env (v1, v2) : G.type_ =
  let v1 = map_type_qualifiers env v1 and v2 = map_typeC env v2 in
  todo env (v1, v2)

and map_typeC env x : G.type_kind =
  match x with
  | TBase v1 ->
      let v1 = map_baseType env v1 in
      todo env v1
  | TPrimitive v1 ->
      let v1 = map_wrap env (map_primitive_type env) v1 in
      todo env v1
  | TSized (v1, v2) ->
      let v1 = map_of_list (map_wrap env (map_sized_type env)) v1
      and v2 = map_of_option (map_type_ env) v2 in
      todo env (v1, v2)
  | TPointer (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_type_ env v2
      and v3 = map_of_list (map_pointer_modifier env) v3 in
      todo env (v1, v2, v3)
  | TReference (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      todo env (v1, v2)
  | TRefRef (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      todo env (v1, v2)
  | TArray (v1, v2) ->
      let v1 = map_bracket env (map_of_option (map_a_const_expr env)) v1
      and v2 = map_type_ env v2 in
      todo env (v1, v2)
  | TFunction v1 ->
      let v1 = map_functionType env v1 in
      todo env v1
  | EnumName (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_a_ident_name env v2 in
      todo env (v1, v2)
  | ClassName (v1, v2) ->
      let v1 = map_wrap env (map_class_key env) v1
      and v2 = map_a_class_name env v2 in
      todo env (v1, v2)
  | TypeName v1 ->
      let v1 = map_a_ident_name env v1 in
      todo env v1
  | TypenameKwd (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      todo env (v1, v2)
  | EnumDef v1 ->
      let v1 = map_enum_definition env v1 in
      todo env v1
  | ClassDef v1 ->
      let v1 = map_class_definition env v1 in
      todo env v1
  | TypeOf (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_paren env (map_either env (map_type_ env) (map_expr env)) v2
      in
      todo env (v1, v2)
  | TAuto v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | ParenType v1 ->
      let v1 = map_paren env (map_type_ env) v1 in
      todo env v1
  | TypeTodo (v1, v2) ->
      let v1 = map_todo_category env v1
      and v2 = map_of_list (map_type_ env) v2 in
      todo env (v1, v2)

and map_baseType env = function
  | Void v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | IntType (v1, v2) ->
      let v1 = map_intType env v1 and v2 = map_tok env v2 in
      todo env (v1, v2)
  | FloatType (v1, v2) ->
      let v1 = map_floatType env v1 and v2 = map_tok env v2 in
      todo env (v1, v2)

and map_intType env = function
  | CChar -> CChar
  | Si v1 ->
      let v1 = map_signed env v1 in
      todo env v1
  | CBool -> CBool
  | WChar_t -> WChar_t

and map_signed env (v1, v2) =
  let v1 = map_sign env v1 and v2 = map_base env v2 in
  (v1, v2)

and map_base env = function
  | CChar2 -> CChar2
  | CShort -> CShort
  | CInt -> CInt
  | CLong -> CLong
  | CLongLong -> CLongLong

and map_sign env = function Signed -> Signed | UnSigned -> UnSigned

and map_floatType env = function
  | CFloat -> CFloat
  | CDouble -> CDouble
  | CLongDouble -> CLongDouble

and map_primitive_type env = function
  | TVoid -> TVoid
  | TBool -> TBool
  | TChar -> TChar
  | TInt -> TInt
  | TFloat -> TFloat
  | TDouble -> TDouble

and map_sized_type env = function
  | TSigned -> TSigned
  | TUnsigned -> TUnsigned
  | TShort -> TShort
  | TLong -> TLong

and map_type_qualifiers env v =
  map_of_list (map_wrap env (map_type_qualifier env)) v

and map_expr env x : G.expr =
  match x with
  | N (v1, v2) ->
      let v1 = map_name env v1 and v2 = map_ident_info env v2 in
      todo env (v1, v2)
  | C v1 ->
      let v1 = map_constant env v1 in
      todo env v1
  | IdSpecial v1 ->
      let v1 = map_wrap env (map_special env) v1 in
      todo env v1
  | Call (v1, v2) ->
      let v1 = map_expr env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2 in
      todo env (v1, v2)
  | CondExpr (v1, v2, v3, v4, v5) ->
      let v1 = map_expr env v1
      and v2 = map_tok env v2
      and v3 = map_of_option (map_expr env) v3
      and v4 = map_tok env v4
      and v5 = map_expr env v5 in
      todo env (v1, v2, v3, v4, v5)
  | Sequence (v1, v2, v3) ->
      let v1 = map_expr env v1
      and v2 = map_tok env v2
      and v3 = map_expr env v3 in
      todo env (v1, v2, v3)
  | Assign (v1, v2, v3) ->
      let v1 = map_a_lhs env v1
      and v2 = map_assignOp env v2
      and v3 = map_expr env v3 in
      todo env (v1, v2, v3)
  | Prefix (v1, v2) ->
      let v1 = map_wrap env (map_fixOp env) v1 and v2 = map_expr env v2 in
      todo env (v1, v2)
  | Postfix (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_wrap env (map_fixOp env) v2 in
      todo env (v1, v2)
  | Unary (v1, v2) ->
      let v1 = map_wrap env (map_unaryOp env) v1 and v2 = map_expr env v2 in
      todo env (v1, v2)
  | Binary (v1, v2, v3) ->
      let v1 = map_expr env v1
      and v2 = map_wrap env (map_binaryOp env) v2
      and v3 = map_expr env v3 in
      todo env (v1, v2, v3)
  | ArrayAccess (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_bracket env (map_expr env) v2 in
      todo env (v1, v2)
  | DotAccess (v1, v2, v3) ->
      let v1 = map_expr env v1
      and v2 = map_wrap env (map_dotOp env) v2
      and v3 = map_name env v3 in
      todo env (v1, v2, v3)
  | DotStarAccess (v1, v2, v3) ->
      let v1 = map_expr env v1
      and v2 = map_wrap env (map_dotOp env) v2
      and v3 = map_expr env v3 in
      todo env (v1, v2, v3)
  | SizeOf (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_either env (map_expr env) (map_paren env (map_type_ env)) v2
      in
      todo env (v1, v2)
  | Cast (v1, v2) ->
      let v1 = map_paren env (map_type_ env) v1 and v2 = map_expr env v2 in
      todo env (v1, v2)
  | StatementExpr v1 ->
      let v1 = map_paren env (map_compound env) v1 in
      todo env v1
  | GccConstructor (v1, v2) ->
      let v1 = map_paren env (map_type_ env) v1
      and v2 = map_brace env (map_of_list (map_initialiser env)) v2 in
      todo env (v1, v2)
  | ConstructedObject (v1, v2) ->
      let v1 = map_type_ env v1 and v2 = map_obj_init env v2 in
      todo env (v1, v2)
  | TypeId (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_paren env (map_either env (map_type_ env) (map_expr env)) v2
      in
      todo env (v1, v2)
  | CplusplusCast (v1, v2, v3) ->
      let v1 = map_wrap env (map_cast_operator env) v1
      and v2 = map_angle env (map_type_ env) v2
      and v3 = map_paren env (map_expr env) v3 in
      todo env (v1, v2, v3)
  | New (v1, v2, v3, v4, v5) ->
      let v1 = map_of_option (map_tok env) v1
      and v2 = map_tok env v2
      and v3 = map_of_option (map_paren env (map_of_list (map_argument env))) v3
      and v4 = map_type_ env v4
      and v5 = map_of_option (map_obj_init env) v5 in
      todo env (v1, v2, v3, v4, v5)
  | Delete (v1, v2, v3, v4) ->
      let v1 = map_of_option (map_tok env) v1
      and v2 = map_tok env v2
      and v3 = map_of_option (map_bracket env map_of_unit) v3
      and v4 = map_expr env v4 in
      todo env (v1, v2, v3, v4)
  | Throw (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_of_option (map_expr env) v2 in
      todo env (v1, v2)
  | Lambda v1 ->
      let v1 = map_lambda_definition env v1 in
      todo env v1
  | ParamPackExpansion (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_tok env v2 in
      todo env (v1, v2)
  | ParenExpr v1 ->
      let v1 = map_paren env (map_expr env) v1 in
      todo env v1
  | Ellipses v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | DeepEllipsis v1 ->
      let v1 = map_bracket env (map_expr env) v1 in
      todo env v1
  | TypedMetavar (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_type_ env v2 in
      todo env (v1, v2)
  | ExprTodo (v1, v2) ->
      let v1 = map_todo_category env v1
      and v2 = map_of_list (map_expr env) v2 in
      todo env (v1, v2)

and map_ident_info env { i_scope = _v_i_scope } = todo env ()

and map_special env = function This -> This | Defined -> Defined

and map_argument env x : G.argument =
  match x with
  | Arg v1 ->
      let v1 = map_expr env v1 in
      todo env v1
  | ArgType v1 ->
      let v1 = map_type_ env v1 in
      todo env v1
  | ArgAction v1 ->
      let v1 = map_action_macro env v1 in
      todo env v1
  | ArgInits v1 ->
      let v1 = map_brace env (map_of_list (map_initialiser env)) v1 in
      todo env v1

and map_action_macro env = function
  | ActMisc v1 ->
      let v1 = map_of_list (map_tok env) v1 in
      todo env v1

and map_constant env x : G.literal =
  match x with
  | Int v1 ->
      let v1 = map_wrap env (map_of_option map_of_int) v1 in
      todo env v1
  | Float v1 ->
      let v1 =
        match v1 with
        | v1, v2 ->
            let v1 = map_wrap env (map_of_option map_of_float) v1
            and v2 = map_floatType env v2 in
            (v1, v2)
      in
      todo env v1
  | Char v1 ->
      let v1 =
        match v1 with
        | v1, v2 ->
            let v1 = map_wrap env map_of_string v1
            and v2 = map_isWchar env v2 in
            (v1, v2)
      in
      todo env v1
  | String v1 ->
      let v1 =
        match v1 with
        | v1, v2 ->
            let v1 = map_wrap env map_of_string v1
            and v2 = map_isWchar env v2 in
            (v1, v2)
      in
      todo env v1
  | MultiString v1 ->
      let v1 = map_of_list (map_wrap env map_of_string) v1 in
      todo env v1
  | Bool v1 ->
      let v1 = map_wrap env map_of_bool v1 in
      todo env v1
  | Nullptr v1 ->
      let v1 = map_tok env v1 in
      todo env v1

and map_isWchar env = function IsWchar -> IsWchar | IsChar -> IsChar

and map_unaryOp env = function
  | UnPlus -> UnPlus
  | UnMinus -> UnMinus
  | Tilde -> Tilde
  | Not -> Not
  | GetRef -> GetRef
  | DeRef -> DeRef
  | GetRefLabel -> GetRefLabel

and map_assignOp env = function
  | SimpleAssign v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | OpAssign v1 ->
      let v1 = map_wrap env (map_arithOp env) v1 in
      todo env v1

and map_fixOp env = function Dec -> Dec | Inc -> Inc

and map_dotOp env = function Dot -> Dot | Arrow -> Arrow

and map_binaryOp env = function
  | Arith v1 ->
      let v1 = map_arithOp env v1 in
      todo env v1
  | Logical v1 ->
      let v1 = map_logicalOp env v1 in
      todo env v1

and map_arithOp env = function
  | Plus -> Plus
  | Minus -> Minus
  | Mul -> Mul
  | Div -> Div
  | Mod -> Mod
  | DecLeft -> DecLeft
  | DecRight -> DecRight
  | And -> And
  | Or -> Or
  | Xor -> Xor

and map_logicalOp env = function
  | Inf -> Inf
  | Sup -> Sup
  | InfEq -> InfEq
  | SupEq -> SupEq
  | Eq -> Eq
  | NotEq -> NotEq
  | AndLog -> AndLog
  | OrLog -> OrLog

and map_ptrOp env = function PtrStarOp -> PtrStarOp | PtrOp -> PtrOp

and map_allocOp env = function
  | NewOp -> NewOp
  | DeleteOp -> DeleteOp
  | NewArrayOp -> NewArrayOp
  | DeleteArrayOp -> DeleteArrayOp

and map_accessop env = function ParenOp -> ParenOp | ArrayOp -> ArrayOp

and map_operator env = function
  | BinaryOp v1 ->
      let v1 = map_binaryOp env v1 in
      todo env v1
  | AssignOp v1 ->
      let v1 = map_assignOp env v1 in
      todo env v1
  | FixOp v1 ->
      let v1 = map_fixOp env v1 in
      todo env v1
  | PtrOpOp v1 ->
      let v1 = map_ptrOp env v1 in
      todo env v1
  | AccessOp v1 ->
      let v1 = map_accessop env v1 in
      todo env v1
  | AllocOp v1 ->
      let v1 = map_allocOp env v1 in
      todo env v1
  | UnaryTildeOp -> UnaryTildeOp
  | UnaryNotOp -> UnaryNotOp
  | CommaOp -> CommaOp

and map_cast_operator env = function
  | Static_cast -> Static_cast
  | Dynamic_cast -> Dynamic_cast
  | Const_cast -> Const_cast
  | Reinterpret_cast -> Reinterpret_cast

and map_a_const_expr env v = map_expr env v

and map_a_lhs env v = map_expr env v

and map_stmt env x : G.stmt =
  match x with
  | Compound v1 ->
      let v1 = map_compound env v1 in
      todo env v1
  | ExprStmt v1 ->
      let v1 = map_expr_stmt env v1 in
      todo env v1
  | MacroStmt v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | If (v1, v2, v3, v4, v5) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_tok env) v2
      and v3 = map_paren env (map_condition_clause env) v3
      and v4 = map_stmt env v4
      and v5 =
        map_of_option
          (fun (v1, v2) ->
            let v1 = map_tok env v1 and v2 = map_stmt env v2 in
            (v1, v2))
          v5
      in
      todo env (v1, v2, v3, v4, v5)
  | Switch (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_condition_clause env) v2
      and v3 = map_stmt env v3 in
      todo env (v1, v2, v3)
  | While (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_condition_clause env) v2
      and v3 = map_stmt env v3 in
      todo env (v1, v2, v3)
  | DoWhile (v1, v2, v3, v4, v5) ->
      let v1 = map_tok env v1
      and v2 = map_stmt env v2
      and v3 = map_tok env v3
      and v4 = map_paren env (map_expr env) v4
      and v5 = map_sc env v5 in
      todo env (v1, v2, v3, v4, v5)
  | For (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_for_header env) v2
      and v3 = map_stmt env v3 in
      todo env (v1, v2, v3)
  | MacroIteration (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2
      and v3 = map_stmt env v3 in
      todo env (v1, v2, v3)
  | Jump (v1, v2) ->
      let v1 = map_jump env v1 and v2 = map_sc env v2 in
      todo env (v1, v2)
  | Label (v1, v2, v3) ->
      let v1 = map_a_label env v1
      and v2 = map_tok env v2
      and v3 = map_stmt env v3 in
      todo env (v1, v2, v3)
  | Case (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_expr env v2
      and v3 = map_tok env v3
      and v4 = map_case_body env v4 in
      todo env (v1, v2, v3, v4)
  | CaseRange (v1, v2, v3, v4, v5, v6) ->
      let v1 = map_tok env v1
      and v2 = map_expr env v2
      and v3 = map_tok env v3
      and v4 = map_expr env v4
      and v5 = map_tok env v5
      and v6 = map_case_body env v6 in
      todo env (v1, v2, v3, v4, v5, v6)
  | Default (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_tok env v2
      and v3 = map_case_body env v3 in
      todo env (v1, v2, v3)
  | Try (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_compound env v2
      and v3 = map_of_list (map_handler env) v3 in
      todo env (v1, v2, v3)
  | StmtTodo (v1, v2) ->
      let v1 = map_todo_category env v1
      and v2 = map_of_list (map_stmt env) v2 in
      todo env (v1, v2)

and map_expr_stmt env (v1, v2) =
  let v1 = map_of_option (map_expr env) v1 and v2 = map_sc env v2 in
  (v1, v2)

and map_condition_clause env = function
  | CondClassic v1 ->
      let v1 = map_expr env v1 in
      todo env v1
  | CondDecl (v1, v2) ->
      let v1 = map_vars_decl env v1 and v2 = map_expr env v2 in
      todo env (v1, v2)
  | CondStmt (v1, v2) ->
      let v1 = map_expr_stmt env v1 and v2 = map_expr env v2 in
      todo env (v1, v2)
  | CondOneDecl v1 ->
      let v1 = map_onedecl env v1 in
      todo env v1

and map_for_header env = function
  | ForClassic (v1, v2, v3) ->
      let v1 = map_a_expr_or_vars env v1
      and v2 = map_of_option (map_expr env) v2
      and v3 = map_of_option (map_expr env) v3 in
      todo env (v1, v2, v3)
  | ForRange (v1, v2, v3) ->
      let v1 = map_var env v1
      and v2 = map_tok env v2
      and v3 = map_initialiser env v3 in
      todo env (v1, v2, v3)

and map_a_expr_or_vars env v =
  map_either env (map_expr_stmt env) (map_vars_decl env) v

and map_a_label env v = map_wrap env map_of_string v

and map_jump env = function
  | Goto (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_a_label env v2 in
      todo env (v1, v2)
  | Continue v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Break v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Return (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_of_option (map_argument env) v2 in
      todo env (v1, v2)
  | GotoComputed (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_tok env v2
      and v3 = map_expr env v3 in
      todo env (v1, v2, v3)

and map_case_body env v = map_of_list (map_stmt_or_decl env) v

and map_handler env (v1, v2, v3) =
  let v1 = map_tok env v1
  and v2 = map_paren env (map_of_list (map_exception_declaration env)) v2
  and v3 = map_compound env v3 in
  (v1, v2, v3)

and map_exception_declaration env = function
  | ExnDecl v1 ->
      let v1 = map_parameter env v1 in
      todo env v1
  | ExnDeclEllipsis v1 ->
      let v1 = map_tok env v1 in
      todo env v1

and map_stmt_or_decl env x : G.stmt list =
  match x with
  | S v1 ->
      let v1 = map_stmt env v1 in
      todo env v1
  | D v1 ->
      let v1 = map_decl env v1 in
      todo env v1

and map_compound env (l, v, r) : G.stmt list bracket =
  let xs = map_of_list (map_sequencable env (map_stmt_or_decl env)) v in
  (l, List.flatten xs, r)

and map_declarations env (l, v, r) : G.stmt list bracket =
  let xs = map_of_list (map_sequencable env (map_stmt_or_decl env)) v in
  (l, List.flatten xs, r)

and map_entity env { name = v_name; specs = v_specs } : G.entity =
  let v_specs = map_of_list (map_specifier env) v_specs in
  let v_name = map_name env v_name in
  todo env ()

and map_decl env x : G.stmt list =
  match x with
  | DeclList v1 ->
      let v1 = map_vars_decl env v1 in
      todo env v1
  | MacroDecl (v1, v2, v3, v4) ->
      let v1 = map_of_list (map_tok env) v1
      and v2 = map_ident env v2
      and v3 = map_paren env (map_of_list (map_argument env)) v3
      and v4 = map_tok env v4 in
      todo env (v1, v2, v3, v4)
  | UsingDecl v1 ->
      let v1 = map_using env v1 in
      todo env v1
  | NameSpaceAlias (v1, v2, v3, v4, v5) ->
      let v1 = map_tok env v1
      and v2 = map_ident env v2
      and v3 = map_tok env v3
      and v4 = map_type_ env v4
      and v5 = map_sc env v5 in
      todo env (v1, v2, v3, v4, v5)
  | Asm (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_tok env) v2
      and v3 = map_paren env (map_asmbody env) v3
      and v4 = map_sc env v4 in
      todo env (v1, v2, v3, v4)
  | Func v1 ->
      let v1 = map_func_definition env v1 in
      todo env v1
  | TemplateDecl (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_template_parameters env v2
      and v3 = map_decl env v3 in
      todo env (v1, v2, v3)
  | TemplateSpecialization (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_angle env map_of_unit v2
      and v3 = map_decl env v3 in
      todo env (v1, v2, v3)
  | TemplateInstanciation (v1, v2, v3) ->
      let v1 = map_tok env v1 and v2 = map_var env v2 and v3 = map_sc env v3 in
      todo env (v1, v2, v3)
  | ExternDecl (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_wrap env map_of_string v2
      and v3 = map_decl env v3 in
      todo env (v1, v2, v3)
  | ExternList (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_wrap env map_of_string v2
      and v3 = map_declarations env v3 in
      todo env (v1, v2, v3)
  | NameSpace (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_ident env) v2
      and v3 = map_declarations env v3 in
      todo env (v1, v2, v3)
  | StaticAssert (v1, v2) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2 in
      todo env (v1, v2)
  | EmptyDef v1 ->
      let v1 = map_sc env v1 in
      todo env v1
  | NotParsedCorrectly v1 ->
      let v1 = map_of_list (map_tok env) v1 in
      todo env v1
  | DeclTodo v1 ->
      let v1 = map_todo_category env v1 in
      todo env v1

and map_vars_decl env (v1, v2) =
  let v1 = map_of_list (map_onedecl env) v1 and v2 = map_sc env v2 in
  (v1, v2)

and map_asmbody env (v1, v2) =
  let v1 = map_of_list (map_wrap env map_of_string) v1
  and v2 = map_of_list (map_colon env) v2 in
  (v1, v2)

and map_colon env = function
  | Colon (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_of_list (map_colon_option env) v2 in
      todo env (v1, v2)

and map_colon_option env = function
  | ColonExpr (v1, v2) ->
      let v1 = map_of_list (map_tok env) v1
      and v2 = map_paren env (map_expr env) v2 in
      todo env (v1, v2)
  | ColonMisc v1 ->
      let v1 = map_of_list (map_tok env) v1 in
      todo env v1

and map_var env (v1, v2) =
  let v1 = map_entity env v1 and v2 = map_var_decl env v2 in
  (v1, v2)

and map_var_decl env { v__type = v_v__type } =
  let v_v__type = map_type_ env v_v__type in
  todo env ()

and map_onedecl env
    {
      v_namei = v_v_namei;
      v_type = v_v_type;
      v_storage = v_v_storage;
      v_specs = v_v_specs;
    } =
  let v_v_specs = map_of_list (map_specifier env) v_v_specs in
  let v_v_storage = map_storage_opt env v_v_storage in
  let v_v_type = map_type_ env v_v_type in
  let v_v_namei =
    map_of_option
      (fun (v1, v2) ->
        let v1 = map_declarator_name env v1
        and v2 = map_of_option (map_init env) v2 in
        (v1, v2))
      v_v_namei
  in
  todo env ()

and map_declarator_name env = function
  | DN v1 ->
      let v1 = map_name env v1 in
      todo env v1
  | DNStructuredBinding v1 ->
      let v1 = map_bracket env (map_of_list (map_ident env)) v1 in
      todo env v1

and map_storage_opt env = function
  | NoSto -> NoSto
  | StoTypedef v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Sto v1 ->
      let v1 = map_wrap env (map_storage env) v1 in
      todo env v1

and map_init env = function
  | EqInit (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_initialiser env v2 in
      todo env (v1, v2)
  | ObjInit v1 ->
      let v1 = map_obj_init env v1 in
      todo env v1
  | Bitfield (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_a_const_expr env v2 in
      todo env (v1, v2)

and map_obj_init env = function
  | Args v1 ->
      let v1 = map_paren env (map_of_list (map_argument env)) v1 in
      todo env v1
  | Inits v1 ->
      let v1 = map_brace env (map_of_list (map_initialiser env)) v1 in
      todo env v1

and map_initialiser env x : G.expr =
  match x with
  | InitExpr v1 ->
      let v1 = map_expr env v1 in
      todo env v1
  | InitList v1 ->
      let v1 = map_brace env (map_of_list (map_initialiser env)) v1 in
      todo env v1
  | InitDesignators (v1, v2, v3) ->
      let v1 = map_of_list (map_designator env) v1
      and v2 = map_tok env v2
      and v3 = map_initialiser env v3 in
      todo env (v1, v2, v3)
  | InitFieldOld (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_tok env v2
      and v3 = map_initialiser env v3 in
      todo env (v1, v2, v3)
  | InitIndexOld (v1, v2) ->
      let v1 = map_bracket env (map_expr env) v1
      and v2 = map_initialiser env v2 in
      todo env (v1, v2)

and map_designator env = function
  | DesignatorField (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_ident env v2 in
      todo env (v1, v2)
  | DesignatorIndex v1 ->
      let v1 = map_bracket env (map_expr env) v1 in
      todo env v1
  | DesignatorRange v1 ->
      let v1 =
        map_bracket env
          (fun (v1, v2, v3) ->
            let v1 = map_expr env v1
            and v2 = map_tok env v2
            and v3 = map_expr env v3 in
            (v1, v2, v3))
          v1
      in
      todo env v1

and map_func_definition env (v1, v2) : G.definition =
  let v1 = map_entity env v1 and v2 = map_function_definition env v2 in
  (v1, v2)

and map_function_definition env
    {
      f_type = v_f_type;
      f_storage = v_f_storage;
      f_body = v_f_body;
      f_specs = v_f_specs;
    } =
  let v_f_specs = map_of_list (map_specifier env) v_f_specs in
  let v_f_body = map_function_body env v_f_body in
  let v_f_storage = map_storage_opt env v_f_storage in
  let v_f_type = map_functionType env v_f_type in
  todo env ()

and map_functionType env
    {
      ft_ret = v_ft_ret;
      ft_params = v_ft_params;
      ft_specs = v_ft_specs;
      ft_const = v_ft_const;
      ft_throw = v_ft_throw;
    } =
  let v_ft_throw = map_of_list (map_exn_spec env) v_ft_throw in
  let v_ft_const = map_of_option (map_tok env) v_ft_const in
  let v_ft_specs = map_of_list (map_specifier env) v_ft_specs in
  let v_ft_params =
    map_paren env (map_of_list (map_parameter env)) v_ft_params
  in
  let v_ft_ret = map_type_ env v_ft_ret in
  todo env ()

and map_parameter env x : G.parameter =
  match x with
  | P v1 ->
      let v1 = map_parameter_classic env v1 in
      todo env v1
  | ParamVariadic (v1, v2, v3) ->
      let v1 = map_of_option (map_tok env) v1
      and v2 = map_tok env v2
      and v3 = map_parameter_classic env v3 in
      todo env (v1, v2, v3)
  | ParamDots v1 ->
      let v1 = map_tok env v1 in
      todo env v1

and map_parameter_classic env
    {
      p_name = v_p_name;
      p_type = v_p_type;
      p_register = v_p_register;
      p_specs = v_p_specs;
      p_val = v_p_val;
    } =
  let v_p_val =
    map_of_option
      (fun (v1, v2) ->
        let v1 = map_tok env v1 and v2 = map_expr env v2 in
        (v1, v2))
      v_p_val
  in
  let v_p_specs = map_of_list (map_specifier env) v_p_specs in
  let v_p_register = map_of_option (map_tok env) v_p_register in
  let v_p_type = map_type_ env v_p_type in
  let v_p_name = map_of_option (map_ident env) v_p_name in
  todo env ()

and map_exn_spec env = function
  | ThrowSpec (v1, v2) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_of_list (map_type_ env)) v2 in
      todo env (v1, v2)
  | Noexcept (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_of_option (map_paren env (map_of_option (map_a_const_expr env))) v2
      in
      todo env (v1, v2)

and map_function_body env = function
  | FBDef v1 ->
      let v1 = map_compound env v1 in
      todo env v1
  | FBDecl v1 ->
      let v1 = map_sc env v1 in
      todo env v1
  | FBZero (v1, v2, v3) ->
      let v1 = map_tok env v1 and v2 = map_tok env v2 and v3 = map_sc env v3 in
      todo env (v1, v2, v3)
  | FBDefault (v1, v2, v3) ->
      let v1 = map_tok env v1 and v2 = map_tok env v2 and v3 = map_sc env v3 in
      todo env (v1, v2, v3)
  | FBDelete (v1, v2, v3) ->
      let v1 = map_tok env v1 and v2 = map_tok env v2 and v3 = map_sc env v3 in
      todo env (v1, v2, v3)

and map_lambda_definition env (v1, v2) : G.expr =
  let v1 = map_bracket env (map_of_list (map_lambda_capture env)) v1
  and v2 = map_function_definition env v2 in
  todo env (v1, v2)

and map_lambda_capture env = function
  | CaptureEq v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | CaptureRef v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | CaptureOther v1 ->
      let v1 = map_expr env v1 in
      todo env v1

and map_enum_definition env
    {
      enum_kind = v_enum_kind;
      enum_name = v_enum_name;
      enum_body = v_enum_body;
    } : G.definition =
  let v_enum_body =
    map_brace env (map_of_list (map_enum_elem env)) v_enum_body
  in
  let v_enum_name = map_of_option (map_name env) v_enum_name in
  let v_enum_kind = map_tok env v_enum_kind in
  todo env ()

and map_enum_elem env { e_name = v_e_name; e_val = v_e_val } =
  let v_e_val =
    map_of_option
      (fun (v1, v2) ->
        let v1 = map_tok env v1 and v2 = map_a_const_expr env v2 in
        (v1, v2))
      v_e_val
  in
  let v_e_name = map_ident env v_e_name in
  todo env ()

and map_class_definition env (v1, v2) : G.definition =
  let v1 = map_of_option (map_a_class_name env) v1
  and v2 = map_class_definition_bis env v2 in
  todo env (v1, v2)

and map_class_definition_bis env
    { c_kind = v_c_kind; c_inherit = v_c_inherit; c_members = v_c_members } =
  let v_c_members =
    map_brace env
      (map_of_list (map_sequencable env (map_class_member env)))
      v_c_members
  in
  let v_c_inherit = map_of_list (map_base_clause env) v_c_inherit in
  let v_c_kind = map_wrap env (map_class_key env) v_c_kind in
  todo env ()

and map_class_key env = function
  | Struct -> Struct
  | Union -> Union
  | Class -> Class

and map_base_clause env
    { i_name = v_i_name; i_virtual = v_i_virtual; i_access = v_i_access } =
  let v_i_access =
    map_of_option (map_wrap env (map_access_spec env)) v_i_access
  in
  let v_i_virtual = map_of_option (map_modifier env) v_i_virtual in
  let v_i_name = map_a_class_name env v_i_name in
  todo env ()

and map_class_member env x (* : G.field list *) =
  match x with
  | Access (v1, v2) ->
      let v1 = map_wrap env (map_access_spec env) v1 and v2 = map_tok env v2 in
      todo env (v1, v2)
  | FieldList (v1, v2) ->
      let v1 = map_of_list (map_fieldkind env) v1 and v2 = map_sc env v2 in
      todo env (v1, v2)
  | Friend (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_decl env v2 in
      todo env (v1, v2)
  | QualifiedIdInClass (v1, v2) ->
      let v1 = map_name env v1 and v2 = map_sc env v2 in
      todo env (v1, v2)
  | MemberDecl v1 ->
      let v1 = map_decl env v1 in
      todo env v1

and map_fieldkind env = function
  | FieldDecl v1 ->
      let v1 = map_onedecl env v1 in
      todo env v1
  | BitField (v1, v2, v3, v4) ->
      let v1 = map_of_option (map_ident env) v1
      and v2 = map_tok env v2
      and v3 = map_type_ env v3
      and v4 = map_a_const_expr env v4 in
      todo env (v1, v2, v3, v4)

and map_template_parameter env x : G.type_parameter =
  match x with
  | TP v1 ->
      let v1 = map_parameter env v1 in
      todo env v1
  | TPClass (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_ident env) v2
      and v3 = map_of_option (map_type_ env) v3 in
      todo env (v1, v2, v3)
  | TPVariadic (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_tok env v2
      and v3 = map_of_option (map_ident env) v3 in
      todo env (v1, v2, v3)
  | TPNested (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_template_parameters env v2
      and v3 = map_template_parameter env v3 in
      todo env (v1, v2, v3)

and map_template_parameters env v : G.type_parameter list =
  map_angle env (map_of_list (map_template_parameter env)) v

and map_specifier env x : G.attribute =
  match x with
  | A v1 ->
      let v1 = map_attribute env v1 in
      todo env v1
  | M v1 ->
      let v1 = map_modifier env v1 in
      todo env v1
  | TQ v1 ->
      let v1 = map_wrap env (map_type_qualifier env) v1 in
      todo env v1
  | ST v1 ->
      let v1 = map_wrap env (map_storage env) v1 in
      todo env v1

and map_attribute env = function
  | UnderscoresAttr (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_paren env (map_paren env (map_of_list (map_argument env))) v2
      in
      todo env (v1, v2)
  | BracketsAttr v1 ->
      let v1 = map_bracket env (map_of_list (map_expr env)) v1 in
      todo env v1
  | DeclSpec (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_paren env (map_ident env) v2 in
      todo env (v1, v2)

and map_modifier env = function
  | Inline v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Virtual v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Final v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Override v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | MsCall v1 ->
      let v1 = map_wrap env map_of_string v1 in
      todo env v1
  | Explicit (v1, v2) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_paren env (map_expr env)) v2 in
      todo env (v1, v2)

and map_access_spec env = function
  | Public -> Public
  | Private -> Private
  | Protected -> Protected

and map_type_qualifier env = function
  | Const -> Const
  | Volatile -> Volatile
  | Restrict -> Restrict
  | Atomic -> Atomic
  | Mutable -> Mutable
  | Constexpr -> Constexpr

and map_storage env = function
  | Auto -> Auto
  | Static -> Static
  | Register -> Register
  | Extern -> Extern
  | StoInline -> StoInline

and map_pointer_modifier env = function
  | Based (v1, v2) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2 in
      todo env (v1, v2)
  | PtrRestrict v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Uptr v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Sptr v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | Unaligned v1 ->
      let v1 = map_tok env v1 in
      todo env v1

and map_using env (v1, v2, v3) =
  let v1 = map_tok env v1
  and v2 = map_using_kind env v2
  and v3 = map_sc env v3 in
  (v1, v2, v3)

and map_using_kind env = function
  | UsingName v1 ->
      let v1 = map_name env v1 in
      todo env v1
  | UsingNamespace (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_a_ident_name env v2 in
      todo env (v1, v2)
  | UsingAlias (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_tok env v2
      and v3 = map_type_ env v3 in
      todo env (v1, v2, v3)

and map_cpp_directive env x : (G.directive, G.definition) either =
  match x with
  | Define (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_ident env v2
      and v3 = map_define_kind env v3
      and v4 = map_define_val env v4 in
      todo env (v1, v2, v3, v4)
  | Include (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_include_kind env v2 in
      todo env (v1, v2)
  | Undef v1 ->
      let v1 = map_ident env v1 in
      todo env v1
  | PragmaAndCo v1 ->
      let v1 = map_tok env v1 in
      todo env v1

and map_define_kind env = function
  | DefineVar -> DefineVar
  | DefineMacro v1 ->
      let v1 = map_paren env (map_of_list (map_ident env)) v1 in
      todo env v1

and map_define_val env = function
  | DefineExpr v1 ->
      let v1 = map_expr env v1 in
      todo env v1
  | DefineStmt v1 ->
      let v1 = map_stmt env v1 in
      todo env v1
  | DefineType v1 ->
      let v1 = map_type_ env v1 in
      todo env v1
  | DefineFunction v1 ->
      let v1 = map_func_definition env v1 in
      todo env v1
  | DefineInit v1 ->
      let v1 = map_initialiser env v1 in
      todo env v1
  | DefineDoWhileZero (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_stmt env v2
      and v3 = map_tok env v3
      and v4 = map_paren env (map_tok env) v4 in
      todo env (v1, v2, v3, v4)
  | DefinePrintWrapper (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_paren env (map_expr env) v2
      and v3 = map_name env v3 in
      todo env (v1, v2, v3)
  | DefineEmpty -> DefineEmpty
  | DefineTodo v1 ->
      let v1 = map_todo_category env v1 in
      todo env v1

and map_include_kind env = function
  | IncLocal v1 ->
      let v1 = map_wrap env map_of_string v1 in
      todo env v1
  | IncSystem v1 ->
      let v1 = map_wrap env map_of_string v1 in
      todo env v1
  | IncOther v1 ->
      let v1 = map_a_cppExpr env v1 in
      todo env v1

and map_a_cppExpr env v = map_expr env v

and map_sequencable :
      'a. env -> ('a -> G.stmt list) -> 'a sequencable -> G.stmt list =
 fun env _of_a -> function
  | X v1 ->
      let v1 = _of_a v1 in
      todo env v1
  | CppDirective v1 ->
      let v1 = map_cpp_directive env v1 in
      todo env v1
  | CppIfdef v1 ->
      let v1 = map_ifdef_directive env v1 in
      todo env v1
  | MacroTop (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_paren env (map_of_list (map_argument env)) v2
      and v3 = map_of_option (map_tok env) v3 in
      todo env (v1, v2, v3)
  | MacroVarTop (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_sc env v2 in
      todo env (v1, v2)

and map_ifdef_directive env = function
  | Ifdef v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | IfdefElse v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | IfdefElseif v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | IfdefEndif v1 ->
      let v1 = map_tok env v1 in
      todo env v1

let map_toplevel env v = map_sequencable env (map_stmt_or_decl env) v

let map_program env v : G.program =
  map_of_list (map_toplevel env) v |> List.flatten

let map_any env x : G.any =
  match x with
  | Expr v1 ->
      let v1 = map_expr env v1 in
      todo env v1
  | Stmt v1 ->
      let v1 = map_stmt env v1 in
      todo env v1
  | Stmts v1 ->
      let v1 = map_of_list (map_stmt env) v1 in
      todo env v1
  | Toplevel v1 ->
      let v1 = map_toplevel env v1 in
      todo env v1
  | Toplevels v1 ->
      let v1 = map_of_list (map_toplevel env) v1 in
      todo env v1
  | Program v1 ->
      let v1 = map_program env v1 in
      todo env v1
  | Cpp v1 ->
      let v1 = map_cpp_directive env v1 in
      todo env v1
  | Type v1 ->
      let v1 = map_type_ env v1 in
      todo env v1
  | Name v1 ->
      let v1 = map_name env v1 in
      todo env v1
  | OneDecl v1 ->
      let v1 = map_onedecl env v1 in
      todo env v1
  | Init v1 ->
      let v1 = map_initialiser env v1 in
      todo env v1
  | ClassMember v1 ->
      let v1 = map_class_member env v1 in
      todo env v1
  | Constant v1 ->
      let v1 = map_constant env v1 in
      todo env v1
  | Argument v1 ->
      let v1 = map_argument env v1 in
      todo env v1
  | Parameter v1 ->
      let v1 = map_parameter env v1 in
      todo env v1
  | Body v1 ->
      let v1 = map_compound env v1 in
      todo env v1
  | Info v1 ->
      let v1 = map_tok env v1 in
      todo env v1
  | InfoList v1 ->
      let v1 = map_of_list (map_tok env) v1 in
      todo env v1

(*****************************************************************************)
(* Entry point *)
(*****************************************************************************)
let any _x =
  ignore map_any;
  failwith "TODO"

let program _cst = failwith "TODO"
