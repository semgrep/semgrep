(* Yoann Padioleau
 *
 * Copyright (C) 2022 r2c
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)
open AST_generic
module H = Graph_code_AST_helpers
module L = Graph_code_AST_lookup
open Graph_code_AST_env
module T = Type_AST
module V = Visitor_AST

let logger = Logging.get_logger [ __MODULE__ ]

(* to get even more logging *)
let debug = false

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types and errors *)
(*****************************************************************************)
(* This file is used to analyze target code; it should not be used to
 * analyze a pattern, hence the exn below.
 *)
exception SemgrepConstruct of Parse_info.t

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let ( let* ) = Option.bind

let todo_type = None

(* TODO: remove this pragma! *)
[@@@warning "-26-27"]

let map_of_string _x = ()

let map_of_int _x = ()

let map_of_float _x = ()

let map_of_bool _x = ()

let map_of_option = Option.map

let map_of_list = Common.map

let map_token_location _env _x = ()

(* this used to be called todo() by the boilerplate generator *)
let nothing _env _x = ()

(*****************************************************************************)
(* Token (leaf) *)
(*****************************************************************************)

(* Most of the boilerplate code below was generated by ocamltarzan with:
 * camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_map_todo.cmo  pr_o.cmo /tmp/xxx.ml *)

let map_tok env v = nothing env v

let map_wrap env _of_a (v1, v2) =
  let v1 = _of_a v1 and v2 = map_tok env v2 in
  (v1, v2)

let map_bracket env _of_a (v1, v2, v3) =
  let v1 = map_tok env v1 and v2 = _of_a v2 and v3 = map_tok env v3 in
  (v1, v2, v3)

let map_sc env v = map_tok env v

let map_todo_kind env v = map_wrap env map_of_string v

(*****************************************************************************)
(* Names *)
(*****************************************************************************)

let map_ident env v = map_wrap env map_of_string v

let map_dotted_ident env v = map_of_list (map_ident env) v

let map_module_name env = function
  | DottedName v1 ->
      let v1 = map_dotted_ident env v1 in
      nothing env v1
  | FileName v1 ->
      let v1 = map_wrap env map_of_string v1 in
      nothing env v1

(* less: could return a type here too? or better in map_expr? *)
let rec map_name env n =
  if debug then
    logger#trace "map_name: %s" (H.string_of_any (E (N n |> AST_generic.e)));
  H.dotted_ident_of_name_opt n
  |> Option.iter (fun xs ->
         if env.phase = Uses then
           (* !!the uses!! *)
           let n2opt = L.lookup_dotted_ident_opt env xs in
           n2opt |> Option.iter (fun n2 -> H.add_use_edge env n2));
  match n with
  | Id (v1, v2) ->
      (if env.phase = Uses then
       (* !!the uses!! *)
       match !(v2.id_resolved) with
       | None
       | Some (Global, _) ->
           (* try locally *)
           let n2opt = L.lookup_local_file_opt env v1 in
           n2opt |> Option.iter (fun n2 -> H.add_use_edge env n2)
       (* TODO: ImportedModule Filename => lookup E.File *)
       | _ -> ());
      (* ----------- *)
      (* Boilerplate *)
      (* ----------- *)
      let v1 = map_ident env v1 and v2 = map_id_info env v2 in
      nothing env (v1, v2)
  | IdQualified v1 ->
      (* ----------- *)
      (* Boilerplate *)
      (* ----------- *)
      let v1 = map_qualified_info env v1 in
      nothing env v1

and map_qualified_info env
    {
      name_last = v_name_last;
      name_middle = v_name_middle;
      name_top = v_name_top;
      name_info = v_name_info;
    } =
  let v_name_info = map_id_info env v_name_info in
  let v_name_top = map_of_option (map_tok env) v_name_top in
  let v_name_middle = map_of_option (map_qualifier env) v_name_middle in
  let v_name_last =
    match v_name_last with
    | v1, v2 ->
        let v1 = map_ident env v1
        and v2 = map_of_option (map_type_arguments env) v2 in
        (v1, v2)
  in
  nothing env ()

and map_qualifier env = function
  | QDots v1 ->
      let v1 =
        map_of_list
          (fun (v1, v2) ->
            let v1 = map_ident env v1
            and v2 = map_of_option (map_type_arguments env) v2 in
            (v1, v2))
          v1
      in
      nothing env v1
  | QExpr (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_tok env v2 in
      nothing env (v1, v2)

and map_id_info env
    {
      id_resolved = _v_id_resolved;
      id_type = _v_id_type;
      id_svalue = _v_id_svalue;
      id_hidden = _v_id_hidden;
    } =
  (* do we want to recurse ?
     let v_id_svalue = map_of_ref (map_of_option (map_svalue env)) v_id_svalue in
     let v_id_type = map_of_ref (map_of_option (map_type_ env)) v_id_type in
     let v_id_resolved =
       map_of_ref (map_of_option (map_resolved_name env)) v_id_resolved
     in
  *)
  nothing env ()

(*****************************************************************************)
(* Expression *)
(*****************************************************************************)

(* this returns a type because we need one to resolve method/field access *)
and map_expr env { e = v_e; e_id = _v_e_id; e_range = _v_e_range } : T.t option
    =
  let t = map_expr_kind env v_e in
  t

and map_expr_kind env ekind : T.t option =
  match ekind with
  (* TODO: fix Python_to_generic that should generate a special Self *)
  | N (Id (("self", tk), _)) ->
      let* xs = env.class_qualifier in
      Some (T.N xs)
  | N v1 ->
      let _t = map_name env v1 in
      let* xs = H.dotted_ident_of_name_opt v1 in
      Some (T.N xs)
  | IdSpecial (spec, tk) -> (
      let _spec = map_special env spec in
      match spec with
      | Self ->
          let* xs = env.class_qualifier in
          Some (T.N xs)
      | _ -> todo_type)
  | DotAccess (v1, v2, v3) -> (
      let v1 = map_expr env v1
      and _v2 = map_tok env v2
      and _v3 = map_field_name env v3 in

      let* t = v1 in
      (* this is similar to H.dotted_ident_of_exprkind_opt but more general*)
      match (t, v3) with
      (* TODO? we could potentially set idinfo.resolved here *)
      | T.N xs, FN (Id (id, _idinfo)) ->
          let final = xs @ [ id ] in
          (if env.phase = Uses then
           let n2opt = L.lookup_dotted_ident_opt env final in
           n2opt |> Option.iter (fun n2 -> H.add_use_edge env n2));
          Some (T.N final)
      | _ -> None)
  | Call (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_arguments env v2 in
      todo_type
  | Alias (_, _) -> todo_type
  | L v1 ->
      let _v1 = map_literal env v1 in
      todo_type
  | Container (v1, v2) ->
      let _v1 = map_container_operator env v1
      and _v2 = map_bracket env (map_of_list (map_expr env)) v2 in
      todo_type
  | Comprehension (v1, v2) ->
      let _v1 = map_container_operator env v1
      and _v2 = map_bracket env (map_comprehension env) v2 in
      todo_type
  | Record v1 ->
      let _v1 = map_bracket env (map_of_list (map_field env)) v1 in
      todo_type
  | Constructor (v1, v2) ->
      let _v1 = map_name env v1
      and _v2 = map_bracket env (map_of_list (map_expr env)) v2 in
      todo_type
  | Xml v1 ->
      let v1 = map_xml env v1 in
      todo_type
  | Assign (v1, v2, v3) ->
      let v1 = map_expr env v1
      and v2 = map_tok env v2
      and v3 = map_expr env v3 in
      todo_type
  | AssignOp (v1, v2, v3) ->
      let v1 = map_expr env v1
      and v2 = map_wrap env (map_operator env) v2
      and v3 = map_expr env v3 in
      todo_type
  | LetPattern (v1, v2) ->
      let v1 = map_pattern env v1 and v2 = map_expr env v2 in
      todo_type
  | ArrayAccess (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_bracket env (map_expr env) v2 in
      todo_type
  | SliceAccess (v1, v2) ->
      let v1 = map_expr env v1
      and v2 =
        map_bracket env
          (fun (v1, v2, v3) ->
            let v1 = map_of_option (map_expr env) v1
            and v2 = map_of_option (map_expr env) v2
            and v3 = map_of_option (map_expr env) v3 in
            (v1, v2, v3))
          v2
      in
      todo_type
  | Lambda v1 ->
      let v1 = map_function_definition env v1 in
      todo_type
  | AnonClass v1 ->
      let v1 = map_class_definition env v1 in
      todo_type
  | Conditional (v1, v2, v3) ->
      let v1 = map_expr env v1
      and v2 = map_expr env v2
      and v3 = map_expr env v3 in
      todo_type
  | Yield (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_expr env) v2
      and v3 = map_of_bool v3 in
      todo_type
  | Await (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_expr env v2 in
      todo_type
  | Cast (v1, v2, v3) ->
      let v1 = map_type_ env v1
      and v2 = map_tok env v2
      and v3 = map_expr env v3 in
      todo_type
  | Seq v1 ->
      let v1 = map_of_list (map_expr env) v1 in
      todo_type
  | Ref (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_expr env v2 in
      todo_type
  | DeRef (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_expr env v2 in
      todo_type
  | ParenExpr v1 ->
      let v1 = map_bracket env (map_expr env) v1 in
      todo_type
  (* Ellipsis are valid constructs in certain language so we can't
   * raise SemgrepConstruct here *)
  | Ellipsis v1 ->
      let v1 = map_tok env v1 in
      todo_type
  (* those constructs should not appear in target code *)
  | DeepEllipsis v1 ->
      let v1 = map_bracket env (map_expr env) v1 in
      todo_type
  | DisjExpr (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_expr env v2 in
      todo_type
  | TypedMetavar (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_tok env v2
      and v3 = map_type_ env v3 in
      todo_type
  | DotAccessEllipsis (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_tok env v2 in
      todo_type
  | StmtExpr v1 ->
      let v1 = map_stmt env v1 in
      todo_type
  | OtherExpr (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      todo_type

and map_literal env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | Bool v1 ->
      let v1 = map_wrap env map_of_bool v1 in
      nothing env v1
  | Int v1 ->
      let v1 = map_wrap env (map_of_option map_of_int) v1 in
      nothing env v1
  | Float v1 ->
      let v1 = map_wrap env (map_of_option map_of_float) v1 in
      nothing env v1
  | Char v1 ->
      let v1 = map_wrap env map_of_string v1 in
      nothing env v1
  | String v1 ->
      let v1 = map_wrap env map_of_string v1 in
      nothing env v1
  | Regexp (v1, v2) ->
      let v1 = map_bracket env (map_wrap env map_of_string) v1
      and v2 = map_of_option (map_wrap env map_of_string) v2 in
      nothing env (v1, v2)
  | Atom (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_wrap env map_of_string v2 in
      nothing env (v1, v2)
  | Unit v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | Null v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | Undefined v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | Imag v1 ->
      let v1 = map_wrap env map_of_string v1 in
      nothing env v1
  | Ratio v1 ->
      let v1 = map_wrap env map_of_string v1 in
      nothing env v1

and map_container_operator _env _ = ()

and map_comprehension env (v1, v2) =
  let v1 = map_expr env v1 and v2 = map_of_list (map_for_or_if_comp env) v2 in
  (v1, v2)

and map_for_or_if_comp env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | CompFor (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_pattern env v2
      and v3 = map_tok env v3
      and v4 = map_expr env v4 in
      nothing env (v1, v2, v3, v4)
  | CompIf (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_expr env v2 in
      nothing env (v1, v2)

and map_field_name env = function
  | FN v1 ->
      (* !!do not call map_name here!! any uses should be handled
       * in the caller in DotAccess
       *)
      (* old: let v1 = map_name env v1 in *)
      nothing env v1
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | FDynamic v1 ->
      let v1 = map_expr env v1 in
      nothing env v1

and map_special env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | This -> ()
  | Super -> ()
  | Self -> ()
  | Parent -> ()
  | NextArrayIndex -> ()
  | Eval -> ()
  | Typeof -> ()
  | Instanceof -> ()
  | Sizeof -> ()
  | Defined -> ()
  | New -> ()
  | ConcatString v1 ->
      let v1 = map_concat_string_kind env v1 in
      nothing env v1
  | EncodedString v1 ->
      let v1 = map_of_string v1 in
      nothing env v1
  | InterpolatedElement -> ()
  | Spread -> ()
  | HashSplat -> ()
  | ForOf -> ()
  | Op v1 ->
      let v1 = map_operator env v1 in
      nothing env v1
  | IncrDecr v1 ->
      let v1 =
        match v1 with
        | v1, v2 ->
            let v1 = map_incr_decr env v1 and v2 = map_prefix_postfix env v2 in
            (v1, v2)
      in
      nothing env v1

and map_operator env _ = ()

and map_incr_decr env _ = ()

and map_prefix_postfix env _ = ()

and map_concat_string_kind env _ = ()

and map_xml env
    { xml_kind = v_xml_kind; xml_attrs = v_xml_attrs; xml_body = v_xml_body } =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v_xml_body = map_of_list (map_xml_body env) v_xml_body in
  let v_xml_attrs = map_of_list (map_xml_attribute env) v_xml_attrs in
  let v_xml_kind = map_xml_kind env v_xml_kind in
  nothing env ()

and map_xml_kind env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | XmlClassic (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_ident env v2
      and v3 = map_tok env v3
      and v4 = map_tok env v4 in
      nothing env (v1, v2, v3, v4)
  | XmlSingleton (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_ident env v2
      and v3 = map_tok env v3 in
      nothing env (v1, v2, v3)
  | XmlFragment (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_tok env v2 in
      nothing env (v1, v2)

and map_xml_attribute env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | XmlAttr (v1, v2, v3) ->
      let v1 = map_ident env v1
      and v2 = map_tok env v2
      and v3 = map_a_xml_attr_value env v3 in
      nothing env (v1, v2, v3)
  | XmlAttrExpr v1 ->
      let v1 = map_bracket env (map_expr env) v1 in
      nothing env v1
  | XmlEllipsis v1 ->
      let v1 = map_tok env v1 in
      nothing env v1

and map_a_xml_attr_value env v = map_expr env v

and map_xml_body env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | XmlText v1 ->
      let v1 = map_wrap env map_of_string v1 in
      nothing env v1
  | XmlExpr v1 ->
      let v1 = map_bracket env (map_of_option (map_expr env)) v1 in
      nothing env v1
  | XmlXml v1 ->
      let v1 = map_xml env v1 in
      nothing env v1

and map_arguments env v = map_bracket env (map_of_list (map_argument env)) v

and map_argument env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | Arg v1 ->
      let v1 = map_expr env v1 in
      nothing env v1
  | ArgKwd (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_expr env v2 in
      nothing env (v1, v2)
  | ArgKwdOptional (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_expr env v2 in
      nothing env (v1, v2)
  | ArgType v1 ->
      let v1 = map_type_ env v1 in
      nothing env v1
  | OtherArg (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

(*****************************************************************************)
(* Statement *)
(*****************************************************************************)

(* mostly boilerplate, control constructs don't introduce entities *)
and map_stmt env
    {
      s = v_s;
      s_id = _v_s_id;
      s_use_cache = _v_s_use_cache;
      s_backrefs = _v_s_backrefs;
      s_strings = _v_s_strings;
      s_range = _v_s_range;
    } =
  let v_s = map_stmt_kind env v_s in
  nothing env ()

and map_stmt_kind env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | ExprStmt (v1, v2) ->
      let v1 = map_expr env v1 and v2 = map_sc env v2 in
      nothing env (v1, v2)
  | Block v1 ->
      let v1 = map_bracket env (map_of_list (map_stmt env)) v1 in
      nothing env v1
  | If (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_condition env v2
      and v3 = map_stmt env v3
      and v4 = map_of_option (map_stmt env) v4 in
      nothing env (v1, v2, v3, v4)
  | While (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_condition env v2
      and v3 = map_stmt env v3 in
      nothing env (v1, v2, v3)
  | Return (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_expr env) v2
      and v3 = map_sc env v3 in
      nothing env (v1, v2, v3)
  | DoWhile (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_stmt env v2
      and v3 = map_expr env v3 in
      nothing env (v1, v2, v3)
  | For (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_for_header env v2
      and v3 = map_stmt env v3 in
      nothing env (v1, v2, v3)
  | Switch (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_of_option (map_condition env) v2
      and v3 = map_of_list (map_case_and_body env) v3 in
      nothing env (v1, v2, v3)
  | Match (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_expr env v2
      and v3 = map_of_list (map_action env) v3 in
      nothing env (v1, v2, v3)
  | Continue (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_label_ident env v2
      and v3 = map_sc env v3 in
      nothing env (v1, v2, v3)
  | Break (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_label_ident env v2
      and v3 = map_sc env v3 in
      nothing env (v1, v2, v3)
  (* could have an entity and dependency ... but it's intra procedural
   * so not that useful
   *)
  | Label (v1, v2) ->
      let v1 = map_label env v1 and v2 = map_stmt env v2 in
      nothing env (v1, v2)
  | Goto (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_label env v2
      and v3 = map_sc env v3 in
      nothing env (v1, v2, v3)
  | Throw (v1, v2, v3) ->
      let v1 = map_tok env v1 and v2 = map_expr env v2 and v3 = map_sc env v3 in
      nothing env (v1, v2, v3)
  | Try (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_stmt env v2
      and v3 = map_of_list (map_catch env) v3
      and v4 = map_of_option (map_finally env) v4 in
      nothing env (v1, v2, v3, v4)
  | WithUsingResource (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_stmt env v2
      and v3 = map_stmt env v3 in
      nothing env (v1, v2, v3)
  | Assert (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_arguments env v2
      and v3 = map_sc env v3 in
      nothing env (v1, v2, v3)
  (* TODO The modification of env.params_locals is done in decls() *)
  | DefStmt v1 ->
      let v1 = map_definition env v1 in
      nothing env v1
  | DirectiveStmt v1 ->
      let v1 = map_directive env v1 in
      nothing env v1
  | DisjStmt (v1, v2) ->
      let v1 = map_stmt env v1 and v2 = map_stmt env v2 in
      nothing env (v1, v2)
  | OtherStmtWithStmt (v1, v2, v3) ->
      let v1 = map_other_stmt_with_stmt_operator env v1
      and v2 = map_of_list (map_any env) v2
      and v3 = map_stmt env v3 in
      nothing env (v1, v2, v3)
  | OtherStmt (v1, v2) ->
      let v1 = map_other_stmt_operator env v1
      and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_condition env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | Cond v1 ->
      let v1 = map_expr env v1 in
      nothing env v1
  | OtherCond (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_case_and_body env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | CasesAndBody v1 ->
      let v1 =
        match v1 with
        | v1, v2 ->
            let v1 = map_of_list (map_case env) v1 and v2 = map_stmt env v2 in
            (v1, v2)
      in
      nothing env v1
  | CaseEllipsis v1 ->
      let v1 = map_tok env v1 in
      nothing env v1

and map_case env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | Case (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_pattern env v2 in
      nothing env (v1, v2)
  | Default v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | CaseEqualExpr (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_expr env v2 in
      nothing env (v1, v2)
  | OtherCase (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_action env (v1, v2) =
  let v1 = map_pattern env v1 and v2 = map_expr env v2 in
  (v1, v2)

and map_catch env (v1, v2, v3) =
  let v1 = map_tok env v1
  and v2 = map_catch_exn env v2
  and v3 = map_stmt env v3 in
  (v1, v2, v3)

and map_catch_exn env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | CatchPattern v1 ->
      let v1 = map_pattern env v1 in
      nothing env v1
  | CatchParam v1 ->
      let v1 = map_parameter_classic env v1 in
      nothing env v1
  | OtherCatch (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_finally env (v1, v2) =
  let v1 = map_tok env v1 and v2 = map_stmt env v2 in
  (v1, v2)

and map_label env v = map_ident env v

and map_label_ident env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | LNone -> ()
  | LId v1 ->
      let v1 = map_label env v1 in
      nothing env v1
  | LInt v1 ->
      let v1 = map_wrap env map_of_int v1 in
      nothing env v1
  | LDynamic v1 ->
      let v1 = map_expr env v1 in
      nothing env v1

and map_for_header env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | ForClassic (v1, v2, v3) ->
      let v1 = map_of_list (map_for_var_or_expr env) v1
      and v2 = map_of_option (map_expr env) v2
      and v3 = map_of_option (map_expr env) v3 in
      nothing env (v1, v2, v3)
  | ForEach (v1, v2, v3) ->
      let v1 = map_pattern env v1
      and v2 = map_tok env v2
      and v3 = map_expr env v3 in
      nothing env (v1, v2, v3)
  | ForIn (v1, v2) ->
      let v1 = map_of_list (map_for_var_or_expr env) v1
      and v2 = map_of_list (map_expr env) v2 in
      nothing env (v1, v2)
  | ForEllipsis v1 ->
      let v1 = map_tok env v1 in
      nothing env v1

and map_for_var_or_expr env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | ForInitVar (v1, v2) ->
      let v1 = map_entity env v1 and v2 = map_variable_definition env v2 in
      nothing env (v1, v2)
  | ForInitExpr v1 ->
      let v1 = map_expr env v1 in
      nothing env v1

and map_other_stmt_with_stmt_operator env _ = ()

and map_other_stmt_operator env _ = ()

(*****************************************************************************)
(* Pattern *)
(*****************************************************************************)
and map_pattern env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | PatLiteral v1 ->
      let v1 = map_literal env v1 in
      nothing env v1
  | PatConstructor (v1, v2) ->
      let v1 = map_name env v1 and v2 = map_of_list (map_pattern env) v2 in
      nothing env (v1, v2)
  | PatRecord v1 ->
      let v1 =
        map_bracket env
          (map_of_list (fun (v1, v2) ->
               let v1 = map_dotted_ident env v1 and v2 = map_pattern env v2 in
               (v1, v2)))
          v1
      in
      nothing env v1
  | PatId (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_id_info env v2 in
      nothing env (v1, v2)
  | PatTuple v1 ->
      let v1 = map_bracket env (map_of_list (map_pattern env)) v1 in
      nothing env v1
  | PatList v1 ->
      let v1 = map_bracket env (map_of_list (map_pattern env)) v1 in
      nothing env v1
  | PatKeyVal (v1, v2) ->
      let v1 = map_pattern env v1 and v2 = map_pattern env v2 in
      nothing env (v1, v2)
  | PatUnderscore v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | PatDisj (v1, v2) ->
      let v1 = map_pattern env v1 and v2 = map_pattern env v2 in
      nothing env (v1, v2)
  | PatTyped (v1, v2) ->
      let v1 = map_pattern env v1 and v2 = map_type_ env v2 in
      nothing env (v1, v2)
  | PatWhen (v1, v2) ->
      let v1 = map_pattern env v1 and v2 = map_expr env v2 in
      nothing env (v1, v2)
  | PatAs (v1, v2) ->
      let v1 = map_pattern env v1
      and v2 =
        match v2 with
        | v1, v2 ->
            let v1 = map_ident env v1 and v2 = map_id_info env v2 in
            (v1, v2)
      in
      nothing env (v1, v2)
  | PatType v1 ->
      let v1 = map_type_ env v1 in
      nothing env v1
  | PatEllipsis v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | DisjPat (v1, v2) ->
      let v1 = map_pattern env v1 and v2 = map_pattern env v2 in
      nothing env (v1, v2)
  | OtherPat (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

(*****************************************************************************)
(* Type *)
(*****************************************************************************)
and map_type_ env { t = v_t; t_attrs = v_t_attrs } =
  let v_t_attrs = map_of_list (map_attribute env) v_t_attrs in
  let v_t = map_type_kind env v_t in
  nothing env ()

and map_type_kind env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | TyN v1 ->
      let v1 = map_name env v1 in
      nothing env v1
  | TyApply (v1, v2) ->
      let v1 = map_type_ env v1 and v2 = map_type_arguments env v2 in
      nothing env (v1, v2)
  | TyFun (v1, v2) ->
      let v1 = map_of_list (map_parameter env) v1 and v2 = map_type_ env v2 in
      nothing env (v1, v2)
  | TyArray (v1, v2) ->
      let v1 = map_bracket env (map_of_option (map_expr env)) v1
      and v2 = map_type_ env v2 in
      nothing env (v1, v2)
  | TyTuple v1 ->
      let v1 = map_bracket env (map_of_list (map_type_ env)) v1 in
      nothing env v1
  | TyVar v1 ->
      let v1 = map_ident env v1 in
      nothing env v1
  | TyAny v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | TyPointer (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      nothing env (v1, v2)
  | TyRef (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      nothing env (v1, v2)
  | TyQuestion (v1, v2) ->
      let v1 = map_type_ env v1 and v2 = map_tok env v2 in
      nothing env (v1, v2)
  | TyRest (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_type_ env v2 in
      nothing env (v1, v2)
  | TyAnd (v1, v2, v3) ->
      let v1 = map_type_ env v1
      and v2 = map_tok env v2
      and v3 = map_type_ env v3 in
      nothing env (v1, v2, v3)
  | TyOr (v1, v2, v3) ->
      let v1 = map_type_ env v1
      and v2 = map_tok env v2
      and v3 = map_type_ env v3 in
      nothing env (v1, v2, v3)
  | TyRecordAnon (v1, v2) ->
      let v1 = map_wrap env (map_class_kind env) v1
      and v2 = map_bracket env (map_of_list (map_field env)) v2 in
      nothing env (v1, v2)
  | TyEllipsis v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | TyExpr v1 ->
      let v1 = map_expr env v1 in
      nothing env v1
  | OtherType (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_type_arguments env v =
  map_bracket env (map_of_list (map_type_argument env)) v

and map_type_argument env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | TA v1 ->
      let v1 = map_type_ env v1 in
      nothing env v1
  | TAWildcard (v1, v2) ->
      let v1 = map_tok env v1
      and v2 =
        map_of_option
          (fun (v1, v2) ->
            let v1 = map_wrap env map_of_bool v1 and v2 = map_type_ env v2 in
            (v1, v2))
          v2
      in
      nothing env (v1, v2)
  | TAExpr v1 ->
      let v1 = map_expr env v1 in
      nothing env v1
  | OtherTypeArg (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

(*****************************************************************************)
(* Attribute *)
(*****************************************************************************)
and map_attribute env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | KeywordAttr v1 ->
      let v1 = map_wrap env (map_keyword_attribute env) v1 in
      nothing env v1
  | NamedAttr (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_name env v2
      and v3 = map_arguments env v3 in
      nothing env (v1, v2, v3)
  | OtherAttribute (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_keyword_attribute env _ = ()

(*****************************************************************************)
(* Definitions *)
(*****************************************************************************)
and map_definition env (ent, def) =
  let env =
    match H.ident_of_entity_opt env ent with
    | Some id -> (
        let dotted_ident = env.current_qualifier @ [ id ] in
        let str = H.str_of_dotted_ident dotted_ident in
        let kind = H.entity_kind_of_definition env (ent, def) in
        let node = (str, kind) in
        if env.phase = Defs then (
          if
            (* less: static? *)
            (* less: we just collapse all methods with same name together *)
            G.has_node node env.g
            (* todo? duplicate node warning? *)
          then ()
          else (
            env.g |> G.add_node node;
            env.g |> G.add_nodeinfo node (H.nodeinfo_of_id env id);
            env.g |> G.add_edge (env.current_parent, node) G.Has);
          env.hooks.on_def_node node (ent, def));

        let env =
          { env with current_parent = node; current_qualifier = dotted_ident }
        in
        match def with
        (* TODO: handle multiple inheritance? *)
        (* TODO: handle if parent local class? dotted_ident_of_name_opt
         * would fail in that situation no?
         *)
        | ClassDef classdef ->
            (match classdef with
            | { cextends = [ ({ t = TyN parent; _ }, None) ]; _ } ->
                H.dotted_ident_of_name_opt parent
                |> Option.iter (fun xs ->
                       if env.phase = Uses then
                         (* !!the uses!! *)
                         let n2opt = L.lookup_dotted_ident_opt env xs in
                         n2opt
                         |> Option.iter (fun n2 ->
                                env.hooks.on_extend_edge node n2 (ent, classdef)))
            | _ -> ());
            { env with class_qualifier = Some dotted_ident }
        | _ -> env)
    | None ->
        (* less: handle also the qualified ident case? *)
        env
  in
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v1 = map_entity env ent and v2 = map_definition_kind env def in
  (v1, v2)

and map_entity env { name = v_name; attrs = v_attrs; tparams = v_tparams } =
  let v_tparams = map_type_parameters env v_tparams in
  let v_attrs = map_of_list (map_attribute env) v_attrs in
  let v_name = map_entity_name env v_name in
  nothing env ()

(* NOT BOILERPLATE, do not call map_name here *)
and map_name_in_def env v = ()

and map_entity_name env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | EN v1 ->
      let v1 = map_name_in_def env v1 in
      nothing env v1
  | EDynamic v1 ->
      let v1 = map_expr env v1 in
      nothing env v1
  | EPattern v1 ->
      let v1 = map_pattern env v1 in
      nothing env v1
  | OtherEntity (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_definition_kind env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | FuncDef v1 ->
      let v1 = map_function_definition env v1 in
      nothing env v1
  | VarDef v1 ->
      let v1 = map_variable_definition env v1 in
      nothing env v1
  | FieldDefColon v1 ->
      let v1 = map_variable_definition env v1 in
      nothing env v1
  | ClassDef v1 ->
      let v1 = map_class_definition env v1 in
      nothing env v1
  | EnumEntryDef v1 ->
      let v1 = map_enum_entry_definition env v1 in
      nothing env v1
  | TypeDef v1 ->
      let v1 = map_type_definition env v1 in
      nothing env v1
  | ModuleDef v1 ->
      let v1 = map_module_definition env v1 in
      nothing env v1
  | MacroDef v1 ->
      let v1 = map_macro_definition env v1 in
      nothing env v1
  | Signature v1 ->
      let v1 = map_type_ env v1 in
      nothing env v1
  | UseOuterDecl v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | OtherDef (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_type_parameter env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | TP v1 ->
      let v1 = map_type_parameter_classic env v1 in
      nothing env v1
  | TParamEllipsis v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | OtherTypeParam (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_type_parameter_classic env
    {
      tp_id = v_tp_id;
      tp_attrs = v_tp_attrs;
      tp_bounds = v_tp_bounds;
      tp_default = v_tp_default;
      tp_variance = v_tp_variance;
    } =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v_tp_variance =
    map_of_option (map_wrap env (map_variance env)) v_tp_variance
  in
  let v_tp_default = map_of_option (map_type_ env) v_tp_default in
  let v_tp_bounds = map_of_list (map_type_ env) v_tp_bounds in
  let v_tp_attrs = map_of_list (map_attribute env) v_tp_attrs in
  let v_tp_id = map_ident env v_tp_id in
  nothing env ()

and map_type_parameters env v = map_of_list (map_type_parameter env) v

and map_variance env _ = ()

(* ------------------------------------------------------------------------- *)
(* Function (or method) definition *)
(* ------------------------------------------------------------------------- *)
and map_function_definition env
    {
      fkind = v_fkind;
      fparams = v_fparams;
      frettype = v_frettype;
      fbody = v_fbody;
    } =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v_fbody = map_function_body env v_fbody in
  let v_frettype = map_of_option (map_type_ env) v_frettype in
  let v_fparams = map_parameters env v_fparams in
  let v_fkind = map_wrap env (map_function_kind env) v_fkind in
  nothing env ()

and map_function_kind env _ = ()

and map_parameters env v = map_of_list (map_parameter env) v

and map_parameter env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | Param v1 ->
      let v1 = map_parameter_classic env v1 in
      nothing env v1
  | ParamPattern v1 ->
      let v1 = map_pattern env v1 in
      nothing env v1
  | ParamRest (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_parameter_classic env v2 in
      nothing env (v1, v2)
  | ParamHashSplat (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_parameter_classic env v2 in
      nothing env (v1, v2)
  | ParamEllipsis v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | OtherParam (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_parameter_classic env
    {
      pname = v_pname;
      ptype = v_ptype;
      pdefault = v_pdefault;
      pattrs = v_pattrs;
      pinfo = v_pinfo;
    } =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v_pinfo = map_id_info env v_pinfo in
  let v_pattrs = map_of_list (map_attribute env) v_pattrs in
  let v_pdefault = map_of_option (map_expr env) v_pdefault in
  let v_ptype = map_of_option (map_type_ env) v_ptype in
  let v_pname = map_of_option (map_ident env) v_pname in
  nothing env ()

and map_function_body env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | FBStmt v1 ->
      let v1 = map_stmt env v1 in
      nothing env v1
  | FBExpr v1 ->
      let v1 = map_expr env v1 in
      nothing env v1
  | FBDecl v1 ->
      let v1 = map_sc env v1 in
      nothing env v1
  | FBNothing -> ()

(* ------------------------------------------------------------------------- *)
(* Variable definition *)
(* ------------------------------------------------------------------------- *)
and map_variable_definition env { vinit = v_vinit; vtype = v_vtype } =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v_vtype = map_of_option (map_type_ env) v_vtype in
  let v_vinit = map_of_option (map_expr env) v_vinit in
  nothing env ()

(* ------------------------------------------------------------------------- *)
(* Type definition *)
(* ------------------------------------------------------------------------- *)
and map_type_definition env { tbody = v_tbody } =
  let v_tbody = map_type_definition_kind env v_tbody in
  nothing env ()

and map_type_definition_kind env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | OrType v1 ->
      let v1 = map_of_list (map_or_type_element env) v1 in
      nothing env v1
  | AndType v1 ->
      let v1 = map_bracket env (map_of_list (map_field env)) v1 in
      nothing env v1
  | AliasType v1 ->
      let v1 = map_type_ env v1 in
      nothing env v1
  | NewType v1 ->
      let v1 = map_type_ env v1 in
      nothing env v1
  | AbstractType v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | Exception (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_of_list (map_type_ env) v2 in
      nothing env (v1, v2)
  | OtherTypeKind (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_or_type_element env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | OrConstructor (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_of_list (map_type_ env) v2 in
      nothing env (v1, v2)
  | OrEnum (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_of_option (map_expr env) v2 in
      nothing env (v1, v2)
  | OrUnion (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_type_ env v2 in
      nothing env (v1, v2)

(* ------------------------------------------------------------------------- *)
(* Object/struct/record/class field definition *)
(* ------------------------------------------------------------------------- *)
and map_field env =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  function
  | F v1 ->
      let v1 = map_stmt env v1 in
      nothing env v1

(* ------------------------------------------------------------------------- *)
(* Class definition *)
(* ------------------------------------------------------------------------- *)
and map_class_definition env
    {
      ckind = v_ckind;
      cextends = v_cextends;
      cimplements = v_cimplements;
      cmixins = v_cmixins;
      cparams = v_cparams;
      cbody = v_cbody;
    } =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v_cbody = map_bracket env (map_of_list (map_field env)) v_cbody in
  let v_cparams = map_parameters env v_cparams in
  let v_cmixins = map_of_list (map_type_ env) v_cmixins in
  let v_cimplements = map_of_list (map_type_ env) v_cimplements in
  let v_cextends = map_of_list (map_class_parent env) v_cextends in
  let v_ckind = map_wrap env (map_class_kind env) v_ckind in
  nothing env ()

and map_class_kind env _ = ()

and map_class_parent env (v1, v2) =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v1 = map_type_ env v1 and v2 = map_of_option (map_arguments env) v2 in
  (v1, v2)

(* ------------------------------------------------------------------------- *)
(* Enum entry  *)
(* ------------------------------------------------------------------------- *)
and map_enum_entry_definition env { ee_args = v_ee_args; ee_body = v_ee_body } =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v_ee_body =
    map_of_option (map_bracket env (map_of_list (map_field env))) v_ee_body
  in
  let v_ee_args = map_of_option (map_arguments env) v_ee_args in
  nothing env ()

(* ------------------------------------------------------------------------- *)
(* Module definition  *)
(* ------------------------------------------------------------------------- *)
and map_module_definition env { mbody = v_mbody } =
  let v_mbody = map_module_definition_kind env v_mbody in
  nothing env ()

and map_module_definition_kind env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | ModuleAlias v1 ->
      let v1 = map_dotted_ident env v1 in
      nothing env v1
  | ModuleStruct (v1, v2) ->
      let v1 = map_of_option (map_dotted_ident env) v1
      and v2 = map_of_list (map_item env) v2 in
      nothing env (v1, v2)
  | OtherModule (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

(* ------------------------------------------------------------------------- *)
(* Macro definition *)
(* ------------------------------------------------------------------------- *)
and map_macro_definition env
    { macroparams = v_macroparams; macrobody = v_macrobody } =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v_macrobody = map_of_list (map_any env) v_macrobody in
  let v_macroparams = map_of_list (map_ident env) v_macroparams in
  nothing env ()

(*****************************************************************************)
(* Directives (Module import/export, package) *)
(*****************************************************************************)
and map_directive env { d = v_d; d_attrs = v_d_attrs } =
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  let v_d_attrs = map_of_list (map_attribute env) v_d_attrs in
  let v_d = map_directive_kind env v_d in
  nothing env ()

and map_directive_kind env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | ImportFrom (v1, v2, v3, v4) ->
      let v1 = map_tok env v1
      and v2 = map_module_name env v2
      and v3 = map_ident env v3
      and v4 = map_of_option (map_alias env) v4 in
      nothing env (v1, v2, v3, v4)
  | ImportAs (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_module_name env v2
      and v3 = map_of_option (map_alias env) v3 in
      nothing env (v1, v2, v3)
  | ImportAll (v1, v2, v3) ->
      let v1 = map_tok env v1
      and v2 = map_module_name env v2
      and v3 = map_tok env v3 in
      nothing env (v1, v2, v3)
  | Package (v1, v2) ->
      let v1 = map_tok env v1 and v2 = map_dotted_ident env v2 in
      nothing env (v1, v2)
  | PackageEnd v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | Pragma (v1, v2) ->
      let v1 = map_ident env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)
  | OtherDirective (v1, v2) ->
      let v1 = map_todo_kind env v1 and v2 = map_of_list (map_any env) v2 in
      nothing env (v1, v2)

and map_alias env (v1, v2) =
  let v1 = map_ident env v1 and v2 = map_id_info env v2 in
  (v1, v2)

(*****************************************************************************)
(* Toplevel *)
(*****************************************************************************)
and map_item env v = map_stmt env v

and map_program env v = map_of_list (map_item env) v

(*****************************************************************************)
(* Partial/any *)
(*****************************************************************************)

(* Partials appear only in Semgrep patterns, not in target files *)
and map_partial env partial =
  raise (SemgrepConstruct (V.first_info_of_any (Partial partial)))

and map_any env = function
  (* ----------- *)
  (* Boilerplate *)
  (* ----------- *)
  | E v1 ->
      let v1 = map_expr env v1 in
      nothing env v1
  | S v1 ->
      let v1 = map_stmt env v1 in
      nothing env v1
  | Ss v1 ->
      let v1 = map_of_list (map_stmt env) v1 in
      nothing env v1
  | T v1 ->
      let v1 = map_type_ env v1 in
      nothing env v1
  | P v1 ->
      let v1 = map_pattern env v1 in
      nothing env v1
  | At v1 ->
      let v1 = map_attribute env v1 in
      nothing env v1
  | Fld v1 ->
      let v1 = map_field env v1 in
      nothing env v1
  | Flds v1 ->
      let v1 = map_of_list (map_field env) v1 in
      nothing env v1
  | Args v1 ->
      let v1 = map_of_list (map_argument env) v1 in
      nothing env v1
  | Params v1 ->
      let v1 = map_of_list (map_parameter env) v1 in
      nothing env v1
  | Partial v1 ->
      let v1 = map_partial env v1 in
      nothing env v1
  | I v1 ->
      let v1 = map_ident env v1 in
      nothing env v1
  | Str v1 ->
      let v1 = map_wrap env map_of_string v1 in
      nothing env v1
  | Def v1 ->
      let v1 = map_definition env v1 in
      nothing env v1
  | Dir v1 ->
      let v1 = map_directive env v1 in
      nothing env v1
  | Pr v1 ->
      let v1 = map_program env v1 in
      nothing env v1
  | Tk v1 ->
      let v1 = map_tok env v1 in
      nothing env v1
  | TodoK v1 ->
      let v1 = map_todo_kind env v1 in
      nothing env v1
  | Ar v1 ->
      let v1 = map_argument env v1 in
      nothing env v1
  | Pa v1 ->
      let v1 = map_parameter env v1 in
      nothing env v1
  | Tp v1 ->
      let v1 = map_type_parameter env v1 in
      nothing env v1
  | Ta v1 ->
      let v1 = map_type_argument env v1 in
      nothing env v1
  | Modn v1 ->
      let v1 = map_module_name env v1 in
      nothing env v1
  | Ce v1 ->
      let v1 = map_catch_exn env v1 in
      nothing env v1
  | Cs v1 ->
      let v1 = map_case env v1 in
      nothing env v1
  | ForOrIfComp v1 ->
      let v1 = map_for_or_if_comp env v1 in
      nothing env v1
  | ModDk v1 ->
      let v1 = map_module_definition_kind env v1 in
      nothing env v1
  | En v1 ->
      let v1 = map_entity env v1 in
      nothing env v1
  | Dk v1 ->
      let v1 = map_definition_kind env v1 in
      nothing env v1
  | Di v1 ->
      let v1 = map_dotted_ident env v1 in
      nothing env v1
  | Lbli v1 ->
      let v1 = map_label_ident env v1 in
      nothing env v1
  | Anys v1 ->
      let v1 = map_of_list (map_any env) v1 in
      nothing env v1
