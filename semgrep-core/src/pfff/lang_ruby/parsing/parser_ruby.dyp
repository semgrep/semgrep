%mltop { [@@@ warning "-27-32"] }
{
(* Mike Furr
 *
 * Copyright (C) 2010 Mike Furr
 * Copyright (C) 2020 r2c
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *)

open Ast_ruby
module H = Ast_ruby_helpers
(* for state *)
module S = Parser_ruby_helpers
(* for merging *)
module M = Parser_ruby_helpers
(* for fake_xxx *)
module PI = Parse_info

let fb = Parse_info.unsafe_fake_bracket

(*************************************************************************)
(*1 Dypgen merge directives *)
(*************************************************************************)

(*let () = Dyp.dypgen_verbose := max_int*)

let dyp_merge_Obj_stmt                   = M.merge_stmt (*merge_expr "stmt"*)

let dyp_merge_Obj_command                = M.merge_expr "command"
let dyp_merge_Obj_command_name           = M.merge_expr "command_name"
let dyp_merge_Obj_expr                   = M.merge_expr "expr"
let dyp_merge_Obj_primary                = M.merge_expr "primary"
let dyp_merge_Obj_argument               = M.merge_argument "argument"
let dyp_merge_Obj_array                  = M.merge_expr "array"
let dyp_merge_Obj_hash                   = M.merge_expr "hash"
let dyp_merge_Obj_hash_elem              = M.merge_expr "hash_elem"
let dyp_merge_Obj_func                   = M.merge_expr "func"
let dyp_merge_Obj_method_name            = M.merge_method_name "method_name"
let dyp_merge_Obj_method_kind            = M.merge_method_kind "method_kind"

let dyp_merge_Obj_stmt_list              = M.merge_expr_list "stmt_list"
let dyp_merge_Obj_call_args              = M.merge_argument_list "call_args"
let dyp_merge_Obj_array_body             = M.merge_expr_list "array_body"
let dyp_merge_Obj_mlhs_clean             = M.merge_expr_list "mlhs_clean"
let dyp_merge_Obj_mrhs                   = M.merge_expr_list "mrhs"

let dyp_merge_Obj_formal_arg_list   = M.merge_formal_list "formal_arg_list"
let dyp_merge_Obj_method_formals    = M.merge_formal_list "method_formals"
let dyp_merge_Obj_formal_arg_nonempty_list= M.merge_formal_list "formal_arg_nonempty_list"

let dyp_merge_Obj_binop                  = M.merge_binop
let dyp_merge_Obj_arg                    = M.merge_binop (*arg "arg"*)

let dyp_merge_Obj_rescue_clause          = M.merge_rescue "rescue_clause"

let dyp_merge_Obj_topcall                = M.merge_topcall

let dyp_merge_Obj_arg_comma_list_trail   = M.merge_rest "arg_comma_list_trail"
let dyp_merge_Obj_arg_comma_nonempty_list= M.merge_rest "arg_comma_nonempty_list"
let dyp_merge_Obj_arg_comma_star_list    = M.merge_rest "arg_comma_star_list"
let dyp_merge_Obj_star_amper             = M.merge_rest "star_amper"
let dyp_merge_Obj_array_item             = M.merge_rest "array_item"
let dyp_merge_Obj_array_body_rest        = M.merge_rest "array_body_rest"
let dyp_merge_Obj_var_or_scoped_id       = M.merge_rest "var_or_scoped_id"
let dyp_merge_Obj_cst_or_scoped_id       = M.merge_rest "cst_or_scoped_id"
let dyp_merge_Obj_class_inheritance      = M.merge_rest "class_inheritance"
let dyp_merge_Obj_do_sep                 = M.merge_rest "do_sep"
let dyp_merge_Obj_code_block             = M.merge_rest "code_block"
let dyp_merge_Obj_code_block_body        = M.merge_rest "code_block_body"
let dyp_merge_Obj_formal_arg             = M.merge_rest "formal_arg"
let dyp_merge_Obj_lhs                    = M.merge_rest "lhs"
let dyp_merge_Obj_mlhs                   = M.merge_rest "mlhs"
let dyp_merge_Obj_mlhs_rest              = M.merge_rest "mlhs_rest"
let dyp_merge_Obj_mlhs_item              = M.merge_rest "mlhs_item"
let dyp_merge_Obj_command_codeblock      = M.merge_rest "command_codeblock"
let dyp_merge_Obj_then_sep               = M.merge_rest "then_sep"
let dyp_merge_Obj_when_clauses           = M.merge_rest "when_clauses"
let dyp_merge_Obj_body_exn               = M.merge_rest "body_exn"
let dyp_merge_Obj_rescue_list            = M.merge_rest "rescue_list"
let dyp_merge_Obj_case_else           = M.merge_tok_stmts_opt "case_else"
let dyp_merge_Obj_ensure_clause       = M.merge_tok_stmts_opt "ensure_clause"
let dyp_merge_Obj_if_else_clauses        = M.merge_rest "if_else_clauses"
let dyp_merge_Obj_meth_or_atom           = M.merge_rest "meth_or_atom"
let dyp_merge_Obj_message_identifier     = M.merge_rest "message_identifier"
let dyp_merge_Obj_message_identifier2     = M.merge_rest "message_identifier2"
let dyp_merge_Obj_bin_op                 = M.merge_rest "bin_op"
let dyp_merge_Obj_unary_op               = M.merge_rest "unary_op"
let dyp_merge_Obj_keyword_as_id          = M.merge_rest "keyword_as_id"
let dyp_merge_Obj_variable               = M.merge_rest "variable"
let dyp_merge_Obj_constant               = M.merge_rest "constant"
let dyp_merge_Obj_eols                   = M.merge_rest "eols"
let dyp_merge_Obj_some_eols              = M.merge_rest "some_eols "
let dyp_merge_Obj_main                   = M.merge_rest "main"

let dyp_merge xs =
  M.wrap xs (fun xs ->
  Printf.eprintf "<all> branches: %d\n%!" (List.length xs);
  xs
  )
  (*Dyp.keep_all*)

(* TODO: do like in tree-sitter token.immediate, check that t2
 * follow just after t1, charpos t2 = charpos t1 + String.length t1
 * otherwise raise Dyp.Give_up
 *)
let token_immediate_check t1 t2 =
  ()

let fake s = Parse_info.unsafe_fake_info s

(*************************************************************************)
(*1 AST helpers *)
(*************************************************************************)

let tuple = function
  | [] -> raise Common.Impossible
  | [x] -> x
  | lst -> Tuple lst

let is_exnblock = function
  | S ExnBlock _ -> true
  | _ -> false

let rec param_to_pattern = function
  | Formal_id id -> Id (id, ID_Lowercase) (* TODO: actually not always that *)
  | Formal_amp (t, id) -> Unary((Op_UAmper, t), Id (id, ID_Lowercase))
  | Formal_star (t, id) -> Splat (t, (Some (Id (id, ID_Lowercase))))
  | Formal_rest t -> Splat (t, None)
  | Formal_tuple (_, xs, _) -> params_to_pattern xs
  | Formal_default (id, t, e) ->
      Binop(Id(id, ID_Lowercase), (Op_ASSIGN, t), e)
  | Formal_hash_splat (t, Some id) ->
      Unary((Op_UStarStar, t), Id (id, ID_Lowercase))
  | Formal_hash_splat (t, None) ->
      (* TODO, use a HashSplat expr instead of that *)
      Unary((Op_UStarStar, t), Id (("_", t), ID_Lowercase))
  | Formal_kwd (id, t, _) -> raise Common.Impossible
  | ParamEllipsis _ -> raise Common.Impossible

and params_to_pattern xs =
  let xs = List.map param_to_pattern xs in
  Tuple xs
}

/*(*************************************************************************)*/
/*(*1 Tokens *)*/
/*(*************************************************************************)*/

/*(*-----------------------------------------*)*/
/*(*2 The space/comment tokens *)*/
/*(*-----------------------------------------*)*/

%token <Parse_info.t> T_SPACE
%token <Parse_info.t> T_COMMENT
%token <Parse_info.t> T_EOF
%token <Parse_info.t> T_UNKNOWN

/*(* newline has a meaning in Ruby *)*/
%token <Parse_info.t> T_EOL

/*(*-----------------------------------------*)*/
/*(*2 The normal tokens *)*/
/*(*-----------------------------------------*)*/

%token <string * Parse_info.t> T_UID
%token <string * Parse_info.t> T_LID
%token <string * Parse_info.t> T_GLOBAL_VAR
%token <string * Parse_info.t> T_INST_VAR
%token <string * Parse_info.t> T_CLASS_VAR

%token <string * Parse_info.t>  T_NUM
%token <string * Parse_info.t>  T_FLOAT

%token <Parse_info.t * (string * Parse_info.t)> T_ATOM
%token <Parse_info.t> T_ATOM_BEG

%token <string * Parse_info.t> T_SINGLE_STRING
%token <Parse_info.t> T_DOUBLE_BEG
%token <string * Parse_info.t> T_INTERP_STR
%token <string * Parse_info.t> T_INTERP_END

%token <Parse_info.t> T_TICK_BEG
%token <string * Parse_info.t> T_USER_BEG

%token <Parse_info.t> T_REGEXP_BEG
%token <string * Parse_info.t>  T_REGEXP_MOD

/*(*-----------------------------------------*)*/
/*(*2 Keyword tokens *)*/
/*(*-----------------------------------------*)*/

/* keywords */
%token
 <Parse_info.t> K_CLASS <Parse_info.t> K_MODULE <Parse_info.t> K_DEF
 <Parse_info.t> K_BEGIN  <Parse_info.t> K_END
 <Parse_info.t> K_ALIAS <Parse_info.t> K_UNDEF
 <Parse_info.t> K_RESCUE <Parse_info.t> K_ENSURE
 <Parse_info.t> K_IF <Parse_info.t> K_UNLESS <Parse_info.t> K_THEN
 <Parse_info.t> K_ELSIF <Parse_info.t> K_ELSE
 <Parse_info.t> K_CASE <Parse_info.t> K_WHEN
 <Parse_info.t> K_WHILE <Parse_info.t> K_UNTIL <Parse_info.t> K_FOR
 <Parse_info.t> K_IN <Parse_info.t> K_DO
 <Parse_info.t> K_RETURN
 <Parse_info.t> K_AND <Parse_info.t> K_OR <Parse_info.t> K_NOT
 <Parse_info.t> K_lBEGIN <Parse_info.t> K_lEND
 <Parse_info.t> K_NIL
 <Parse_info.t> K_YIELD
 <Parse_info.t> K_SELF <Parse_info.t> K_SUPER
 <Parse_info.t> K_TRUE <Parse_info.t> K_FALSE
/* K_DEFINED K_SUPER K_BREAK K_REDO K_RETRY K_NEXT K___LIN_ K___FIL_ */

/*(*-----------------------------------------*)*/
/*(*2 Punctuation tokens *)*/
/*(*-----------------------------------------*)*/

/*(* syntax *)*/
%token <Parse_info.t> T_DOT          /* . */
%token <Parse_info.t> T_COMMA        /* , */

%token <Parse_info.t> T_ASSOC    /* => */
%token <Parse_info.t> T_LPAREN   /* _( */
%token <Parse_info.t> T_LPAREN_ARG   /* ( */
%token <Parse_info.t> T_RPAREN   /* ) */
%token <Parse_info.t> T_LBRACK_ARG   /* [ as in x[y] = 2 */
%token <Parse_info.t> T_LBRACK   /* [ as in x [y] aka x([y]) */
%token <Parse_info.t> T_RBRACK   /* ] */
%token <Parse_info.t> T_LBRACE   /* { for hash */
%token <Parse_info.t> T_LBRACE_ARG   /* { for code block */
%token <Parse_info.t> T_RBRACE   /* } */

%token <Parse_info.t> T_QUESTION     /* ? */
%token <Parse_info.t> T_COLON        /* : */

%token <Parse_info.t> T_SEMICOLON    /* ; */
%token <Parse_info.t> T_SCOPE        /* x::y */
%token <Parse_info.t> T_USCOPE       /* f ::y */

/*(* operators *)*/

%token <Parse_info.t> T_PLUS     /* + */
%token <Parse_info.t> T_UPLUS    /* unary + */
%token <Parse_info.t> T_MINUS    /* - */
%token <Parse_info.t> T_UMINUS   /* unary - */
%token <Parse_info.t> T_POW      /* ** */
%token <Parse_info.t> T_CMP      /* <=> */
%token <Parse_info.t> T_ASSIGN       /* = */
%token <Parse_info.t> T_EQ       /* == */
%token <Parse_info.t> T_EQQ      /* === */
%token <Parse_info.t> T_NEQ      /* != */
%token <Parse_info.t> T_GEQ      /* >= */
%token <Parse_info.t> T_LEQ      /* <= */
%token <Parse_info.t> T_LT       /* < */
%token <Parse_info.t> T_GT       /* > */
%token <Parse_info.t> T_ANDOP  <Parse_info.t> T_OROP    /* && and || */
%token <Parse_info.t> T_MATCH  <Parse_info.t> T_NMATCH  /* =~ and !~ */

%token <Parse_info.t> T_DOT2 <Parse_info.t> T_DOT3 /* .. and ... */
%token <Parse_info.t> LDots <Parse_info.t> RDots

%token <Parse_info.t> T_LSHFT <Parse_info.t> T_RSHFT    /* << and >> */

%token <string*Parse_info.t> T_OP_ASGN   /* +=, -=  etc. */

%token <Parse_info.t> T_STAR     /* * */
%token <Parse_info.t> T_USTAR    /* * */
%token <Parse_info.t> T_SLASH    /* / */
%token <Parse_info.t> T_PERCENT  /* % */

%token <Parse_info.t> T_RARROW   /* -> */
%token <Parse_info.t> T_CARROT       /* ^ */
%token <Parse_info.t> T_VBAR         /* | */
%token <Parse_info.t> T_BANG         /* ! */
%token <Parse_info.t> T_TILDE        /* ~ */
%token <Parse_info.t> T_AMPER    /* & */
%token <Parse_info.t> T_UAMPER   /* & */

/*(*-----------------------------------------*)*/
/*(*2 Extra tokens: *)*/
/*(*-----------------------------------------*)*/
/*(* see the T_Uxxx amd T_xxx_ARG above *)*/

/*(*************************************************************************)*/
/*(*1 Rules type declaration *)*/
/*(*************************************************************************)*/
%start <Ast_ruby.program> main
%start <Ast_ruby.any> sgrep_spatch_pattern


%%

/*(*************************************************************************)*/
/*(*1 Toplevel *)*/
/*(*************************************************************************)*/

main: eols stmt_list<xs> T_EOF { xs }

stmt_list:
  | /*empty*/ { [] }
  | stmt<s>   { [s] }

  /*(* recursive *)*/
  | /*empty*/ T_SEMICOLON   eols stmt_list<ss> @{ ss,     [Dyp.Dont_shift] }
  | stmt<s>   eol_or_semi   eols stmt_list<ss> @{ s::ss,  [Dyp.Dont_shift] }

eols:
  | /*empty*/  {}
  /*(* recursive *)*/
  | eols T_EOL {}

/*(* called T or TERM in original grammar *)*/
eol_or_semi:
 | T_SEMICOLON {}
 | T_EOL {}

/*(*************************************************************************)*/
/*(*1 Sgrep *)*/
/*(*************************************************************************)*/
sgrep_spatch_pattern: eols stmt_list T_EOF
   { match $2 with
     | [] -> Ss []
     | [S s] -> S2 s
     | [e] -> E e
     | xs -> Ss xs
   }

/*(*************************************************************************)*/
/*(*1 Statement (part 1) (and expression part 2) *)*/
/*(*************************************************************************)*/

stmt:
  | K_ALIAS<pos> meth_or_atom<e1> meth_or_atom<e2>
      { D (Alias(pos, e1,e2)) }
  | K_UNDEF<pos> meth_or_atom_list<e1>
      { D (Undef(pos, e1)) }

  | stmt<s> K_IF<pos>     eols stmt<g>
      { if M.is_cond_modifier g then raise Dyp.Giveup;
        S (If(pos, g, [s], None)) }
  | stmt<s> K_UNLESS<pos> eols stmt<g>
      { if M.is_cond_modifier g then raise Dyp.Giveup;
        S (Unless(pos, g, [s], None)) }
  | stmt<s> K_UNTIL<pos>  eols stmt<g>
      { if M.is_cond_modifier g then raise Dyp.Giveup;
        S (Until(pos, is_exnblock s, g, [s])) }
  | stmt<s> K_WHILE<pos>  eols stmt<g>
      { if M.is_cond_modifier g then raise Dyp.Giveup;
        S (While(pos, is_exnblock s,g, [s])) }
  | stmt<s> K_RESCUE<pos> eols stmt<g>
      { if M.is_cond_modifier g then raise Dyp.Giveup;
        S (ExnBlock({body_exprs = [s]; rescue_exprs = [($2, [],None,[g])];
            ensure_expr = None; else_expr = None})) }

  /* handle special case for x = y rescue z where rescue binds to
   * just the rhs, not the full assignment (unlike the other modifiers)
   */
  | lhs_assign_op<l,op,_tk> eols arg<r> K_RESCUE<pos> eols stmt<guard>
      { if M.is_cond_modifier guard then raise Dyp.Giveup;
        let r' = S (ExnBlock({body_exprs=[r];rescue_exprs =[($4,[],None,[guard])];
                 ensure_expr = None; else_expr = None}))
         in (*prune_binop l op r'*)
         Binop(l,(op,pos),r') (* TODO: wrong pos *)}
  | mlhs_assign_op<l,op,tk> eols mrhs<r>
      { (*prune_binop (tuple l) op (tuple r)*)
         let lhs = tuple l in
         Binop(lhs,(op,tk), (tuple r)) (* TODO: wrong pos?*)
      }

  | scope_BEGIN<pos> eols T_LBRACE eols stmt_list<xs> T_RBRACE
      { S.leave_scope dyp; D (BeginBlock(pos, ($3, xs, $6)))}
  | scope_END<pos>  eols T_LBRACE  eols stmt_list<xs> T_RBRACE
      { S.leave_scope dyp; D (EndBlock(pos, ($3, xs, $6)))}

  | topcall<c>
      { c }
  | expr<e>
      { e }

  | T_USTAR primary { Splat($1, Some $2) }

/* tokens that need to reduce immediately to guide the lexer */
scope_BEGIN:  K_BEGIN<pos>  {S.enter_scope dyp; pos}
scope_END:    K_END<pos>    {S.enter_scope dyp; pos}

/*(*************************************************************************)*/
/*(*1 Expressions (part 1) (and statement part 2) *)*/
/*(*************************************************************************)*/

expr:
  | K_RETURN<pos> call_args<xs>
      { M.well_formed_return xs;
        S (Return(pos, xs)) }
 /*(* call_args-->arg_comma_star_list-->arg_comma_nonempty_list->arg vs arg*)*/
  | K_RETURN<pos> arg<p>
      { match p with
        | S Block(_, [x], _) -> S (Return(pos, [Arg x]))
        | arg -> if M.is_cond_modifier arg then raise Dyp.Giveup;
                 S (Return(pos, [Arg arg]))
      }
  /*(* stmt-->topcall-->command-->K_YIELD vs stmt-->expr-->K_YIELD *)*/
  | K_YIELD<pos> call_args<xs>
      { M.well_formed_return xs;
        S (Yield(pos, xs)) }

  | expr<e1> K_AND eols expr<e2> { M.prune_left_assoc $2 e1 Op_kAND e2 }
  | expr<e1> K_OR eols expr<e2>  { M.prune_left_assoc $2 e1 Op_kOR e2 }
  | K_NOT<pos>  eols expr<e>     { M.prune_uop Op_UNot e pos}
  | T_BANG<pos> eols expr<e>     { M.prune_uop (U Op_UBang) e pos}

  /*(* stmt-->topcall-->command vs stmt-->expr-->command *)*/
  | command<c>              { c }

  | arg<a>                  { a }

/*(*************************************************************************)*/
/*(*1 Arg (or expression part 3) *)*/
/*(*************************************************************************)*/

arg:
  | lhs_pruned_assign_op<l,op,tk> eols arg<r>
      { M.prune_right_assoc tk l op r }

  | unary_op<o,pos>    eols arg<a> { M.prune_uop (U o) a pos }

  | arg<l> bin_op<bop,tk> eols arg<r> { M.prune_left_assoc tk l bop r }
  | arg<l> T_ANDOP     eols arg<r> { M.prune_left_assoc $2 l Op_AND r }
  | arg<l> T_OROP      eols arg<r> { M.prune_left_assoc $2 l Op_OR r }

  | arg<e1> T_QUESTION<pos> eols expr<e2> T_COLON eols expr<e3>
    { M.prune_tern e1 e2 e3 $2 $5 }

  | primary<p> {p}

/*(*************************************************************************)*/
/*(*1 Primary (or expression part 4) (and statement part 3) *)*/
/*(*************************************************************************)*/

primary:
  | T_LPAREN eols stmt_list T_RPAREN
      { (* don't collapse the block here to prevent the disambiguation
           rules from erroneously firing *)
         S (Block($1, $3, $4)) }

  | constant<c> { c }
  | variable<id> { Id id }
  | K_NIL             { Literal(Nil $1) }
  | K_TRUE            { Literal(Bool (true,$1)) }
  | K_FALSE           { Literal(Bool (false,$1)) }

  /*(* typing-ext: sgrep-ext: *)*/
  | T_DOT3              { Ellipsis $1 }
  | LDots primary RDots { Flag_parsing.sgrep_guard (DeepEllipsis ($1, $2, $3)) }

  /*(* stmt-->topcall-->command-->command_name (with empty call_args) vs
     * stmt-->expr-->arg-->primary-->command_name *)*/
  | command_name<c>                { M.methodcall c (fb []) None}
  | command_name<c> code_block<cb> { M.command_codeblock c cb }

  /*(* stmt-->topcall vs stmt-->expr-->arg-->primary *)*/
  | func<f>                { f }
  | func<f> code_block<cb>
      { match f with
        | Call(m,args,None) -> M.methodcall m args (Some cb)
        | _ -> M.methodcall f (fb []) (Some cb)
      }

  | primary<p> T_SCOPE variable<id>  { M.scope $2 p (SV id) }
  | T_USCOPE<pos> variable<id>       { ScopedId(TopScope(pos, id)) }

  | primary<p> T_LBRACK_ARG<t1> eols arg_comma_list_trail<xs> eols T_RBRACK<t2>
     { M.methodcall (DotAccess(p,(t1), MethodOperator(Op_AREF,t1))) (t1, xs, t2) None }

  | lambda { $1 }

  | array { $1 }
  | hash { $1 }

  | K_RETURN<pos> { S (Return(pos, [])) }
/*
 * | K_RETURN<pos>T_LPAREN eols call_args<args> eols T_RPAREN{Return(pos, args)}
 * | K_RETURN<pos> any_LPAREN eols expr<arg> eols T_RPAREN { S (Return(pos, [Arg arg]))}
 */
  | K_YIELD<pos> { S (Yield(pos, [])) }
  | K_YIELD<pos> any_LPAREN eols call_args<xs> eols T_RPAREN { S (Yield(pos, xs))}
  | K_YIELD<pos> any_LPAREN eols expr<e>       eols T_RPAREN { S (Yield(pos, [Arg e]))}

  | K_IF<pos> expr<g> then_sep stmt_list<xs> if_else_clauses<else_e> K_lEND
    { S (If(pos, g, xs, else_e)) }

  | K_UNLESS<pos> expr<g> then_sep stmt_list<xs> case_else<else_e> K_lEND
    { S (Unless(pos, g, xs, else_e)) }

  | K_WHILE<pos> expr<g> do_sep stmt_list<xs> K_lEND
    { M.well_formed_do g xs;
      S (While(pos, false, g, xs)) }

  | K_UNTIL<pos> expr<g> do_sep stmt_list<xs> K_lEND
    { M.well_formed_do g xs;
      S (Until(pos, false, g , xs)) }

  | K_CASE<pos> some_eols         when_clauses<xs> case_else<else_e> K_lEND
    { S (Case(pos, {case_guard=None; case_whens=xs; case_else = else_e})) }

  | K_CASE<pos> eols expr<e> eols when_clauses<xs> case_else<else_e> K_lEND
    { S (Case(pos, {case_guard = Some e; case_whens = xs; case_else = else_e})) }

  | K_CASE<pos> eols expr<e> T_SEMICOLON eols when_clauses<xs> case_else<else_e> K_lEND

    { S (Case(pos, {case_guard = Some e; case_whens = xs; case_else = else_e})) }

  /*(* TODO: mlhs in tree-sitter-ruby, not formal_arg_list *)*/
  | K_FOR<pos> formal_arg_list<vars> K_IN arg<a> do_sep stmt_list<xs> K_lEND
    { M.well_formed_do a xs;
      S (For(pos, params_to_pattern vars, $3, a, xs)) }

  | K_lBEGIN<pos> eols body_exn<body>  K_lEND { S (ExnBlock(body)) }

  /*(* defintions! *)*/
  | class_definition { $1 }

  | module_definition { $1 }

  | method_definition { $1 }


arg_comma_list_trail:
  | arg_comma_star_list<e> {e}
  | arg_comma_star_list<e> T_COMMA {e}


do_sep:
    | T_SEMICOLON eols {}
    | T_COLON eols     {}
    | some_eols        {}
    | eols K_DO eols   {}

then_sep:
    | T_SEMICOLON eols {}
    | T_COLON     eols {}
    | some_eols        {}
    | eols K_THEN eols {}

/*(*----------------------------*)*/
/*(*2 constants *)*/
/*(*----------------------------*)*/

constant:
  | T_NUM   { Literal (Num $1) }
  | T_FLOAT { Literal (Float $1) }

  | string<s>        { s }

  | T_ATOM
      { Atom (fst $1, AtomSimple (snd $1)) }
  | T_ATOM_BEG<pos> interp_str<istr>
      { Atom (pos, AtomFromString (pos, istr, fake"\"")) }

  | T_REGEXP_BEG<l> interp_str<istr> T_REGEXP_MOD<mods, posmod>
      { let r = l (* TODO *) in
        let rmod = if mods = "" then None else Some (mods, posmod) in
        Literal(Regexp ((l, istr, r), rmod)) }

  | T_TICK_BEG<pos> interp_str<xs> { Literal (String ((Tick (pos, xs, fake"`")))) }

/*(*----------------------------*)*/
/*(*2 strings *)*/
/*(*----------------------------*)*/
string:
  | one_string<s> {s} /* ("abc" 'def') is the string "abcdef" */
  /*(* recursive *)*/
  | string<s1> one_string<s2> { M.merge_string_lits s1 s2 }

one_string:
  | T_SINGLE_STRING
      { Literal(String ((Single $1))) }
  | T_DOUBLE_BEG<pos> interp_str<xs>
      { Literal(String ((Double (pos, xs, fake "\"")))) }

  | T_USER_BEG<m,pos> interp_str<str> { M.process_user_string m str pos }


interp_str:
  | T_SINGLE_STRING {[StrChars $1]}
  | interp_str_work<i>
      {match i with [] -> [StrChars ("", Parse_info.unsafe_fake_info "")] | lst -> lst}

interp_str_work:
  | T_INTERP_STR<s,pos> interp_code<tl>
      { if s = "" then tl else (StrChars (s,pos))::tl }

  | T_INTERP_END<s,pos2>
      { if s = "" then [] else [StrChars (s, pos2)] }

interp_code:
  | eols stmt_list<ss> interp_str_work<tl>
      {
        let mk_block lst =
          match lst with
          | [x] -> x
          | _ -> S (Block(PI.unsafe_fake_bracket lst))
        in
          match ss with
          | [] -> tl
          | x::_ -> StrExpr (fake "#{", mk_block ss, fake "}")::tl
      }

  | T_INTERP_END<s,pos>
      { if s = "" then [] else [StrChars (s, pos)] }

/*(*----------------------------*)*/
/*(*2 Exceptions *)*/
/*(*----------------------------*)*/

body_exn:
 | stmt_list<xs> rescue_list<resc_e> case_else<else_e> ensure_clause<ens_e>
     { { body_exprs = xs; rescue_exprs = resc_e;
        ensure_expr = ens_e; else_expr = else_e}
     }

rescue_clause:
  | K_RESCUE<resc_pos>                     then_sep stmt_list<xs>
      { ($1, [], None, xs) }
  | K_RESCUE<pos> T_ASSOC seen_id<bind>    then_sep stmt_list<xs>
      { ($1, [], Some ($2, bind), xs) }
  | K_RESCUE<pos> arg_comma_star_list<exn> then_sep stmt_list<xs>
    { ($1, exn |> args_to_exprs, None, xs) }
  | K_RESCUE<pos> arg_comma_star_list<exn>
    { ($1, exn |> args_to_exprs, None, []) }

seen_id: variable<i> { M.seen dyp (Id i); Id i}


rescue_list:
  | /* empty */ { [] }
  /* need to force an eol/semi here to disambiguate the rescue modifier */
  | eol_or_semi rescue_clause<r> rescue_list<rs> /*_rest*/
      { r::rs }

ensure_clause:
  | /* empty */ { None }
  | K_ENSURE eols stmt_list<xs> { Some ($1, xs) }

/*(*----------------------------*)*/
/*(*2 IfThenElse *)*/
/*(*----------------------------*)*/

if_else_clauses:
  | /* empty */ { None }
  | K_ELSE eols stmt_list<body>
    { Some ($1, body) }
  | K_ELSIF<pos> eols expr<g> then_sep stmt_list<xs> if_else_clauses<rest>
    { Some (pos, [S (If(pos, g, xs, rest)) ]) }

case_else:
  | /* empty */ { None }
  | K_ELSE eols stmt_list<xs> { Some ($1, xs) }

/*(*----------------------------*)*/
/*(*2 Case *)*/
/*(*----------------------------*)*/

when_clauses:
  | /* empty */ { [] }
  | K_WHEN arg_comma_star_list<e> then_sep stmt_list<es>
    when_clauses<rest>
    { ($1, e |> args_to_exprs, es) :: rest }

/*(*----------------------------*)*/
/*(*2 containers *)*/
/*(*----------------------------*)*/

array: T_LBRACK eols array_body<xs> eols T_RBRACK { Array($1, xs |> exprs_to_args, $5) }

array_body:
  | command<c> { [c] }
  | array_body_rest<es> { es }

array_body_rest:
  | /*(*empty*)*/    { [] }
  | array_item<e>    { [e] }
  | star_amper<es>   { es }

  /*(* recursive *)*/
  | array_item<e> T_COMMA eols array_body_rest<es> @{ e::es, [Dyp.Dont_shift] }

array_item:
  | arg<e> { e }
  | constant<c> T_LBRACK<t1> eols call_args<xs> eols T_RBRACK<t2>
      { M.methodcall (DotAccess(c, (t1), MethodOperator(Op_AREF,t1))) (* TODO: Wrong pos Binop, and probably all the following Binop in this file *)
                     (t1, xs, t2) None }


hash: T_LBRACE eols hash_elem_list eols T_RBRACE { Hash(true, ($1, $3, $5)) }

hash_elem_list:
  | /*(*empty*)*/ { [] }
  | hash_elem { [$1] }
  | hash_elem T_COMMA eols hash_elem_list @{ $1::$4, [Dyp.Dont_shift] }

hash_elem:
  | arg { $1 }
  | pair { let (a,b,c) = $1 in keyword_arg_to_expr a b c }

/*(* TODO: move arg bin_op OP_ASSOC here like in tree-sitter-ruby *)*/
pair:
  | identifier T_COLON arg
    { token_immediate_check (snd $1) $2;
      $1, $2, $3
     }
  /* HACK: 'unless' is a valid name for a keyword argument or a hash key!
   * Tree-sitter's Ruby parser doesn't even treat 'unless' as a keyword.
   * This is just a quick-fix until we use tree-sitter's parser also for
   * parsing Semgrep patterns. */
  | K_UNLESS T_COLON arg
    {
      token_immediate_check $1 $2;
      ("unless", $1), $2, $3
    }

/*(*************************************************************************)*/
/*(*1 Call *)*/
/*(*************************************************************************)*/

topcall:
  | func<f>
      { f }
  | func<f> code_block<cb>
      { match f with
        | Call(m,args,None) -> M.methodcall m args (Some cb)
        | _ -> M.methodcall f (fb []) (Some cb) }

  | command<c>
      { c }
  | command_name<m> call_args<xs> do_codeblock<cb>
      { M.well_formed_command m xs;
        M.methodcall m (fb xs) (Some cb)}

/*(*----------------------------*)*/
/*(*2 Command *)*/
/*(*----------------------------*)*/

command:
  | command_name<m> call_args<xs>
      { M.well_formed_command m xs;
        M.methodcall m (fb xs) None}
  | K_YIELD<pos>    call_args<xs>
      { M.well_formed_return xs;
        S (Yield(pos, xs)) }

  /*(* recursive *)*/
  | command_name<cmd> command<cmd2>
      { M.well_formed_command cmd [Arg cmd2];
        M.methodcall cmd (fb [Arg cmd2]) None}

command_name:
  | variable<id>
      { Id id }

  | primary<p> T_DOT eols message_identifier<m>
      { M.unfold_dot p (m) $2}
  | primary<p> T_SCOPE    message_identifier<m>
      { M.scope $2 p (sm m) }

  /*(* recursive *)*/
  | command_name<p> T_DOT eols message_identifier<m>
      { M.unfold_dot p (m) $2}
  | command_name<p> T_SCOPE    message_identifier<m>
      { M.scope $2 p (sm m) }

/*(*----------------------------*)*/
/*(*2 Func *)*/
/*(*----------------------------*)*/
func:
  | command_name<c> any_LPAREN eols call_args<xs> eols T_RPAREN
      { match xs with
        | [] -> Call(c, ($2, xs, $6), None)
        | _ -> M.methodcall c ($2, xs, $6) None
      }
  | command_name<c> any_LPAREN eols command<a> eols T_RPAREN
      { Call(c,($2, [Arg a], $6),None)}

any_LPAREN:
  | T_LPAREN<pos> {pos}
  | T_LPAREN_ARG<pos> {pos}

/*(*----------------------------*)*/
/*(*2 Arguments *)*/
/*(*----------------------------*)*/

call_args:
  | /*empty*/                 { [] }
  | arg_comma_star_list<xs>   { xs }
  | T_LBRACK eols call_args<xs> eols T_RBRACK { [Arg (Array($1, xs, $5))] }

arg_comma_star_list:
  /*(* call_args-->empty vs call_args-->arg_comma_star_list-->empty *)*/
  | /*empty*/     { [] }
  | star_amper<a> { a |> exprs_to_args }

  | arg_comma_nonempty_list<xs> { xs }
  | arg_comma_nonempty_list<xs> T_COMMA eols star_amper<a>
      @{ xs @ (a |> exprs_to_args), [Dyp.Dont_shift] }

arg_comma_nonempty_list:
  | argument { [$1] }
  /*(* recursive *)*/
  | argument T_COMMA eols arg_comma_nonempty_list @{ $1::$4, [Dyp.Dont_shift] }

star_amper:
  | T_USTAR arg
      { [Splat($1, Some $2)] }
  | T_UAMPER<pos> arg<a>
      { [Unary((Op_UAmper,pos),a)] }

  | T_USTAR<pos1> arg<a1> T_COMMA eols T_UAMPER<pos2> arg<a2>
      { [Splat(pos1, Some a1); Unary((Op_UAmper,pos2),a2)] }

argument:
 | arg { Arg $1 }
 | pair { let (a,b,c) = $1 in ArgKwd (a, b, c) }

/*(*************************************************************************)*/
/*(*1 LHS/RHS *)*/
/*(*************************************************************************)*/

assign_op:
  | T_ASSIGN          { Op_ASSIGN, $1 }
  | T_OP_ASGN<op,pos> { Op_OP_ASGN (H.binary_op_of_string op), pos }

/*(*----------------------------*)*/
/*(*2 LHS *)*/
/*(*----------------------------*)*/

lhs_assign_op: lhs<l> assign_op<op,tk>   { M.seen dyp l; l,op,tk}

lhs:
  | var_or_scoped_id<id>
      { id }
  | K_NIL             { Literal(Nil $1) }
  | K_TRUE            { Literal(Bool (true,$1)) }
  | K_FALSE           { Literal(Bool (false,$1)) }
  | primary<p> T_LBRACK_ARG<t1> eols arg_comma_star_list<xs> eols T_RBRACK<t2>
      { M.methodcall (DotAccess(p,(t1),MethodOperator(Op_AREF,t1))) (t1, xs, t2) None}
  | primary<p> T_DOT<t> eols message_identifier<m>
      { M.methodcall (DotAccess(p,(t), (m))) (fb []) None}

/*(*----------------------------*)*/
/*(*2 Multiple LHS *)*/
/*(*----------------------------*)*/

mlhs_assign_op: mlhs<l> assign_op<op,tk> {List.iter (M.seen dyp) l; l,op,tk}

mlhs:
  | mlhs_clean<ls> {ls}
  | mlhs_clean<ls> T_COMMA<pos> { ls @ [Splat(pos, None)] }

mlhs_clean:
  | T_LPAREN eols mlhs<l> eols T_RPAREN     { [(tuple l)] }
  | mlhs_item<l>                            { [l] }
  | mlhs_item<l> T_COMMA eols mlhs_rest<ls> { l::ls}
  | T_USTAR<pos> lhs<l>                     { [Splat(pos, Some l)] }

mlhs_item:
  | lhs<l>                               {l}
  | T_USTAR                              { Splat($1, None) }
  | T_LPAREN eols mlhs<ls> eols T_RPAREN { tuple ls }

mlhs_rest:
  | mlhs_item<l> { [l] }
  /*(* recursive *)*/
  | mlhs_item<l> T_COMMA eols mlhs_rest<ls> @{ l::ls, [Dyp.Dont_shift] }
  | T_USTAR lhs { [Splat($1, Some $2)] }

/*(*----------------------------*)*/
/*(*2 Pruned LHS *)*/
/*(*----------------------------*)*/

lhs_pruned_assign_op: lhs_prune_binop<l> assign_op<op,tk>
  { M.seen dyp l; l,op,tk}

lhs_prune_binop: lhs<l> {match l with Binop _ -> raise Dyp.Giveup | _ -> l}

/*(*----------------------------*)*/
/*(*2 Multiple RHS *)*/
/*(*----------------------------*)*/

mrhs:
  | arg_comma_star_list<xs> { match xs with [] -> raise Dyp.Giveup | _ -> xs |> args_to_exprs }
  | topcall<c> { [c] }
  | T_LBRACK eols call_args<xs> eols T_RBRACK { [Array($1, xs, $5)] }
  | T_USTAR<pos> arg<a>                       { [Splat(pos, Some a)] }
  | T_USTAR<pos> command_codeblock<c>         { [Splat(pos, Some c)] }
  | T_USTAR<pos1> T_LBRACK eols call_args<xs> eols T_RBRACK
      { [Splat(pos1,Some (Array($2, xs, $6)))] }

command_codeblock:
  | command<c>                     { c }
  | command_name<c> code_block<cb> { M.command_codeblock c cb }




/*(*************************************************************************)*/
/*(*1 Function definition *)*/
/*(*************************************************************************)*/

method_definition: scope_DEF<pos> method_kind<id> method_formals<xs> eols
  body_exn<body> K_lEND
      { S.leave_scope dyp;
        D (MethodDef (pos, id, xs, body)) }

/* tokens that need to reduce immediately to guide the lexer */
scope_DEF:    K_DEF<pos>    {S.enter_scope dyp; pos}

/*(*----------------------------*)*/
/*(*2 Code Block *)*/
/*(*----------------------------*)*/

code_block:
  | brace_codeblock<cb> {cb}
  | do_codeblock<cb> {cb}

brace_codeblock:
  | T_LBRACE_ARG<pos> eols code_block_body<b> T_RBRACE
      { let args, body = b in CodeBlock(($1,true,$4),args,body) }

code_block_body:
  /* for when the lexer sees "||" instead of two "|"'s */
  | T_OROP eols stmt_list<xs>                               { (Some [], xs) }
  | T_VBAR formal_arg_list<args> T_VBAR eols stmt_list<xs>  { (Some args, xs) }
  | stmt_list<xs>                                           { (None, xs) }

do_codeblock:
  | K_DO eols code_block_body<b> K_lEND
      { let args, body = b in CodeBlock(($1,false,$4),args,body) }

/*(*----------------------------*)*/
/*(*2 Lambda *)*/
/*(*----------------------------*)*/

lambda:
  | T_RARROW<pos> lambda_args<opt_args> eols lambda_body<body>
      { Lambda (pos, opt_args, body) }

lambda_args:
  | T_LPAREN eols formal_arg_list<args> T_RPAREN  { Some args }

lambda_body:
  | T_LBRACE_ARG eols stmt_list<body> T_RBRACE    { body }

/*(*----------------------------*)*/
/*(*2 parameters (not arguments, as the name (wrongly) says) *)*/
/*(*----------------------------*)*/

formal_arg:
  | identifier<id>         { M.seen dyp (Id (id, ID_Lowercase)); Formal_id(id)}
  | T_UAMPER T_LID<id,pos> { M.seen_str dyp id; Formal_amp ($1, $2) }
  | T_AMPER T_LID<id,pos>  { M.seen_str dyp id; Formal_amp ($1, $2) }
  | T_USTAR T_LID<id,pos>  { M.seen_str dyp id; Formal_star ($1, $2) }

  | T_USTAR                { Formal_rest $1 }
  | T_LID<id,pos> T_ASSIGN eols arg<e>
      { M.seen_str dyp id;
        Formal_default ($1, $2, e) }
  | any_LPAREN formal_arg_nonempty_list<f> T_RPAREN { Formal_tuple ($1, f, $3)}
  /*(* sgrep-ext: and regular ruby? *)*/
  | T_DOT3 { ParamEllipsis $1 }

formal_arg_nonempty_list:
  | formal_arg<f> { [f] }
  | formal_arg<f> T_COMMA { [f; Formal_rest $2 (* TODO *)] }
  /*(* recursive *)*/
  | formal_arg<f> T_COMMA eols formal_arg_nonempty_list<fs>
       @{ f::fs, [Dyp.Dont_shift] }

formal_arg_list:
  | /*(* empty *)*/              { [] }
  | formal_arg_nonempty_list<xs> { xs }

method_formals:
  | eol_or_semi { [] }
  | formal_arg_nonempty_list<xs> eol_or_semi
      { match xs with
        | (Formal_tuple _)::_ -> raise Dyp.Giveup
        | e -> e }
  | any_LPAREN eols formal_arg_list<xs> eols T_RPAREN
      { (* RPAREN usually puts the lexer in an end state, but we need to
         force it to an end state *)
         S.state_override := true;
         xs }

/*(*************************************************************************)*/
/*(*1 Class/Module definition *)*/
/*(*************************************************************************)*/

class_definition:
  | scope_CLASS<pos> eols cst_or_scoped_id<id> class_inheritance<inh> do_sep
      body_exn<body> K_lEND
      { S.leave_scope dyp;
        D (ClassDef(pos, C (id, inh), body))}

  | scope_CLASS<pos> T_LSHFT arg<id> eols body_exn<body> K_lEND
      { S.leave_scope dyp;
        D (ClassDef(pos, SingletonC ($2, id), body)) }

module_definition: scope_MODULE<pos> cst_or_scoped_id<id> eols body_exn<body> K_lEND
      { S.leave_scope dyp;
        D (ModuleDef (pos, id, body)) }

/* tokens that need to reduce immediately to guide the lexer */
scope_CLASS:  K_CLASS<pos>  {S.enter_scope dyp; pos}
scope_MODULE: K_MODULE<pos> {S.enter_scope dyp; pos}

class_inheritance:
 | /*(* empty *)*/ { None }
 | T_LT primary    { Some ($1, $2) }

/*(*************************************************************************)*/
/*(*1 Name *)*/
/*(*************************************************************************)*/

identifier:
  | T_LID { $1 }
  /*(* weird, but found code like that *)*/
  | T_INST_VAR   { $1 }
  | T_GLOBAL_VAR { $1 }

/*(* was called identifier (but I now follow tree-sitter-ruby conventions) *)*/
variable:
  | T_LID<id,pos>          { ((id,pos), ID_Lowercase)}
  | T_UID<id,pos>          { ((id,pos), ID_Uppercase)}

  | T_GLOBAL_VAR<id,pos>   { ((id,pos), ID_Global) }
  | T_INST_VAR<id,pos>     { ((id,pos), ID_Instance) }
  | T_CLASS_VAR<id,pos>    { ((id,pos), ID_Class) }

  | K_SELF            { (("self", $1), ID_Self) }
  | K_SUPER           { (("super", $1), ID_Super) }

variable2:
  | variable { $1 }
  | keyword_as_id { $1, ID_Lowercase }

/*(* for use *)*/
message_identifier:
  /*(* this part was in an intermediate 'assignable' rule before *)*/
  | variable2<e>             { MethodId e }
  | T_LBRACK_ARG<pos> T_RBRACK { MethodOperator(Op_AREF,pos) }
  | T_LBRACK<pos>     T_RBRACK { MethodOperator(Op_AREF,pos) }

  /*(* not 'assignable' part I guess *)*/
  | bin_op<op,tk> {
        (* TODO: use bin_msg instead *)
        match op with
        | B op -> MethodOperator(op,tk)
        (* sgrep-ext: *)
        | Op_DOT3 when !Flag_parsing.sgrep_mode -> MethodEllipsis (tk)
        | x -> failwith (Common.spf "not a binary msg: %s"
                          (Ast_ruby.show_binary_op x))
     }
  | T_LBRACK_ARG<pos> T_RBRACK T_ASSIGN { MethodOperator(Op_ASET,pos) }
  | T_LBRACK<pos>     T_RBRACK T_ASSIGN { MethodOperator(Op_ASET,pos) }
  | T_UPLUS<pos>                        { MethodUOperator(Op_UPlus,pos) }
  | T_UMINUS<pos>                       { MethodUOperator(Op_UMinus,pos) }
  | T_TILDE<pos>                        { MethodUOperator(Op_UTilde,pos) }

/*(* for simple method definitions, aliases and undefs *)*/
method_name:
  | message_identifier     { $1 }
  | T_LID T_ASSIGN         { MethodIdAssign ($1, $2, ID_Lowercase) }
  | T_UID T_ASSIGN         { MethodIdAssign ($1, $2, ID_Uppercase) }
  | keyword_as_id T_ASSIGN { MethodIdAssign ($1, $2, ID_Lowercase) }

/*(* was called method_name *)*/
method_kind:
  | method_name { M $1 }
  /*(* for complex method definitions *)*/
  | variable2<id1> T_DOT eols method_name<id2>
      { SingletonM (DotAccess(Id id1,($2), id2))}
  | variable2<id1> T_SCOPE    method_name<id2>
      { SingletonM (M.scope $2 (Id id1) (sm id2)) }
  | T_LPAREN arg T_RPAREN T_DOT method_name
      { SingletonM (DotAccess($2, ($4), ($5))) }

meth_or_atom:
    | method_name  { $1 }
    | T_ATOM       { MethodAtom (fst $1, AtomSimple (snd $1)) }

/*(* TODO: split in scoped_id *)*/
var_or_scoped_id:
  | variable<id>                           { Id id }
  | T_USCOPE<pos> variable<id>             { ScopedId (TopScope((pos),id))}
  | var_or_scoped_id<id1> T_SCOPE variable2<id2>
      { ScopedId (Scope(id1,$2,SV id2)) }

/*(*TODO: should be just constant below, not any variable *)*/
cst_or_scoped_id:
  | variable<id>                           { NameConstant (fst id) }
  | T_USCOPE<pos> variable<id>             { NameScope (TopScope((pos),id))}
  | var_or_scoped_id<id1> T_SCOPE variable2<id2>
      { NameScope (Scope(id1,$2,SV id2)) }



/*(* operator overloading *)*/
bin_op:
  | T_PLUS   { B Op_PLUS,$1 }   | T_MINUS  { B Op_MINUS, $1 }
  | T_STAR   { B Op_TIMES,$1 }  | T_SLASH  { B Op_DIV,$1 } | T_PERCENT{ B Op_REM,$1 }
  | T_POW    { B Op_POW,$1 }
  | T_LSHFT  { B Op_LSHIFT,$1 } | T_RSHFT  { B Op_RSHIFT,$1 }
  | T_LT     { B Op_LT,$1 }     | T_GT     { B Op_GT,$1 }
  | T_GEQ    { B Op_GEQ,$1 }    | T_LEQ    { B Op_LEQ,$1 }
  | T_EQ     { B Op_EQ,$1 }     | T_EQQ    { B Op_EQQ,$1 } | T_NEQ    { B Op_NEQ,$1 }
  | T_CMP    { B Op_CMP,$1 }
  | T_MATCH  { B Op_MATCH,$1 } | T_NMATCH { B Op_NMATCH,$1 }
  | T_AMPER  { B Op_BAND,$1 } | T_VBAR   { B Op_BOR,$1 }  | T_CARROT { B Op_XOR,$1 }
  /*(* TODO: should move T_ASSOC in pair *)*/
  | T_ASSOC  { Op_ASSOC,$1 }
  | T_DOT2   { B Op_DOT2,$1 }
  | T_DOT3   { Op_DOT3,$1 }

unary_op:
  | T_UPLUS<pos>   { Op_UPlus,pos }  | T_UMINUS<pos>  { Op_UMinus,pos }
  | T_TILDE<pos>   { Op_UTilde,pos } | T_BANG<pos>    { Op_UBang,pos }

keyword_as_id:
  | K_CLASS<pos>   { (("class", pos)) }
  | K_MODULE<pos>  { (("module", pos)) }
  | K_DEF<pos>     { (("def", pos)) }
  | K_END<pos>     { (("END", pos)) }
  | K_ALIAS<pos>   { (("alias", pos)) }
  | K_UNDEF<pos>   { (("undef", pos)) }
  | K_BEGIN<pos>   { (("BEGIN", pos)) }
  | K_RESCUE<pos>  { (("rescue", pos)) }
  | K_ENSURE<pos>  { (("ensure", pos)) }
  | K_IF<pos>      { (("if", pos)) }
  | K_UNLESS<pos>  { (("unless", pos)) }
  | K_THEN<pos>    { (("then", pos)) }
  | K_ELSIF<pos>   { (("elsif", pos)) }
  | K_ELSE<pos>    { (("else", pos)) }
  | K_CASE<pos>    { (("case", pos)) }
  | K_WHEN<pos>    { (("when", pos)) }
  | K_WHILE<pos>   { (("while", pos)) }
  | K_UNTIL<pos>   { (("until", pos)) }
  | K_FOR<pos>     { (("for", pos)) }
  | K_IN<pos>      { (("in", pos)) }
  | K_DO<pos>      { (("do", pos)) }
  | K_RETURN<pos>  { (("return", pos)) }
  | K_AND<pos>     { (("and", pos)) }
  | K_OR<pos>      { (("or", pos)) }
  | K_NOT<pos>     { (("not", pos)) }
  | K_lBEGIN<pos>  { (("begin", pos)) }
  | K_lEND<pos>    { (("end", pos)) }
  | K_YIELD<pos>   { (("yield", pos)) }
  | K_NIL<pos>     { (("nil", pos)) }
  | K_TRUE<pos>    { (("true", pos)) }
  | K_FALSE<pos>   { (("false", pos)) }
/*  | K_DEFINED<pos> { (ID_Lowercase, "defined?", pos) }*/




/*(*************************************************************************)*/
/*(*1 Misc *)*/
/*(*************************************************************************)*/

some_eols :
  | T_EOL eols {}

meth_or_atom_list:
    | meth_or_atom<e> { [e] }
    | meth_or_atom<e> T_COMMA meth_or_atom_list<lst>{ e::lst }
