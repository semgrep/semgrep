(* Yoann Padioleau
 *
 * Copyright (C) 2010 Facebook
 * Copyright (C) 2021 R2C
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
*)

open OCaml
open Ast_cpp

[@@@warning "-26-27"]

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* hooks *)
type visitor_in = {
  kexpr: expr vin;
  kstmt: stmt vin;
  kinit: initialiser vin;
  ktypeC: typeC vin;

  kclass_member: class_member vin;

  kparameter: parameter vin;
  kcompound: compound vin;

  kclass_def: class_definition vin;
  kfunc_def: func_definition vin;
  kcpp: cpp_directive vin;

  kdeclaration: decl vin;
  ktoplevel: toplevel vin;

  kinfo: tok vin;
}
and visitor_out = any -> unit
and 'a vin = ('a  -> unit) * visitor_out -> 'a  -> unit

let default_visitor =
  { kexpr    = (fun (k,_) x -> k x);
    kparameter = (fun (k,_) x -> k x);
    ktypeC = (fun (k,_) x -> k x);
    kcompound = (fun (k,_) x -> k x);
    kstmt = (fun (k,_) x -> k x);
    kinfo = (fun (k,_) x -> k x);
    kclass_def = (fun (k,_) x -> k x);
    kfunc_def = (fun (k,_) x -> k x);
    kclass_member = (fun (k,_) x -> k x);
    kcpp = (fun (k,_) x -> k x);
    kdeclaration = (fun (k,_) x -> k x);
    ktoplevel = (fun (k,_) x -> k x);
    kinit = (fun (k,_) x -> k x);
  }

let (mk_visitor: visitor_in -> visitor_out) = fun vin ->

  (* start of auto generation *)
  (* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_visitor.cmo  pr_o.cmo /tmp/xxx.ml  *)

  let rec v_info x =
    let k _ = () in
    vin.kinfo (k, all_functions) x

  and v_tok v = v_info v

  and v_wrap:'a. ('a -> unit) -> 'a wrap -> unit =
    fun _of_a (v1, v2) ->
      let v1 = _of_a v1 and v2 = v_info v2 in ()
  and v_paren:'a. ('a -> unit) -> 'a paren -> unit =
    fun _of_a (v1, v2, v3) ->
      let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in ()
  and v_brace: 'a. ('a -> unit) -> 'a brace -> unit =
    fun _of_a (v1, v2, v3) ->
      let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in ()
  and v_bracket: 'a. ('a -> unit) -> 'a bracket -> unit =
    fun _of_a (v1, v2, v3) ->
      let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in ()
  and v_angle: 'a. ('a -> unit) -> 'a angle -> unit =
    fun _of_a (v1, v2, v3) ->
      let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in ()

  and v_name (v1, v2, v3) =
    let v1 = v_option v_tok v1
    and v2 = v_list v_qualifier v2
    and v3 = v_ident_or_op v3
    in ()

  and v_ident v = v_wrap v_string v

  and v_ident_or_op =
    function
    | IdIdent v1 -> let v1 = v_wrap v_string v1 in ()
    | IdOperator (v1, v2) ->
        let v1 = v_tok v1
        and v2 = v_wrap v_operator v2
        in ()
    | IdConverter (v1, v2) -> let v1 = v_tok v1 and v2 = v_fullType v2 in ()
    | IdDestructor (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_wrap v_string v2 in ()
    | IdTemplated (v1, v2) ->
        let v1 = v_ident_or_op v1 and v2 = v_template_arguments v2 in ()
  and v_template_arguments v = v_angle (v_list (v_template_argument)) v
  and v_template_argument v = OCaml.v_either v_fullType v_expression v
  and v_either_ft_or_expr v = OCaml.v_either v_fullType v_expression v
  and v_qualifier =
    function
    | QClassname v1 -> let v1 = v_wrap v_string v1 in ()
    | QTemplateId (v1, v2) ->
        let v1 = v_wrap v_string v1 and v2 = v_template_arguments v2 in ()




  and v_fullType (v1, v2) =
    let v1 = v_typeQualifiers v1 and v2 = v_typeC v2 in ()
  and v_type_ x = v_fullType x
  and v_typeC v =
    let k v = v_typeCbis v in
    vin.ktypeC (k, all_functions) v

  and v_todo_category x = v_wrap v_string x
  and v_pointer_modifier = function
    | Based (v1, v2) -> v_tok v1; v_paren (v_list (v_argument)) v2
    | PtrRestrict (v1) -> v_tok v1
    | Uptr (v1) -> v_tok v1
    | Sptr (v1) -> v_tok v1
    | Unaligned (v1) -> v_tok v1

  and v_typeCbis =
    function
    | TPointer (v0, v1, v2) ->
        v_tok v0;
        let v1 = v_fullType v1 in
        v_list v_pointer_modifier v2
    | TReference (v0, v1) ->
        v_tok v0;
        let v1 = v_fullType v1 in ()
    | TArray (v1, v2) ->
        let v1 = v_bracket (v_option v_constExpression) v1
        and v2 = v_fullType v2
        in ()
    | TFunction v1 -> let v1 = v_functionType v1 in ()
    | EnumDef (v1) ->
        v_enum_definition v1
    | ClassDef v1 -> let v1 = v_class_definition v1 in ()
    | EnumName (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_name v2 in ()
    | ClassName (v1, v2) ->
        let v1 = v_wrap v_structUnion v1 and v2 = v_name v2 in ()
    | TypeName v1 ->
        let v1 = v_name v1 in ()
    | TypenameKwd (v1, v2) -> let v1 = v_tok v1 and v2 = v_type_ v2 in ()
    | TypeOf (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_paren v_either_ft_or_expr v2 in ()
    | ParenType v1 -> let v1 = v_paren v_fullType v1 in ()
    | TSized ((v1, v2)) ->
        let v1 = v_list (v_wrap v_sized_type) v1
        and v2 = v_option v_type_ v2
        in ()
    | TAuto v1 -> let v1 = v_tok v1 in ()
    | TRefRef ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_type_ v2 in ()
    | TPrimitive v1 -> let v1 = v_wrap v_primitive_type v1 in ()
    | TypeTodo ((v1, v2)) ->
        let v1 = v_todo_category v1 and v2 = v_list v_type_ v2 in ()

  and v_primitive_type =
    function
    | TVoid -> ()
    | TBool -> ()
    | TChar -> ()
    | TInt -> ()
    | TFloat -> ()
    | TDouble -> ()
  and v_sized_type =
    function | TSigned -> () | TUnsigned -> () | TShort -> () | TLong -> ()

  and v_enum_definition { enum_kind = v1; enum_name = v2; enum_body = v3 } =
    let v1 = v_tok v1
    and v2 = v_option v_name v2
    and v3 = v_brace (v_list v_enum_elem) v3
    in ()

  and v_enum_elem { e_name = v_e_name; e_val = v_e_val } =
    let arg = v_wrap v_string v_e_name in
    let arg =
      v_option
        (fun (v1, v2) -> let v1 = v_tok v1 and v2 = v_constExpression v2 in ())
        v_e_val
    in ()
  and v_typeQualifiers v =
    v_list (v_wrap v_type_qualifier) v

  and v_type_qualifier =
    function
    | Const -> ()
    | Volatile -> ()
    | Restrict -> ()
    | Atomic -> ()
    | Mutable -> ()
    | Constexpr -> ()

  and v_expression v =
    let k x = v_expressionbis x in
    vin.kexpr (k, all_functions) v

  and v_expr x = v_expression x

  and v_expressionbis =
    function
    | N (v1, v2) -> let v1 = v_name v1 and v2 = v_ident_info v2 in ()
    | C v1 -> let v1 = v_constant v1 in ()
    | Ellipsis v1 -> let v1 = v_tok v1 in ()
    | Call (v1, v2) ->
        let v1 = v_expression v1
        and v2 = v_paren (v_list v_argument) v2
        in ()
    | CondExpr (v1, t1, v2, t2, v3) ->
        let v1 = v_expression v1 in
        v_tok t1;
        let v2 = v_option v_expression v2 in
        v_tok t2;
        let v3 = v_expression v3 in
        ()
    | Sequence (v1, t1, v2) ->
        let v1 = v_expression v1 in
        v_tok t1;
        let v2 = v_expression v2 in
        ()
    | Assign (v1, v2, v3) ->
        let v1 = v_expression v1
        and v2 = v_assignOp v2
        and v3 = v_expression v3
        in ()
    | Postfix (v1, v2) -> let v1 = v_expression v1 and v2 = v_wrap v_fixOp v2 in ()
    | Prefix (v1, v2) -> v_wrap v_fixOp v1; v_expression v2
    | Unary (v1, v2) ->
        v_wrap v_unaryOp v1;
        v_expression v2
    | Binary (v1, v2, v3) ->
        let v1 = v_expression v1
        and v2 = v_wrap v_binaryOp v2
        and v3 = v_expression v3
        in ()
    | ArrayAccess (v1, v2) ->
        let v1 = v_expression v1 and v2 = v_bracket v_expression v2 in ()
    | DotAccess (v1, t, v2) ->
        let v1 = v_expression v1 and t = v_wrap v_dotOp t and v2 = v_name v2 in ()
    | DotStarAccess (v1, t, v2) ->
        let v1 = v_expression v1 and t = v_wrap v_dotOp t and v2 = v_expression v2 in ()

    | SizeOf (v1, v2) ->
        let v1 = v_tok v1
        and v2 = OCaml.v_either v_expr (v_paren v_type_) v2
        in ()
    | Cast (v1, v2) ->
        let v1 = v_paren v_fullType v1 and v2 = v_expression v2 in ()
    | StatementExpr v1 -> let v1 = v_paren v_compound v1 in ()
    | GccConstructor (v1, v2) ->
        let v1 = v_paren v_fullType v1
        and v2 = v_brace (v_list v_initialiser) v2
        in ()
    | ConstructedObject (v1, v2) ->
        let v1 = v_fullType v1
        and v2 = v_obj_init v2
        in ()
    | TypeId (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_paren v_either_ft_or_expr v2 in ()
    | CplusplusCast (v1, v2, v3) ->
        let v1 = v_wrap v_cast_operator v1
        and v2 = v_angle v_fullType v2
        and v3 = v_paren v_expression v3
        in ()
    | New (v1, v2, v3, v4, v5) ->
        let v1 = v_option v_tok v1
        and v2 = v_tok v2
        and v3 = v_option (v_paren (v_list v_argument)) v3
        and v4 = v_fullType v4
        and v5 = v_option v_obj_init v5
        in ()
    | Delete (v1, v2, v3, v4) ->
        let v1 = v_option v_tok v1
        and v2 = v_tok v2
        and v3 = v_option (v_bracket v_unit) v3
        and v4 = v_expr v4
        in ()
    | Throw (t1, v1) ->
        v_tok t1;
        let v1 = v_option v_expression v1 in ()
    | ParenExpr v1 -> let v1 = v_paren v_expression v1 in ()

    | IdSpecial v1 -> let v1 = v_wrap v_special v1 in ()
    | Lambda v1 -> let v1 = v_lambda_definition v1 in ()
    | ParamPackExpansion ((v1, v2)) ->
        let v1 = v_expr v1 and v2 = v_tok v2 in ()
    | DeepEllipsis v1 -> let v1 = v_bracket v_expr v1 in ()
    | TypedMetavar ((v1, v2)) -> let v1 = v_ident v1 and v2 = v_type_ v2 in ()
    | ExprTodo ((v1, v2)) ->
        let v1 = v_todo_category v1 and v2 = v_list v_expr v2 in ()

  and v_special = function | This -> () | Defined -> ()

  and v_lambda_definition (v1, v2) =
    let v1 = v_bracket (v_list v_lambda_capture) v1
    and v2 = v_function_definition v2
    in ()
  and v_lambda_capture =
    function
    | CaptureEq v1 -> let v1 = v_tok v1 in ()
    | CaptureRef v1 -> let v1 = v_tok v1 in ()
    | CaptureOther v1 -> let v1 = v_expr v1 in ()

  and v_obj_init =
    function
    | Args v1 -> let v1 = v_paren (v_list v_argument) v1 in ()
    | Inits v1 -> let v1 = v_brace (v_list v_initialiser) v1 in ()

  and v_ident_info { i_scope = _v_i_scope } =
    (* todo? let arg = Scope_code.v_scope v_i_scope in () *)
    ()
  and v_argument = function
    | Arg e -> v_expression e
    | ArgType v1 -> let v1 = v_fullType v1 in ()
    | ArgAction v1 -> let v1 = v_action_macro v1 in ()
    | ArgInits v1 -> let v1 = v_brace (v_list v_initialiser) v1 in ()

  and v_action_macro = function | ActMisc v1 -> let v1 = v_list v_tok v1 in ()
  and v_constant =
    function
    | String v1 -> v_wrap v_string v1
    | MultiString v1 ->
        v_list (v_wrap v_string) v1
    | Char v1 -> v_wrap v_string v1
    | Int v1 -> let v1 = v_wrap (v_option v_int) v1 in ()
    | Float v1 -> let v1 = v_wrap (v_option v_float) v1 in ()
    | Bool v1 -> v_wrap v_bool v1
    | Nullptr v1 -> v_tok v1

  and v_unaryOp =
    function
    | GetRef -> ()
    | DeRef -> ()
    | UnPlus -> ()
    | UnMinus -> ()
    | Tilde -> ()
    | Not -> ()
    | GetRefLabel -> ()
  and v_assignOp = function
    | SimpleAssign v1 -> v_tok v1
    | OpAssign v1 -> v_wrap v_arithOp v1

  and v_fixOp = function | Dec -> () | Inc -> ()
  and v_binaryOp =
    function
    | Arith v1 -> let v1 = v_arithOp v1 in ()
    | Logical v1 -> let v1 = v_logicalOp v1 in ()
  and v_arithOp =
    function
    | Plus -> ()
    | Minus -> ()
    | Mul -> ()
    | Div -> ()
    | Mod -> ()
    | DecLeft -> ()
    | DecRight -> ()
    | And -> ()
    | Or -> ()
    | Xor -> ()
  and v_logicalOp =
    function
    | Inf -> ()
    | Sup -> ()
    | InfEq -> ()
    | SupEq -> ()
    | Eq -> ()
    | NotEq -> ()
    | AndLog -> ()
    | OrLog -> ()
  and v_ptrOp = function | PtrStarOp -> () | PtrOp -> ()
  and v_allocOp =
    function
    | NewOp -> ()
    | DeleteOp -> ()
    | NewArrayOp -> ()
    | DeleteArrayOp -> ()
  and v_accessop = function | ParenOp -> () | ArrayOp -> ()
  and v_operator =
    function
    | BinaryOp v1 -> let v1 = v_binaryOp v1 in ()
    | AssignOp v1 -> let v1 = v_assignOp v1 in ()
    | FixOp v1 -> let v1 = v_fixOp v1 in ()
    | PtrOpOp v1 -> let v1 = v_ptrOp v1 in ()
    | AccessOp v1 -> let v1 = v_accessop v1 in ()
    | AllocOp v1 -> let v1 = v_allocOp v1 in ()
    | UnaryTildeOp -> ()
    | UnaryNotOp -> ()
    | CommaOp -> ()
  and v_cast_operator =
    function
    | Static_cast -> ()
    | Dynamic_cast -> ()
    | Const_cast -> ()
    | Reinterpret_cast -> ()
  and v_constExpression v = v_expression v

  and v_dotOp = function | Dot -> () | Arrow -> ()

  and v_statement v =
    let k v = v_statementbis v in
    vin.kstmt (k, all_functions) v

  and v_case_body v = v_list v_stmt_or_decl v

  and v_stmt x = v_statement x

  and v_statementbis =
    function
    | Compound v1 -> let v1 = v_compound v1 in ()
    | ExprStmt v1 -> let v1 = v_exprStatement v1 in ()
    | Label (v1, t, v2) ->
        v_wrap v_string v1;
        v_tok t;
        v_statement v2
    | Case (t1, v1, t2, v2) ->
        v_tok t1;
        v_expression v1;
        v_tok t2;
        v_case_body v2
    | CaseRange (t1, v1, t2, v2, t3, v3) ->
        v_tok t1;
        v_expression v1;
        v_tok t2;
        v_expression v2;
        v_tok t3;
        v_case_body v3
    | Default (t1, t2, v1) ->
        v_tok t1;
        v_tok t2;
        v_case_body v1

    | Jump (v1, v2) ->
        v_jump v1;
        v_tok v2
    | Try (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_compound v2
        and v3 = v_list v_handler v3
        in ()
    | MacroStmt v1 -> v_tok v1
    | StmtTodo ((v1, v2)) ->
        let v1 = v_todo_category v1 and v2 = v_list v_stmt v2 in ()
    | If (v1, t1, v2, v3, v4) ->
        v_tok v1;
        v_option v_tok t1;
        v_paren v_condition_clause v2;
        v_statement v3;
        v_option (fun (v1, v2) ->
          v_tok v1;
          v_statement v2) v4
    | Switch (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_paren v_condition_clause v2
        and v3 = v_statement v3
        in ()
    | While (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_paren v_condition_clause v2
        and v3 = v_statement v3
        in ()
    | DoWhile (v1, v2, v3, v4, v5) ->
        let v1 = v_tok v1
        and v2 = v_statement v2
        and v3 = v_tok v3
        and v4 = v_paren v_expression v4
        and v5 = v_tok v5
        in ()
    | For (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_paren v_for_header v2
        and v3 = v_statement v3
        in ()
    | MacroIteration (v1, v2, v3) ->
        let v1 = v_wrap v_string v1
        and v2 = v_paren (v_list v_argument) v2
        and v3 = v_statement v3
        in ()
  and v_compound v =
    let k v = v_brace (v_list (v_sequencable v_stmt_or_decl)) v in
    vin.kcompound (k, all_functions) v
  and v_for_header =
    function
    | ForEllipsis v1 -> v_tok v1
    | ForClassic ((v1, v2, v3)) ->
        let v1 = v_a_expr_or_vars v1
        and v2 = v_option v_expr v2
        and v3 = v_option v_expr v3
        in ()
    | ForRange ((v1, v2, v3)) ->
        let v1 = v_var_decl v1
        and v2 = v_tok v2
        and v3 = v_initialiser v3
        in ()
  and v_a_expr_or_vars v = OCaml.v_either v_expr_stmt v_vars_decl v

  and v_vars_decl (v1, v2) =
    let v1 = v_list v_onedecl v1 and v2 = v_sc v2 in ()

  and v_sc x = v_tok x

  and v_var_decl (v1, v2) =
    let v1 = v_entity v1 and v2 = v_variable_definition v2 in ()
  and v_variable_definition { v_init = v_v_init; v_type = v_v_type } =
    let arg = v_option v_init v_v_init in let arg = v_type_ v_v_type in ()

  and v_condition_clause =
    function
    | CondClassic v1 -> let v1 = v_expr v1 in ()
    | CondDecl ((v1, v2)) -> let v1 = v_vars_decl v1 and v2 = v_expr v2 in ()
    | CondStmt ((v1, v2)) -> let v1 = v_expr_stmt v1 and v2 = v_expr v2 in ()
    | CondOneDecl v1 -> let v1 = v_var_decl v1 in ()

  and v_stmt_or_decl =
    function
    | S v1 -> let v1 = v_stmt v1 in ()
    | D v1 -> let v1 = v_decl v1 in ()

  and v_decl x = v_declaration x

  and v_sequencable _of_a =
    function
    | X v1 -> let v1 = _of_a v1 in ()
    | CppDirective v1 -> let v1 = v_cpp_directive v1 in ()
    | CppIfdef v1 -> let v1 = v_ifdef_directive v1 in ()
    | MacroDecl ((v1, v2, v3, v4)) ->
        let v1 = v_list v_specifier v1
        and v2 = v_ident v2
        and v3 = v_paren (v_list v_argument) v3
        and v4 = v_sc v4
        in ()
    | MacroVar ((v1, v2)) -> let v1 = v_ident v1 and v2 = v_sc v2 in ()

  and v_sequencable2 _of_a =
    function
    | X v1 -> let v1 = _of_a v1 in ()
    | CppDirective v1 -> let v1 = v_cpp_directive v1 in ()
    | CppIfdef v1 -> let v1 = v_ifdef_directive v1 in ()
    | MacroDecl ((v1, v2, v3, v4)) ->
        let v1 = v_list v_specifier v1
        and v2 = v_ident v2
        and v3 = v_paren (v_list v_argument) v3
        and v4 = v_sc v4
        in ()
    | MacroVar ((v1, v2)) -> let v1 = v_ident v1 and v2 = v_sc v2 in ()

  and v_expr_stmt x = v_exprStatement x

  and v_exprStatement (v1, v2) =
    v_option v_expression v1;
    v_tok v2
  and v_jump =
    function
    | Goto (t, v1) -> v_tok t; let v1 = v_wrap v_string v1 in ()
    | Continue t -> v_tok t
    | Break t -> v_tok t
    | Return (t, v1) -> v_tok t; v_option v_argument v1
    | GotoComputed (t1, t2, v1) ->
        v_tok t1;
        v_tok t2;
        let v1 = v_expression v1 in ()
  and v_handler (v1, v2, v3) =
    let v1 = v_tok v1
    and v2 = v_paren v_exception_declaration v2
    and v3 = v_compound v3
    in ()
  and v_exception_declaration =
    function
    | ExnDecl v1 -> let v1 = v_parameter v1 in ()
  and v_storage =
    function
    | Auto -> () | Static -> () | Register -> () | Extern -> ()
    | StoInline -> ()
  and v_init =
    function
    | EqInit (v1, v2) -> let v1 = v_tok v1 and v2 = v_initialiser v2 in ()
    | ObjInit v1 -> let v1 = v_obj_init v1 in ()
    | Bitfield ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_a_const_expr v2 in ()

  and v_a_const_expr v = v_expr v


  and v_initialiser x =
    let k x =
      match x with
      | InitExpr v1 -> let v1 = v_expression v1 in ()
      | InitList v1 -> let v1 = v_brace (v_list v_initialiser) v1 in ()
      | InitDesignators (v1, v2, v3) ->
          let v1 = v_list v_designator v1
          and v2 = v_tok v2
          and v3 = v_initialiser v3
          in ()
      | InitFieldOld (v1, v2, v3) ->
          let v1 = v_wrap v_string v1
          and v2 = v_tok v2
          and v3 = v_initialiser v3
          in ()
      | InitIndexOld (v1, v2) ->
          let v1 = v_bracket v_expression v1 and v2 = v_initialiser v2 in ()
    in
    vin.kinit (k, all_functions) x

  and v_designator =
    function
    | DesignatorField (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_wrap v_string v2 in ()
    | DesignatorIndex v1 -> let v1 = v_bracket v_expression v1 in ()
    | DesignatorRange v1 ->
        let v1 =
          v_bracket
            (fun (v1, v2, v3) ->
               let v1 = v_expression v1
               and v2 = v_tok v2
               and v3 = v_expression v3
               in ())
            v1
        in ()
  and v_asmbody (v1, v2) =
    let v1 = v_list (v_wrap (v_string)) v1 and v2 = v_list (v_colon) v2 in ()
  and v_colon =
    function | Colon (v1, v2) ->
      v_tok v1;
      v_list v_colon_option v2
  and v_colon_option =
    function
    | ColonMisc v1 -> v_list v_tok v1
    | ColonExpr (v1, v2) ->
        v_list v_tok v1;
        v_paren v_expression v2
  and v_func_definition x =
    let k (v1, v2) =
      v_entity v1;
      v_function_definition v2;
    in
    vin.kfunc_def (k, all_functions) x

  and v_entity { name = v1; specs = v_specs } =
    let arg = v_name v1 in let arg = v_list v_specifier v_specs in ()
  and
    v_function_definition x =
    match x with {
      f_type = v_f_type;
      f_specs = v_f_storage;
      f_body = v_f_body
    } ->
        let arg = v_functionType v_f_type in
        let arg = v_list v_specifier v_f_storage in
        let arg = v_function_body v_f_body
        in
        ()

  and v_function_body =
    function
    | FBDef v1 -> let v1 = v_compound v1 in ()
    | FBDecl v1 -> let v1 = v_sc v1 in ()
    | FBZero ((v1, v2, v3)) ->
        let v1 = v_tok v1 and v2 = v_tok v2 and v3 = v_sc v3 in ()
    | FBDefault ((v1, v2, v3)) ->
        let v1 = v_tok v1 and v2 = v_tok v2 and v3 = v_sc v3 in ()
    | FBDelete ((v1, v2, v3)) ->
        let v1 = v_tok v1 and v2 = v_tok v2 and v3 = v_sc v3 in ()

  and v_specifier =
    function
    | A v1 -> let v1 = v_attribute v1 in ()
    | M v1 -> let v1 = v_modifier v1 in ()
    | TQ v1 -> let v1 = v_wrap v_type_qualifier v1 in ()
    | ST v1 -> let v1 = v_wrap v_storage v1 in ()
  and v_attribute =
    function
    | UnderscoresAttr ((v1, v2)) ->
        let v1 = v_tok v1
        and v2 = v_paren (v_paren (v_list v_argument)) v2
        in ()
    | BracketsAttr v1 -> let v1 = v_bracket (v_list v_expr) v1 in ()
    | DeclSpec ((v1, v2)) ->
        let v1 = v_tok v1 and v2 = v_paren v_ident v2 in ()

  and
    v_functionType {
      ft_ret = v_ft_ret;
      ft_params = v_ft_params;
      ft_specs = v_ft_dots;
      ft_const = v_ft_const;
      ft_throw = v_ft_throw
    } =
    let arg = v_fullType v_ft_ret in
    let arg = v_paren (v_list v_parameter) v_ft_params in
    let arg = v_list v_specifier v_ft_dots in
    let arg = v_option v_tok v_ft_const in
    let arg = v_list v_exn_spec v_ft_throw in
    ()

  and v_parameter x =
    let k x =
      match x with
      | P v1 -> let v1 = v_parameter_classic v1 in ()
      | ParamVariadic ((v1, v2, v3)) ->
          let v1 = v_option v_tok v1
          and v2 = v_tok v2
          and v3 = v_parameter_classic v3
          in ()
      | ParamEllipsis v1 -> let v1 = v_tok v1 in ()
      | ParamTodo ((v1, v2)) ->
          let v1 = v_todo_category v1 and v2 = v_list v_parameter v2 in ()
    in
    vin.kparameter (k, all_functions) x
  and
    v_parameter_classic x =
    match x with  {
      p_name = v_p_name;
      p_type = v_p_type;
      p_specs = v_p_register;
      p_val = v_p_val
    } ->
        let arg = v_option (v_wrap v_string) v_p_name in
        let arg = v_fullType v_p_type in
        let arg = v_list v_specifier v_p_register in
        let arg =
          v_option
            (fun (v1, v2) -> let v1 = v_tok v1 and v2 = v_expression v2 in ())
            v_p_val
        in ()

  and v_exn_spec =
    function
    | ThrowSpec ((v1, v2)) ->
        let v1 = v_tok v1 and v2 = v_paren (v_list v_type_) v2 in ()
    | Noexcept ((v1, v2)) ->
        let v1 = v_tok v1
        and v2 = v_option (v_paren (v_option v_a_const_expr)) v2
        in ()

  and v_class_definition x =
    let k (v1, v2) =
      let v1 = v_option v_name v1
      and v2 = v_class_definition_bis v2
      in ()
    in
    vin.kclass_def (k, all_functions) x
  and
    v_class_definition_bis x =
    match x with {
      c_kind = v_c_kind;
      c_inherit = v_c_inherit;
      c_members = v_c_members
    } ->
        let arg = v_wrap v_structUnion v_c_kind in
        let arg = v_list v_base_clause v_c_inherit in
        let arg = v_brace (v_list (v_sequencable2 (v_class_member))) v_c_members in
        ()


  and v_structUnion = function | Struct -> () | Union -> () | Class -> ()
  and
    v_base_clause {
      i_name = v_i_name;
      i_virtual = v_i_virtual;
      i_access = v_i_access
    } =
    let arg = v_name v_i_name in
    let arg = v_option v_modifier v_i_virtual in
    let arg = v_option (v_wrap v_access_spec) v_i_access in ()
  and v_access_spec = function | Public -> () | Private -> () | Protected -> ()

  and v_modifier = function
    | Inline v1 -> let v1 = v_tok v1 in ()
    | Virtual v1 -> let v1 = v_tok v1 in ()
    | Final v1 -> let v1 = v_tok v1 in ()
    | Override v1 -> let v1 = v_tok v1 in ()
    | MsCall v1 -> let v1 = v_wrap v_string v1 in ()
    | Explicit ((v1, v2)) ->
        let v1 = v_tok v1 and v2 = v_option (v_paren v_expr) v2 in ()

  and v_class_member x =
    let k =
      function
      | Access (v1, v2) ->
          let v1 = v_wrap v_access_spec v1 and v2 = v_tok v2 in ()
      | QualifiedIdInClass (v1, v2) ->
          let v1 = v_name v1 and v2 = v_tok v2 in ()
      | Friend ((v1, v2)) -> let v1 = v_tok v1 and v2 = v_decl v2 in ()
      | F v1 -> let v1 = v_decl v1 in ()
    in
    vin.kclass_member (k, all_functions) x

  and v_cpp_directive x =
    let k = function
      | Define (v1, v2, v3, v4) ->
          let v1 = v_tok v1
          and v2 = v_wrap v_string v2
          and v3 = v_define_kind v3
          and v4 = v_define_val v4
          in ()
      | Include (v1, v2) ->
          let v1 = v_tok v1
          and v2 = v_inc_kind v2
          in ()

      | Undef v1 -> let v1 = v_wrap v_string v1 in ()
      | PragmaAndCo v1 -> let v1 = v_tok v1 in ()
    in
    vin.kcpp (k, all_functions) x
  and v_define_kind =
    function
    | DefineVar -> ()
    | DefineMacro v1 ->
        let v1 = v_paren (v_list (v_wrap v_string)) v1 in ()
  and v_define_val =
    function
    | DefinePrintWrapper (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_paren v_expression v2
        and v3 = v_name v3
        in ()
    | DefineExpr v1 -> let v1 = v_expression v1 in ()
    | DefineStmt v1 -> let v1 = v_statement v1 in ()
    | DefineType v1 -> let v1 = v_fullType v1 in ()
    | DefineDoWhileZero (v1, v2, v3, v4) ->
        let v1 = v_tok v1
        and v2 = v_stmt v2
        and v3 = v_tok v3
        and v4 = v_paren v_tok v4
        in ()
    | DefineFunction v1 -> let v1 = v_func_definition v1 in ()
    | DefineInit v1 -> let v1 = v_initialiser v1 in ()
    | DefineEmpty -> ()
    | DefineTodo v1 -> let v1 = v_todo_category v1 in ()
  and v_inc_kind =
    function
    | IncLocal v1 -> v_wrap v_string v1
    | IncSystem v1 -> v_wrap v_string v1
    | IncOther v1 -> v_expression v1

  and v_ifdef_directive =
    function
    | Ifdef v1 -> v_tok v1
    | IfdefElse v1 -> v_tok v1
    | IfdefElseif v1 -> v_tok v1
    | IfdefEndif v1 -> v_tok v1

  and v_declarations v =
    v_brace (v_list (v_sequencable v_stmt_or_decl)) v
  and v_declaration x =
    let k = function
      | Func v1 -> let v1 = v_func_definition v1 in ()
      | TemplateDecl (v1, v2, v3) ->
          let v1 = v_tok v1
          and v2 = v_template_parameters v2
          and v3 = v_declaration v3
          in ()
      | ExternDecl (v1, v2, v3) ->
          let v1 = v_tok v1 and v2 = v_wrap v_string v2 and v3 = v_declaration v3 in ()
      | ExternList (v1, v2, v3) ->
          let v1 = v_tok v1
          and v2 = v_wrap v_string v2
          and v3 = v_declarations v3
          in ()
      | Namespace (v1, v2, v3) ->
          let v1 = v_tok v1
          and v2 = v_option (v_wrap v_string) v2
          and v3 = v_declarations v3
          in ()
      | EmptyDef v1 -> let v1 = v_tok v1 in ()
      | DeclTodo v1 -> v_todo_category v1

      | DeclList (v1, v2) ->
          let v1 = v_list v_onedecl v1 and v2 = v_tok v2 in ()
      | UsingDecl v1 -> v_using v1
      | NamespaceAlias (v1, v2, v3, v4, v5) ->
          let v1 = v_tok v1
          and v2 = v_wrap v_string v2
          and v3 = v_tok v3
          and v4 = v_name v4
          and v5 = v_tok v5
          in ()
      | Asm (v1, v2, v3, v4) ->
          let v1 = v_tok v1
          and v2 = v_option v_tok v2
          and v3 = v_paren v_asmbody v3
          and v4 = v_tok v4
          in ()
      | TemplateInstanciation ((v1, v2, v3)) ->
          let v1 = v_tok v1 and v2 = v_var_decl v2 and v3 = v_sc v3 in ()
      | StaticAssert ((v1, v2)) ->
          let v1 = v_tok v1 and v2 = v_paren (v_list v_argument) v2 in ()
      | NotParsedCorrectly v1 -> let v1 = v_list v_tok v1 in ()

    in
    vin.kdeclaration (k, all_functions) x


  and v_using (v1, v2, v3) =
    let v1 = v_tok v1 and v2 = v_using_kind v2 and v3 = v_sc v3 in ()
  and v_using_kind =
    function
    | UsingName v1 -> let v1 = v_name v1 in ()
    | UsingNamespace ((v1, v2)) ->
        let v1 = v_tok v1 and v2 = v_name v2 in ()
    | UsingAlias ((v1, v2, v3)) ->
        let v1 = v_ident v1 and v2 = v_tok v2 and v3 = v_type_ v3 in ()

  and v_onedecl =
    function
    | TypedefDecl ((v1, v2, v3)) ->
        let v1 = v_tok v1 and v2 = v_type_ v2 and v3 = v_ident v3 in ()
    | EmptyDecl v1 -> let v1 = v_type_ v1 in ()
    | V v1 -> let v1 = v_var_decl v1 in ()
    | StructuredBinding ((v1, v2, v3)) ->
        let v1 = v_type_ v1
        and v2 = v_bracket (v_list v_ident) v2
        and v3 = v_init v3
        in ()
    | BitField ((v1, v2, v3, v4)) ->
        let v1 = v_option v_ident v1
        and v2 = v_tok v2
        and v3 = v_type_ v3
        and v4 = v_a_const_expr v4
        in ()


  and v_template_parameter =
    function
    | TP v1 -> let v1 = v_parameter v1 in ()
    | TPClass ((v1, v2, v3)) ->
        let v1 = v_tok v1
        and v2 = v_option v_ident v2
        and v3 = v_option v_type_ v3
        in ()
    | TPVariadic ((v1, v2, v3)) ->
        let v1 = v_tok v1 and v2 = v_tok v2 and v3 = v_option v_ident v3 in ()
    | TPNested ((v1, v2, v3)) ->
        let v1 = v_tok v1
        and v2 = v_template_parameters v2
        and v3 = v_template_parameter v3
        in ()
  and v_template_parameters v = v_angle (v_list v_template_parameter) v
  and v_toplevel v =
    let k x =
      v_sequencable v_stmt_or_decl x
    in
    vin.ktoplevel (k, all_functions) v
  and v_program v = v_list v_toplevel v
  and v_any =
    function
    | Toplevels v1 -> v_list v_toplevel v1
    | Program v1 -> let v1 = v_program v1 in ()
    | Toplevel v1 -> let v1 = v_toplevel v1 in ()
    | Stmt v1 -> let v1 = v_statement v1 in ()
    | Stmts v1 -> let v1 = v_list v_statement v1 in ()
    | Expr v1 -> let v1 = v_expression v1 in ()
    | Init v1 -> let v1 = v_initialiser v1 in ()
    | Type v1 -> let v1 = v_fullType v1 in ()
    | Name v1 -> let v1 = v_name v1 in ()
    | Cpp v1 -> let v1 = v_cpp_directive v1 in ()
    | Constant v1 -> let v1 = v_constant v1 in ()
    | Argument v1 -> let v1 = v_argument v1 in ()
    | Parameter v1 -> let v1 = v_parameter v1 in ()
    | Body v1 -> let v1 = v_compound v1 in ()
    | Info v1 -> let v1 = v_info v1 in ()
    | InfoList v1 -> let v1 = v_list v_info v1 in ()
    | ClassMember v1 -> let v1 = v_class_member v1 in ()
    | OneDecl v1 -> let v1 = v_onedecl v1 in ()

  (* end of auto generation *)

  and all_functions x = v_any x
  in
  v_any
