\documentclass{article}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\newif\iffacebook

\finaltrue\verbosefalse\facebooktrue
%\finalfalse\verbosetrue\facebooktrue

%cf also some \newif below

\newcommand{\tm}{OCamlTreemap\xspace}

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------
%thx to LP, changed for the better a few things :)
% - ??

%history LP-ization:
% - skeleton; a not too bad TOC
% - put all content of files in the Extra section
% - split the files in chuncks (for type, helpers, ...), using
%   my emacs macro
% - distribute parts of the file before
% - add figures (hand made)
% - add biblio

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{noweb}
\noweboptions{}
%note: allow chunk to be on different pages, so less white space at
%  bottom of pages
\def\nwendcode{\endtrivlist \endgroup}
\let\nwdocspar=\par

\usepackage{xspace}

\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}

\usepackage{url}
\iffinal
\usepackage{hyperref}
\hypersetup{colorlinks=true}
\fi

\usepackage[pageref]{backref}
\def\backref{{\footnotesize cited page(s)}~}%en: \def\backref{{\footnotesize cited page(s)}~}


\usepackage{multirow}

\usepackage{booktabs}
\newcommand{\otoprule}{\midrule[\heavyrulewidth]}

\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\implemtrue
\implemoverviewtrue
\wantrepetitivecodefalse
\allcodefalse

%******************************************************************************
% Title
%******************************************************************************
\begin{document}

\title{
{\Huge
Treemaps
}\\
in OCaml\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{pad@facebook.com}
}
%dup: authors.txt


\maketitle

%TODO? an abstract ? instead of the copyright ?

%dup: with section Copyright
%\pagebreak
\hrule
\begin{quote}
    Copyright \copyright{}  2010 Facebook \\
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3.
\end{quote}
\hrule
%\pagebreak
% if implem is included, then the doc contains the full source code
% so the copyright should be LGPL ?

\iffinal
\begingroup
\hypersetup{colorlinks=true, linkcolor=blue}
\tableofcontents
\endgroup
\else
\tableofcontents
\fi


%******************************************************************************
% Body
%******************************************************************************

\section{Introduction}

\subsection{Motivations}


\begin{verbatim}
% see code base, many files, like kernel, or even my own code.
% SeeSoft good, thumbnails, but does not scale to thousands of files.
% enter treemaps, space filling!

% size important
% can play intensitiy, ... ex of treemap where size, modulated,
%  and intensitiy, and commit, and semantic, and speedbar!

% ex of pfff treemap, or linux!

% why reinvent ? related soft ?

% where better than fekete ?
\end{verbatim}

\cite{treemap-wikipedia}

\cite{treemap-market}


\begin{verbatim}
 * Advantages of my solution compared to using kdirstat on ~/www ?
 *  - can customize color for files, eg colors for css/php/js/...
 *  - can focus only on certain files, eg .php
 *
 *  - can access info from my other ocaml libs, eg
 *    pfff_db, and git. To do that with kdirstat would
 *    force me to hack a complex codebase, and dependencies (kde ...)
 *  - can combine static analysis or dynamic analyzis result with treemaps
 *    (but kprof does that too ?)
\end{verbatim}

More applications:
\cite{treemap-history}

\begin{verbatim}
(*
 * Basic references:
 *  http://en.wikipedia.org/wiki/Treemapping
 *  http://www.cs.umd.edu/hcil/treemap-history/index.shtml
 *
 * Seminal: http://hcil.cs.umd.edu/trs/91-03/91-03.html
 *
 * http://www.smartmoney.com/map-of-the-market/
 * (need jave plugin)
 *
 * Treemaps are cool. They can show multiple attributes at the same time:
 *  - size (size of rectangle)
 *  - depth (if nested, especially when use borders or cushion)
 *  - kind (color)
 *  - intensity (degrade de couleur)
 *  - extra info by for instance drawing points (des petits pois) inside it
 *    can also use filling pattern as in xfig to convey additional info.
 *
 * Does the position (x,y) mean something ? if sort alphabetically, then
 * yes can also give spatial indication. If use squarified then it's kind
 * of sorted by size which also give good spatial indication wether some
 * modules are important or not.
 *
 * More references:
 *  - seminal paper http://hcil.cs.umd.edu/trs/91-03/91-03.html
 *  - cushion so better see structure
 *    (solve pb of having lots of similar small rectangles which forbid to
 *    visually see the bigger picture, that is their enclosing rectangles)
 *  - squarified so can more easily compare two items
 *    (solve pb of elongated rectangle)
 *
 *
 * ***** other ocaml libs
 *
 * 3d stuff: lmntal style, with physics (not that needed)
 * http://ubietylab.net/ubigraph/content/Demos/Networkx.html
 * not free, they have a binding for ocaml
 *
 * **** other perl/python/ruby libs
 *
 * python seems quite good and fresh with latest research :)
 * semi:
 * http://www.machine-envy.com/blog/2006/07/29/a-treemap-viewer-for-python/
 * semi:
 * http://www.scipy.org/Cookbook/Matplotlib/TreeMap?action=show&redirect=TreeMap
 * (but does not have the cushion :( )
 *
 * http://rubytreemap.rubyforge.org/
 *
 * **** other java libraries ...
 *
 * treemap by bouthier (ex maryland)
 * perfuse
 *
 * **** misc
 *
 * http://kdirstat.sourceforge.net/kdirstat/
 * use apparently qtreemap
 *
 * http://kprof.sourceforge.net/
 * also use treemap
 *
 * *** list of libs
 * http://en.wikipedia.org/wiki/List_of_treemapping_software
 *

 *)

 *  - windirstats, kdirstats, etc
 *    http://lifehacker.com/5915921/the-best-disk-space-analyzer-for-windows

\end{verbatim}



\begin{figure*}
  \begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_code}
%height=7cm
  \end{center}
\caption{Treemap of source code}
\label{fig:treemap-ex}
\end{figure*}

\begin{verbatim}
% size, labels, anamorphic (c smaller :) ), git info.
% could add semantic analysis, so if called often, coefficient rectifier
\end{verbatim}

\subsection{Getting started}

\subsubsection{Requirements}

\begin{verbatim}
% commons
% json if want json reader
% recommended h_program-visual/
\end{verbatim}

\subsubsection{Compiling}

\subsubsection{Quick example of use}
\label{sec:quick-ex-use}

% API code

% command line program, json reader
\begin{verbatim}
$ ./treemap_viewer  examples/treemap/ex.json
\end{verbatim}

\begin{verbatim}
$ ./treemap_viewer -algorithm squarified  examples/treemap/ex.json
\end{verbatim}

\subsection{Copyright}

The source code of \tm is governed by the following copyright:
<<Facebook copyright>>=
(* Yoann Padioleau
 *
 * Copyright (C) 2010 Facebook
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)
@
%alt: (* Copyright 2009, 2010 Facebook. All Rights Reserved. *)

\subsection{About this document}
#include "About.tex.nw"


\section{Examples of Use}

% manual
% treedir

% mli


\section{Seminal Algorithm, Slice and Dice}
\label{sec:xxx}

\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_shneiderman_slice}
\caption{Slice and dice treemap}\label{fig:treemap-ex}
\end{center}\end{figure*}


\subsection{Treemap data structure}

\begin{verbatim}
(*
 * We use the directory/file metaphor for the nodes/leafs,
 * because dirs/files are one of the best example of use of treemaps,
 * and because it was the one chosen by Schneiderman in his original paper.
 *
 * The type is polymorphic because we want the interactive treemap visualizer
 * to offer hooks to display certain information about the dir/file under
 * the cursor.
 *)

\end{verbatim}


<<type treemap>>=
type ('dir, 'file) treemap =
 (treemap_data * 'dir, treemap_data * 'file) tree
    and treemap_data = {
      size : int;
      color : Simple_color.color;
      label: string;
    }
@


<<signature tree and treemap examples>>=
val treemap_rectangles_ex:
   ((float * float) list * (float * float) list * (float * float * float)) list

val tree_ex_shneiderman_1991 : (unit, int) tree
val tree_ex_wijk_1999: (unit, int) tree
val treemap_ex_ordered_2001: (unit, unit) treemap
@

<<variable tree_ex_shneiderman_1991>>=
let tree_ex_shneiderman_1991 =
  let ninfo = () in
  Node (ninfo,  [
    Leaf 12;
    Leaf 6;
    Node (ninfo,  [
      Leaf 2;
      Leaf 2;
      Leaf 2;
      Leaf 2;
      Leaf 2;
    ]);
    Node(ninfo,  [
      Node(ninfo,  [
        Leaf 5;
        Leaf 20;
      ]);
      Node(ninfo,  [
        Leaf 5;
      ]);
      Leaf 40;
    ]);
  ])
@


\subsection{The algorithm}

\cite{treemap-seminal}

<<signature display_treemap>>=
val display_treemap :
  ('dir, 'file) treemap -> int * int -> 'file option Common.matrix
@

<<type rectangle1>>=
(* The array has 2 elements, for x, y. I use an array because that's how
 * the seminal algorithm on treemap was written. It allows to pass
 * as an int the current split and do x.(axis_split) and do a 1-axis_split
 * in recursive calls to go from a x-split to a y-split.
 *
 * A rectangle is represented by 2 variables called P and Q in the seminal
 * algorithm.
 *)
(*
type rectangle1 =
  float array (* lower left  coord, P *) *
  float array (* upper right coord, Q *)
*)

@


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/IMG_0067}
\caption{P and Q}\label{fig:treemap-ex}
\end{center}\end{figure*}

\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/IMG_0069}
\caption{Slicing and dicing}\label{fig:treemap-ex}
\end{center}\end{figure*}



<<function display_treemap>>=
(*
 * ref: http://hcil.cs.umd.edu/trs/91-03/91-03.html, page 6
 *
 * The algorithm is very simple. Look at the paper. I've just added
 * the depth argument.
 *
 * axis_split is 0 when split enclosing rectangle vertically, and 1
 * when doing it horizontally. We alternate hence the (1 - axis_split) below.
 *
 * still? look if python port look the same
 *)
let display_treemap (treemap: ('dir,'file) treemap) (w, h) =

  let mat = Array.make_matrix w h None in

  (* p and q are the coords of the current rectangle being laid out *)
  let rec aux_treemap root p q axis_split ~depth =

    (* todo? join the 2 match in a single one ? *)
    (match root with
    | Leaf (tnode, fileinfo) ->
        let color = color_of_treemap_node root in

        let rect_opt =
          draw_rect_treemap_float_ortho
            ((p.(0), p.(1)),
             (q.(0), q.(1)))
            color
            (w, h)
        in
        rect_opt +> Common.do_option (update_mat_with_fileinfo fileinfo mat)

    | Node (tnode, dirinfo) ->
        ()
    );
    let size_root = size_of_treemap_node root in
    let width = q.(axis_split) -. p.(axis_split) in
    match root with
    | Node (mode, children) ->
        children +> List.iter (fun child ->
          (* if want margin, then maybe can increment slightly p and decrement
           * q ? like 1% of its width ?
           *)
          q.(axis_split) <-
            p.(axis_split) +.
            (float_of_int (size_of_treemap_node child) /.
             float_of_int (size_root)) *. width;
          aux_treemap child (Array.copy p) (Array.copy q) (1 - axis_split)
            ~depth:(depth + 1)
          ;
          p.(axis_split) <- q.(axis_split);
        )
    | Leaf _ -> ()
  in
  aux_treemap treemap [|0.0;0.0|] [|1.0;1.0|] 0  ~depth:1;
  mat
@

\subsection{Screen and viewport}

\begin{verbatim}
(* Need information such as total width to draw to the right place, outside
 * the viewport, in the status area or legend area.
 *)

\end{verbatim}


<<type screen_dim>>=
type screen_dim = {
  (* total width/height *)
  w: int;
  h: int;
  (* the viewport *)
  w_view: int;
  h_view: int;
  (* extra information *)
  h_status: int;
  w_legend: int;
}
@


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/IMG_0066}
\caption{Screen and viewport}\label{fig:treemap-ex}
\end{center}\end{figure*}


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/IMG_0068}
\caption{Scaling the ortho plan}{fig:treemap-ex}
\end{center}\end{figure*}


<<signature graphic helpers>>=
val draw_rect_treemap_float_ortho :
  (float * float) * (float * float) ->
  Graphics.color -> int * int -> ((int * int) * (int * int)) option
@

<<function draw_rect_treemap_float_ortho>>=
(*
 * The treemap algorithms assume an ortho? space from 0,0 to 1.1 but
 * our current screen have pixels and goes from 0,0 to 1024,168 for
 * instance. Those functions are here to make the translation
 * (it can produce some aliasing effects).

 * TODO: pass a converter function from ortho space to regular ?
 * as in opengl?
 *)

let draw_rect_treemap_float_ortho ((x1, y1),(x2, y2)) color (w, h) =

  let w = float_of_int w in
  let h = float_of_int h in

  let x1, y1 = int_of_float (x1 *. w), int_of_float (y1 *. h) in
  let x2, y2 = int_of_float (x2 *. w), int_of_float (y2 *. h) in
  let w = (x2 - x1) in
  let h = (y2 - y1) in
  Graphics.set_color color;

  if w <= 0 || h <= 0
  then None
  else begin
    Graphics.fill_rect
      x1 y1 w h;
    Some ((x1,y1), (x2,y2))
  end
@


\section{Other Algorithms}
\label{sec:xxx}

<<type algorithm>>=
type algorithm =
  | Classic
  | Squarified
  | SquarifiedNoSort
  | Ordered of pivot

  and pivot =
    | PivotBySize
    | PivotByMiddle
@

<<signature algos>>=
val algos: algorithm list

val layoutf_of_algo: algorithm -> ('a, 'b) layout_func

@

<<variable algos>>=
let algos = [Classic; Squarified; SquarifiedNoSort;
             Ordered PivotBySize; Ordered PivotByMiddle]
@


<<signature display_treemap_algo>>=
val display_treemap_algo :
  ?algo:algorithm ->
  ?drawing_file_hook:
    (Figures.rect_pixel -> 'file -> 'file option Common.matrix -> unit) ->
  ('dir, 'file) treemap ->
  int * int ->
  'file option Common.matrix
@

\subsection{Tiling rectangles}
\label{sec:xxx}

%note: before I had a bug in visualizer :( only for ordered
% when draw square, draw it wrong time ? because of lack of Array.copy ?
% I then used this better rect type below, so no need to do some Array.copy
% proof that array and side effects really lead to buggy code :)

<<type layout_func>>=
type ('a, 'b) layout_func =
  (float * ('a, 'b) treemap) list ->
  int ->
  rectangle ->
  (float * ('a, 'b) treemap * rectangle) list
@


<<function display_treemap_generic>>=
let display_treemap_generic
    ?(drawing_file_hook=(fun _rect _file _mat -> ()))
    (treemap: ('dir,'file) treemap)
    (w, h)
    flayout
 =

  let mat = Array.make_matrix w h None in

  let rec aux_treemap root rect ~depth =
    let (p,q) = rect.p, rect.q in

    if not (valid_rect rect)
    then () (* TODO ? warning ? *)
    else

    (match root with
    | Leaf (tnode, fileinfo) ->
        let color = color_of_treemap_node root in

        let rect_opt =
          draw_rect_treemap_float_ortho
            ((p.x, p.y),
             (q.x, q.y))
            color
            (w, h)
        in
        let info = fileinfo in

        (match rect_opt with
        | None -> ()
        | Some ((x1,y1), (x2,y2)) ->

            for i = x1 to x2 - 1 do
              for j = y1 to y2 - 1 do
                mat.(i).(j) <- Some info;
              done
            done;

            drawing_file_hook {
              F.lower_left =   { F.x = x1; F.y = y1 };
              F.upper_right =  { F.x = x2; F.y = y2 };
            }
              fileinfo
              mat

        );
        draw_label rect  (w, h) depth (tnode).label ~is_dir:false


    | Node (mode, children) ->

        (* let's draw some borders. Far better to see the structure. *)
        let _rect_opt =
          draw_rect_treemap_float_ortho
            ((p.x, p.y),
            (q.x, q.y))
            Graphics.black
            (w, h)

        in
        (* does not work, weird *)
        let border =
          match depth with
          | 1 -> 0.0
          | 2 -> 0.002
          | 3 -> 0.001
          | 4 -> 0.0005
          | 5 -> 0.0002
          | _ -> 0.0
        in
        let p = {
          x = p.x +. border;
          y = p.y +. border;
        }
        in
        let q = {
          x = q.x -. border;
          y = q.y -. border;
        }
        in
        (* todo? can overflow ... check still inside previous rect *)
        let rect = { p = p; q = q } in

        let children' =
          children +> List.map (fun child ->
            float_of_int (size_of_treemap_node child),
            child
          )
        in

        let rects_with_info =
          (* generic call *)
          flayout children' depth rect
        in
        (* less: assert rects_with_info are inside rect ? *)

        rects_with_info +> List.iter (fun (x, child, rect) ->
          aux_treemap child rect ~depth:(depth + 1)
        );

        draw_label rect (w, h) depth (fst mode).label ~is_dir:true
    )
  in
  aux_treemap treemap rect_ortho ~depth:1;
  mat
@


<<function display_treemap_algo>>=
let display_treemap_algo ?(algo=Classic) ?drawing_file_hook
 treemap (w, h) =

  (* old: display_treemap            treemap (w, h) *)
  let layoutf = layoutf_of_algo algo in
  display_treemap_generic ?drawing_file_hook
    treemap (w, h) layoutf
@


<<layout slice and dice>>=
let (slice_and_dicing_layout: ('a, 'b) layout_func) =
 fun children depth rect ->

  let p = [| rect.p.x; rect.p.y |] in
  let q = [| rect.q.x; rect.q.y |] in

  let axis_split = (depth + 1) mod 2 in

  let stotal = children +> List.map fst +> Common2.sum_float in

  let width = q.(axis_split) -. p.(axis_split) in

  children +> List.map (fun (size, child) ->

    q.(axis_split) <-
      p.(axis_split) +.
      ((size) /. stotal) *. width;

    let rect_here = {
      p = {  x = p.(0); y = p.(1); };
      q = {  x = q.(0); y = q.(1); }
    }
    in
    p.(axis_split) <- q.(axis_split);
    size, child, rect_here
  )
@


\subsection{Clustered treemaps}
\label{sec:xxx}

\subsection{Squarified treemaps}
\label{sec:xxx}

\cite{treemap-squarified}

<<variable tree_ex_wijk_1999>>=
let tree_ex_wijk_1999 =
  let ninfo = () in
  Node (ninfo,  [
    Leaf 6;
    Leaf 6;
    Leaf 4;
    Leaf 3;
    Leaf 2;
    Leaf 2;
    Leaf 1;
  ])
@


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_wijk_slice}
\caption{Slice and dice limitations}\label{fig:treemap-ex}
\end{center}\end{figure*}


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_wijk_squarified}
\caption{Squarified treemap}\label{fig:treemap-ex}
\end{center}\end{figure*}

\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/IMG_0065}
\caption{Squarifying algorithm}\label{fig:treemap-ex}
\end{center}\end{figure*}

<<squarified examples>>=
(* ref: www.win.tue.nl/~vanwijk/stm.pdf
 *
 * In the following I use some of the examples in the paper so you'll need
 * the paper to follow what I say.
 *)


(*
 * A few examples.
 *
 * the total sum in squarified_list_area_ex is 24, just like the area
 * of rect_orig below. This simplifies discussions.
 *
 * I've added the string later as we want squarify to also return
 * information related to the node with its size (that is the full treemap
 * node, with its descendant)
*)
let squarified_list_area_ex =
  [6; 6; 4; 3; 2; 2; 1] +> List.map (fun x -> float_of_int x, spf "info: %d" x)

(* normally our algorithm should do things proportionnally to the size
 * of the aready. It should not matter that the total sum of area is
 * equal to the size of the rectangle. Indeed later we will always do
 * things in an ortho plan, that is with a rectangle 0x0 to 1x1.
 *)
let squarified_list_area_ex2 =
  squarified_list_area_ex +> List.map (fun (x, info) -> x *. 2.0, info)
let dim_rect_orig =
  { p = {x = 0.0; y = 0.0; }; q = { x = 6.0; y = 4.0} }
@


<<type split>>=
type split =
  (* Spread one next to the other, e.g. | | | | | |
   * The split lines will be vertical, but the rectangles
   * would be spreaded horizontally. In the paper they call that horizontal
   * Split but I prefer Spread, because the split lines are actually verticals.
   *)
  | SpreadHorizontally

  (* Spread one on top of the other eg _
   *                                   _
   *                                   _
   *)
  | SpreadVertically
@


<<function ratio_rect_dim>>=
(* we want the ratio to be a close to 1 as possible (that is to be a square) *)
let ratio_rect_dim (w,h) =
  let res = max (w /. h) (h /. w) in
  (* assert (res >= 1.0); *)
  res

let _ = assert (ratio_rect_dim (6.0, 4.0) = 1.5)
let _ = assert (ratio_rect_dim (4.0, 6.0) = 1.5)
@


<<function worst>>=
(* On the running example, at the first step we want to add the rect of
 * size 6 on the left, alone, and its aspect ratio will be 8/3.
 * Indeed its height is fixed (4) and so his width is
 * whatever that must lead to an area of 6, that is 6/4 (1.5)
 * which leads then to an aspect ratio of 4 vs 1.5 = 4 / 1.5 = 8/3.
 * If we add 2 rect of size 6, then their aspect ratio is 1.5 which is
 * better
 *)

let worst elems_in_row  size_side_row =
  let s = Common2.sum_float elems_in_row in
  let rplus = Common2.maximum elems_in_row in
  let rminus = Common2.minimum elems_in_row in

  (* cf formula in paper *)
  max ((Common2.square size_side_row *. rplus) /. Common2.square s)
      (Common2.square s /.  (Common2.square size_side_row *. rminus))

let _ = assert
  (worst [6.0] 4.0 = 8.0 /. 3.0) (* 2.66667 *)
let _ = assert
  (worst [6.0;6.0] 4.0 = 3.0 /. 2.0) (* 1.5, which is close to 1 so better *)
let _ = assert
  (worst [6.0;6.0;4.0] 4.0 = 4.0) (* 4.0, we regress *)
@


<<function layout>>=
(* We are given a fixed row which contains a set of elems that we have
 * to spread unoformly, just like in the original algorithm.
 *)
let layout row rect =

  let p = [| rect.p.x; rect.p.y |] in
  let q = [| rect.q.x; rect.q.y |] in

  let children = row in

  let stotal = children +> List.map fst +> Common2.sum_float in
  let children = children +> List.map (fun (size, info) ->
    size /. stotal (* percentage *),
    size,
    info
  )
  in

  let res = ref [] in
  let spread =
    if rect_width rect >= rect_height rect
    then SpreadHorizontally
    else SpreadVertically
  in
  let axis_split =
    match spread with
    | SpreadHorizontally -> 0
    | SpreadVertically -> 1
  in
  let width = q.(axis_split) -. p.(axis_split) in

  children +> List.iter (fun (percent_child, size_child, info) ->

    q.(axis_split) <-
      p.(axis_split) +.
      percent_child *. width;
    let rect_here = {
      p = {  x = p.(0); y = p.(1); };
      q = {  x = q.(0); y = q.(1); }
    }
    in
    Common.push (size_child, info, rect_here) res;
    p.(axis_split) <- q.(axis_split);
  );
  !res
@


<<function squarify_orig>>=
let rec (squarify_orig:
   ?verbose:bool ->
   (float * 'a) list -> (float * 'a) list -> rectangle ->
   (float * 'a * rectangle) list
   ) =
 fun ?(verbose=false) children current_row rect ->
  (* does not work well because of float approximation.
   * assert(Common.sum_float (children ++ current_row) = rect_area rect);
   *)
  let (p, q) = rect.p, rect.q in

  let floats xs = List.map fst xs in

  (* First heuristic in the squarified paper *)
  let spread =
    if rect_width rect >= rect_height rect (* e.g. 6 x 4 rectangle *)
    then SpreadHorizontally
    else SpreadVertically
  in

  (* We now know what kind of row we want. If spread horizontally then
   * we will have a row on the left to fill and the size of the side of
   * this row is known and is the height of the rectangle (in our ex 4).
   * In the paper they call this variable 'width' but it's misleading.
   * Note that because we are in Horizontal mode, inside this left row,
   * things will be spreaded this time vertically.
   *)
  let size_side_row =
    match spread with
    | SpreadHorizontally -> rect_height rect
    | SpreadVertically -> rect_width rect
  in
  match children with
  | c::cs ->
      if null current_row ||
         (worst (floats (current_row @ [c])) size_side_row)
          <=
          (worst (floats current_row)         size_side_row)
      then
        (* not yet optimal row, let's recurse *)
        squarify_orig cs (current_row @ [c]) rect
      else begin
        (* optimal layout for the left row. We can fix it. *)
        let srow = Common2.sum_float (floats current_row) in
        let stotal = Common2.sum_float (floats (current_row @ children)) in
        let portion_for_row = srow /. stotal in

        let row_rect, remaining_rect =
          match spread with
          | SpreadHorizontally ->
              let middle_x =
                (q.x -. p.x) *. portion_for_row
                  +. p.x
              in
              {
                p = p;
                q = { x = middle_x; y = q.y };
              },
              {
                p = { x = middle_x; y = p.y};
                q = q;
              }

          | SpreadVertically ->
              let middle_y =
                (q.y -. p.y) *. portion_for_row
                  +. p.y in
              {
                p = p;
                q = { x = q.x; y = middle_y;};
              },
              {
                p = { x = p.x; y = middle_y};
                q = q;
              }


        in
        if verbose then begin
          pr2 "layoutrow:";
          pr2_gen current_row;
          pr2 "row rect";
          pr2 (s_of_rectangle row_rect);
        end;

        let rects_row = layout current_row row_rect in
        let rects_remain = squarify_orig children [] remaining_rect in
        rects_row @ rects_remain
      end
  | [] ->
      if verbose then begin
        pr2 "layoutrow:";
        pr2_gen current_row;
        pr2 "row rect";
        pr2 (s_of_rectangle rect);
      end;

      layout current_row rect
@


<<function squarify>>=
let squarify children rect =
  (* squarify_orig assume the sum of children = area rect *)
  let area = rect_area rect in
  let total = Common2.sum_float (List.map fst children) in
  let children' = children +> List.map (fun (x, info) ->
    (x /. total) *. area,
    info
  )
  in
  squarify_orig children' [] rect
@


<<function test_squarify>>=
let test_squarify () =
    pr2_gen (worst [6.0] 4.0);
    pr2_gen (worst [6.0;6.0] 4.0);
    pr2_gen (worst [6.0;6.0;4.0] 4.0);
  pr2_xxxxxxxxxxxxxxxxx ();
  squarify squarified_list_area_ex dim_rect_orig +> ignore;
  pr2_xxxxxxxxxxxxxxxxx ();
  squarify squarified_list_area_ex2 rect_ortho +> ignore;
  ()
@


<<layout squarify>>=
let (squarify_layout: ('a, 'b) layout_func) =
 fun children _depth rect ->
  let children' = children +> Common.sort_by_key_highfirst in
  squarify children' rect

let (squarify_layout_no_sort_size: ('a, 'b) layout_func) =
 fun children _depth rect ->
  squarify children rect
@




\subsection{Ordered treemaps}
\label{sec:xxx}

\cite{treemap-ordered}

<<variable treemap_ex_ordered_2001>>=
let (treemap_ex_ordered_2001: (unit, unit) treemap) =
  let children = children_ex_ordered_2001 in

  let children_treemap =
    children +> Common.index_list_1 +> List.map (fun (size, i) ->

      Leaf ({
        size = size;
        color = Color.color_of_string (spf "grey%d" (90 - (i * 3)));
        label = spf "size = %d" size;
      }, ())
    )
  in
  let total_size = Common2.sum children in
  Node (({
    size = total_size;
    color = Color.black;
    label = "";
  }, ()), children_treemap
  )
@


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_grey_slice}
\caption{Orders in slice and dice}\label{fig:treemap-ex}
\end{center}\end{figure*}


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_grey_squarified}
\caption{Orders in squarified}\label{fig:treemap-ex}
\end{center}\end{figure*}


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_grey_squarified_nosort}
\caption{Orders in squarified no sort}\label{fig:treemap-ex}
\end{center}\end{figure*}





\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/IMG_0073}
\caption{Finding a good split point}\label{fig:treemap-ex}
\end{center}\end{figure*}

\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/IMG_0070}
\caption{Pivot coordinates part1}\label{fig:treemap-ex}
\end{center}\end{figure*}


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/IMG_0071}
\caption{Pivot coordinates part2}\label{fig:treemap-ex}
\end{center}\end{figure*}




\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_grey_ordered_middle}
\caption{Ordered by middle treemap}\label{fig:treemap-ex}
\end{center}\end{figure*}


\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_grey_ordered_size}
\caption{Ordered by size treemap}\label{fig:treemap-ex}
\end{center}\end{figure*}




<<ordered examples>>=
(* ref:
*)

let children_ex_ordered_2001 = [
    1; 5; 3; 4; 5; 1;
    10; 1; 1; 2; 7; 3;
    5; 2; 10; 1; 2; 1;
    1; 2;
  ]
@


<<type pivotized>>=
type 'a pivotized = {
  left: 'a;
  right: 'a;
  pivot: 'a; (* this one should be singleton and the other a list *)
  above_pivot: 'a;
}
@


<<function compute_rects_pivotized>>=
let compute_rects_pivotized childs_pivotized rect spread =
  let (p, q) = rect.p, rect.q in

  let x = childs_pivotized in
  let size = {
    left = Common2.sum_float (List.map fst x.left);
    right = Common2.sum_float (List.map fst x.right);
    pivot = Common2.sum_float (List.map fst x.pivot);
    above_pivot = Common2.sum_float (List.map fst x.above_pivot);
  }
  in

  let total_size = size.left +. size.right +. size.pivot +. size.above_pivot in

  let portion_for_left = size.left /. total_size in
  let portion_for_right = size.right /. total_size in

  let portion_for_pivot_vs_above =
    (size.pivot ) /. (size.pivot +. size.above_pivot)
  in

  (* computing the rectangle of the left and right is easy as the
   * height is fixed (when we spread horizontally)
   *)
  match spread with
  | SpreadHorizontally ->
      (* TODO do something that adapt to rect ? lourd que rect
       * commence pas 0,0, ca fait faire des calculs en plus. *)
      let middle_x1 =
        p.x +. ((rect_width rect) *. portion_for_left)
      in
      let middle_x2 =
        q.x -.  ((rect_width rect) *. portion_for_right)
      in
      let middle_y =
        p.y +. ((rect_height rect) *. portion_for_pivot_vs_above)
      in
      { left = {
            p = p;
            q = { x = middle_x1; y = q.y } };
        right = {
            p = { x = middle_x2; y = p.y };
            q = q; };
        pivot = {
            p = { x = middle_x1; y = p.y};
            q = { x = middle_x2; y = middle_y}; };
        above_pivot = {
            p = { x = middle_x1; y = middle_y };
            q = { x = middle_x2; y = q.y; } };
      }

  | SpreadVertically ->
      (* just the reverse of previous code, x become y and vice versa *)
      let middle_y1 =
        p.y +. ((rect_height rect) *. portion_for_left)
      in
      let middle_y2 =
        q.y -. ((rect_height rect) *. portion_for_right)
      in

      let middle_x =
        p.x +. ((rect_width rect) *. portion_for_pivot_vs_above)
      in
      { left = {
          p = p;
          q = { x = q.x; y = middle_y1; } };
        right = {
          p = { x = p.x; y = middle_y2; };
          q = q; };
        pivot = {
          p = { x = p.x;  y = middle_y1; };
          q = { x = middle_x; y = middle_y2; } };
        above_pivot = {
          p = { x = middle_x; y = middle_y1; };
          q = { x = q.x; y = middle_y2; } }
      }
@


<<function balayer_right_wrong>>=
(*
let rec balayer_right_wrong xs =
  match xs with
  | [] -> []
  | x::xs ->
      let first =
        [], x::xs
      in
      let last =
        x::xs, []
      in
      let rest = balayer_right_wrong xs in
      let rest' = rest +> List.map (fun (start, theend) -> x::start, theend) in
      [first] ++ rest' ++ [last]
*)

let balayer_right xs =
  let n = List.length xs in
  let res = ref [] in
  for i = 0 to n do
    Common.push (take i xs, drop i xs) res;
  done;
  List.rev !res
let _ = assert (balayer_right [1;2;3;2] =
    [
      [], [1;2;3;2];
      [1], [2;3;2];
      [1;2], [3;2];
      [1;2;3], [2];
      [1;2;3;2], [];
    ])
@


<<function orderify_children>>=
let orderify_children ?(pivotf=PivotBySize) xs rect =

  let rec aux xs rect =
    match xs with
    | [] -> []
    | [size, x] ->
        [size, x, rect]

    | _x::_y::_ys ->

        let left, pivot, right =
          match pivotf with
          | PivotBySize ->
              let pivot_max = Common2.maximum (xs +> List.map fst) in
              Common2.split_when
                (fun x -> fst x = pivot_max) xs
          | PivotByMiddle ->
              let nmiddle = List.length xs / 2 in
              let start, thend = Common2.splitAt nmiddle xs in

              start, List.hd thend, List.tl thend
        in

        let spread =
          if rect_width rect >= rect_height rect (* e.g. 6 x 4 rectangle *)
          then SpreadHorizontally
          else SpreadVertically
        in

        let right_combinations = balayer_right right in

        let scores_and_rects =
          right_combinations +> List.map (fun (above_pivot, right) ->

            let childs_pivotized =
              { left = left;
                pivot = [pivot];
                right = right;
                above_pivot = above_pivot;
              }
            in
            let rects = compute_rects_pivotized childs_pivotized rect spread in
            ratio_rect_dim (rect_width rects.pivot, rect_height rects.pivot),
            (rects,
            childs_pivotized)
          )
        in
        let best = Common.sort_by_key_lowfirst scores_and_rects +> List.hd in
        let (_score, (rects, childs_pivotized)) = best in

        (* pr2_gen rects; *)
        aux childs_pivotized.left rects.left @
        aux childs_pivotized.pivot rects.pivot @
        aux childs_pivotized.above_pivot rects.above_pivot @
        aux childs_pivotized.right rects.right @
        []
  in
  aux xs rect
@


<<function test_orderify>>=
let test_orderify () =
  let xs = children_ex_ordered_2001 +> List.map float_of_int in
  let rect = rect_ortho in

  let fake_treemap = () in
  let children = xs +> List.map (fun size -> size, fake_treemap) in

  let layout = orderify_children children rect in
  pr2_gen layout
@


<<layout ordered>>=
let (ordered_layout: ?pivotf:pivot -> ('a, 'b) layout_func) =
 fun ?pivotf children _depthTODOMAYBE rect ->
  orderify_children ?pivotf children rect
@



\subsection{Cushion treemaps}
\label{sec:xxx}

\cite{treemap-cushion}


\section{Extra Features}
\label{sec:xxx}

\subsection{Nesting}

% border

\subsection{Labeling}

% label

\subsection{Interactivity}

<<signature display_treemap_interactive>>=
val display_treemap_interactive :
  ?algo:algorithm ->
  ?drawing_file_hook:
    (Figures.rect_pixel -> 'file -> 'file option Common.matrix -> unit) ->
  (* used to display file information in the status area *)
  ?info_of_file_under_cursor:(Graphics.status -> 'file -> string) ->
  ('dir, 'file) treemap ->
  screen_dim ->
  unit
@


<<function update_mat_with_fileinfo>>=
let update_mat_with_fileinfo fileinfo mat rect =

  let ((x1,y1), (x2,y2)) = rect in

  for i = x1 to x2 - 1 do
    for j = y1 to y2 - 1 do
      mat.(i).(j) <- Some fileinfo;
    done
  done
@


<<function display_treemap_interactive>>=
let display_treemap_interactive
 ?algo
 ?drawing_file_hook
 ?(info_of_file_under_cursor=(fun _ _ -> ""))
 treemap
 dim
  =
  let dim = ref dim in
  let matrix_info = ref (
    display_treemap_algo
      ?algo
      ?drawing_file_hook
      treemap
      (!dim.w_view, !dim.h_view)
  )
  in
  while true do
    let status = Graphics.wait_next_event [
        Graphics.Mouse_motion;
        Graphics.Key_pressed;
        Graphics.Button_down;
        Graphics.Button_up;
      ]
    in
    let (x,y) = status.Graphics.mouse_x, status.Graphics.mouse_y in

    if x >= 0 && y >= 0 && x < !dim.w_view && y < !dim.h_view
    then begin

      (* clear the status area *)
      Graphics.set_color Graphics.white;
      Graphics.fill_rect 0 (!dim.h - !dim.h_status) !dim.w (!dim.h);

      Graphics.set_color Graphics.black;
      Graphics.moveto (0 + !dim.w / 2) (!dim.h - (!dim.h_status / 2));

      let info =
        try
          !matrix_info.(x).(y)
        with Invalid_argument(s) ->
          pr2 (spf "pb with coord (%d,%d).  %s" x y s);
          raise (Invalid_argument(s))

      in
      match info with
      | None -> pr2 "Impossible";
      | Some file ->
          let s = info_of_file_under_cursor status file in
          (* draw_string_centered (spf "x = %03d, y = %03d; info = %s" x y s); *)
          Graphics.set_font "-misc-*-*-*-*-12-*-*-*-*-*-*";
          draw_string_centered (spf "%s" s);
    end;

    (* a resize has taken place *)
    let w, h = Graphics.size_x (), Graphics.size_y () in
    if w <> !dim.w || h <> !dim.h
    then begin
      dim := current_dim ~w_legend:!dim.w_legend ~h_status:!dim.h_status;
      Graphics.clear_graph ();
      matrix_info :=
        display_treemap_algo
          ?algo
          ?drawing_file_hook
          treemap
          (!dim.w_view, !dim.h_view);
      (* draw_legend_hook !dim ? *)
    end
  done
@


<<function info_of_file_under_cursor_default>>=

let info_of_file_under_cursor_default = fun status (f, _) ->
  let s = f in
  if status.Graphics.button
  then begin
    pr2 (spf "%s" f);
    (* Sys.command (spf "/home/pad/packages/Linux/bin/emacsclient -n %s" f) +> ignore; *)
  end;
  if status.Graphics.keypressed (* Graphics.key_pressed () *)
  then raise (UnixExit 0);
  s
@


\section{JSON Reader}
\label{sec:xxx}

\begin{verbatim}
$ find .
.
./a
./a/c
./a/c/foo.txt
./a/foobar.txt
./b
./b/bar.txt
./b/bar2.txt
\end{verbatim}

\begin{verbatim}
$ ./treemap_viewer -algorithm squarified  examples/treemap/ex.json
\end{verbatim}

\begin{figure*}\begin{center}
\includegraphics[width=8cm]{pics/treemap_ex_json}
\caption{Treemap from [[ex.json]]}\label{fig:treemap-ex}
\end{center}\end{figure*}



<<ex.json>>=
{
  "kind": "Node",     "label": ".",
  "children": [
    {
      "kind": "Node",   "label": "a/",
      "children": [
        {
          "kind": "Node",  "label": "c/",
          "children": [
            {
              "kind": "Leaf", "size": 2, "color": "purple",
              "label": "a/c/foo.txt"
            }
          ]
        },
        {
          "kind": "Leaf", "size": 1, "color": "HotPink2",
          "label": "a/foobar.txt"
        }
      ]
    },
    {
      "kind": "Node", "label": "b/",
      "children": [
        {
          "kind": "Leaf", "size": 1, "color": "azure4",
          "label": "b/bar.txt"
        },
        {
          "kind": "Leaf", "size": 4, "color": "cyan",
          "label": "b/bar2.txt"
        }
] } ] }
@

%(*
% * For the people who want to use the treemap rendering but do not
% * want to write OCaml code (pfff), here is some json reader code.
% *
% * Here is an example generated via:
% *  $ ./ocamltreemap -test_json_of examples/treemap/ex_dirs/
% * {
% *   "kind": "Node",
% *   "label": ".",
% *   "children": [
% *     {
% *       "kind": "Node",
% *       "label": "a",
% *       "children": [
% *         {
% *           "kind": "Node",
% *           "label": "c",
% *           "children": [
% *             {
% *               "kind": "Leaf",
% *               "size": 2,
% *               "color": "LightCyan3",
% *               "label": "examples/treemap/ex_dirs/a/c/foo.txt"
% *             }
% *           ]
% *         },
% *         {
% *           "kind": "Leaf",
% *           "size": 1,
% *           "color": "DodgerBlue4",
% *           "label": "examples/treemap/ex_dirs/a/foobar.txt"
% *         }
% *       ]
% *     },
% *     {
% *       "kind": "Node",
% *       "label": "b",
% *       "children": [
% *         {
% *           "kind": "Leaf",
% *           "size": 1,
% *           "color": "medium turquoise",
% *           "label": "examples/treemap/ex_dirs/b/bar.txt"
% *         },
% *         {
% *           "kind": "Leaf",
% *           "size": 4,
% *           "color": "LemonChiffon2",
% *           "label": "examples/treemap/ex_dirs/b/bar2.txt"
% *         }
% *       ]
% *     }
% *   ]
% * }
% *
% *)


<<signature treemap_of_json>>=
val treemap_of_json:
  Json_type.json_type ->
  (Common.dirname, Common.filename * int) Treemap.treemap
@


<<signature json_of_treemap>>=
val json_of_treemap:
  ('dir, 'file) Treemap.treemap -> Json_type.json_type
@


<<function treemap_of_json>>=
(* cf json_of_treemap_basic below. Just do reverse operation *)
let rec treemap_of_json j =
  match j with
  | J.Object [
      "kind", J.String "Node";
      "label", J.String s;
      "children", J.Array xs;
    ] ->
      let children = xs +> List.map treemap_of_json in

      let sizes = children +> List.map Treemap.size_of_treemap_node in
      let size = Common2.sum sizes in

      let rect = {
        label = s;
        color = Color.black;
        size = size;
      }
      in
      Common2.Node ((rect, s), children)

  | J.Object [
      "kind", J.String "Leaf";
      "size", J.Int size;
      "color", J.String scolor;
      "label", J.String lbl;
    ] ->
      let rect = {
        label = lbl;
        color = Color.color_of_string scolor;
        size = size;
      }
      in
      Common2.Leaf (rect, (lbl, size))

  | _ ->
      failwith "wrong format"
@


<<function json_of_color>>=
let json_of_color c = J.String (Color.string_of_color c)
@


<<function json_of_treemap>>=
(* I was first using ocamltarzan to auto generate the json_of, but it
 * leds to verbosity, so I ended up manually coding it.
 *)
let rec (json_of_treemap: ('a, 'b) Treemap.treemap -> J.json_type)
 = function
  | Common2.Node (((rect, _a), xs)) ->
      let { size = _v_sizeTODO; color = _v_colorTODO; label = v_label } = rect in

      let bnds = [] in

      let children =
        J.Array (List.map json_of_treemap xs)
      in
      let bnd = ("children", children) in
      let bnds = bnd :: bnds in

      let arg = J.String v_label in
      let bnd = ("label", arg) in
      let bnds = bnd :: bnds in

      let arg = J.String "Node" in
      let bnd = ("kind", arg) in
      let bnds = bnd :: bnds in

      J.Object bnds

  | Common2.Leaf (rect, _b) ->
      let { size = v_size; color = v_color; label = v_label } = rect in

      let bnds = [] in
      let arg = J.String v_label in
      let bnd = ("label", arg) in
      let bnds = bnd :: bnds in
      let arg = json_of_color v_color in
      let bnd = ("color", arg) in
      let bnds = bnd :: bnds in
      let arg = J.Int v_size in
      let bnd = ("size", arg) in
      let bnds = bnd :: bnds in

      let arg = J.String "Leaf" in
      let bnd = ("kind", arg) in
      let bnds = bnd :: bnds in
      J.Object bnds
@


<<function test_json_of>>=
let test_json_of dir =
  let maxc = 256 in
  let tree = tree_of_dirs_or_files
    ~file_hook:(fun file -> Common2.filesize file) [dir] in
  let treemap = treemap_of_tree
    ~size_of_leaf:(fun (_f, intleaf) -> intleaf)
    ~color_of_leaf:(fun (_f, _intleaf) ->
      Color.rgb (Random.int maxc) (Random.int maxc) (Random.int maxc)
    )
    ~label_of_dir:(fun dir -> Filename.basename dir)
    ~label_of_file:(fun (f, _intleaf) -> f)
    tree
  in
  let json =
    json_of_treemap
      (*
      (fun _ -> J.Null)
      (fun _ -> J.Null)
      *)
      treemap in
  let s = Json_out.string_of_json json in
  pr s
@


<<function test_of_json>>=
let test_of_json file =
    let json = Json_in.load_json file in
    let treemap = treemap_of_json json in

    let json2 = json_of_treemap treemap in
    let s = Json_out.string_of_json json2 in
    pr s
@


<<treemap_json actions>>=
  "-test_json_of", "<dir>",
  Common.mk_action_1_arg test_json_of;
  "-test_of_json", "<file>",
  Common.mk_action_1_arg test_of_json;
@



\section{Applications}
\label{sec:xxx}

\subsection{Disk statistics}

KDirStat
WindowsStat
MacosStat

<<signature tree_of_dir>>=
type directory_sort =
  | NoSort
  | SortDirThenFiles
  | SortDirAndFiles
  | SortDirAndFilesCaseInsensitive
val follow_symlinks: bool ref
@

<<function tree_of_dir>>=
(*
let tree_of_dir2
  ?(filter_file=(fun _ -> true))
  ?(filter_dir=(fun _ -> true))
  ?(sort=SortDirAndFilesCaseInsensitive)
  ~file_hook
  dir
 =
  let rec aux dir =

    let subdirs =
      Common2.readdir_to_dir_list dir +> List.map (Filename.concat dir) in
    let files =
      Common2.readdir_to_file_list dir +> List.map (Filename.concat dir) in

    let subdirs =
      subdirs +> Common.map_filter (fun dir ->
        if filter_dir dir
        then Some (dir, aux dir)
        else None
      )
    in
    let files =
      files +> Common.map_filter (fun file ->
        if filter_file file
        then Some (file, (Leaf (file, file_hook file)))
        else None
      )
    in

    let agglomerated =
      match sort with
      | NoSort -> subdirs ++ files
      | SortDirThenFiles ->
          Common.sort_by_key_lowfirst subdirs ++
          Common.sort_by_key_lowfirst files
      | SortDirAndFiles ->
          Common.sort_by_key_lowfirst (subdirs ++ files)
      | SortDirAndFilesCaseInsensitive ->
          let xs = (subdirs ++ files) +> List.map (fun (s, x) ->
            lowercase s, x
          )
          in
          Common.sort_by_key_lowfirst xs
    in
    let children = List.map snd agglomerated in
    Node(dir, children)
  in
  aux dir
*)
@


\subsection{Source code architecture visualization}

archi

linux fekete.

sgrep/slayer plugin, slayer :)

\subsection{Code coverage (tests, deadcode, etc)}


\subsection{Version-control visualization}

git

SeeSoft. Work by UIUC on cvs and visualization.
Also video of evolution of java code.

\section{Conclusion}

Hope you like it.

\cite{treemap-list-software-wikipedia}
\appendix


\section{Extra Code}


\subsection{[[treemap.mli]]}



<<treemap.mli>>=
open Figures

(* tree -> treemap -> treemap_rendering *)

type ('dir, 'file) tree =
  ('dir, 'file) Common2.tree

<<type treemap>>

type treemap_rendering = treemap_rectangle list
 and treemap_rectangle = {
   tr_rect: rectangle;
   tr_color: int (* Simple_color.color *);
   tr_label: string;
   tr_depth: int;
   tr_is_node: bool;
 }



<<type screen_dim>>

val xy_ratio : float

val rect_ortho: rectangle

<<type algorithm>>

<<type layout_func>>

<<signature algos>>

(* treemap -> treemap_rendering *)
val render_treemap:
  ?algo:algorithm ->
  ?big_borders:bool ->
  ('dir, 'file) treemap -> treemap_rendering

<<signature treemap_of_tree>>

<<signature tree_of_dir>>

(* paths -> tree (see also Common.tree2_of_files) *)
val tree_of_dirs_or_files:
  ?filter_file:(Common.filename -> bool) ->
  ?filter_dir:(Common.dirname -> bool) ->
  ?sort:directory_sort ->
  file_hook:(Common.filename -> 'a) ->
  Common2.path list ->
  (Common.dirname, Common.filename * 'a) tree



val remove_singleton_subdirs:
  (Common.dirname, Common.filename * 'a) tree ->
  (Common.dirname, Common.filename * 'a) tree


(* internal functions *)
<<signature treemap accessors>>

<<signature algorithm accessors>>

(* tests *)
<<signature tree and treemap examples>>

val actions : unit -> Common.cmdline_actions

@







<<signature treemap_of_tree>>=
(* tree -> treemap (see also treemap_json.ml) *)
val treemap_of_tree :
  size_of_leaf:('file -> int) ->
  color_of_leaf:('file -> Simple_color.color) ->
  ?label_of_file:('file -> string) ->
  ?label_of_dir:('dir -> string) ->
  ('dir, 'file) tree ->
  ('dir, 'file) treemap
@




<<signature graphic helpers>>=
val info_of_file_under_cursor_default :
  Graphics.status -> (Common.filename * 'a) -> string

val current_dim:
  w_legend:int -> h_status:int -> screen_dim
@



<<signature treemap accessors>>=
val color_of_treemap_node :
  ('a, 'b) treemap -> Simple_color.color
val size_of_treemap_node :
  ('a, 'b) treemap  -> int
@


<<signature algorithm accessors>>=
val s_of_algo: algorithm -> string
val algo_of_s: string -> algorithm
@



<<signature test treemap functions>>=
val test_treemap_manual : unit -> unit
val test_treemap_tree : algorithm -> int -> unit
val test_treemap_dir : string -> algorithm -> unit
@


\subsection{[[treemap.ml]]}




<<treemap.ml>>=
<<Facebook copyright>>
open Common2

module F = Figures
open Figures

module Color = Simple_color

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

type ('dir, 'file) tree = ('dir, 'file) Common2.tree

<<type treemap>>
  (* with tarzan *)

<<type algorithm>>

<<variable algos>>

<<type screen_dim>>


<<type rectangle1>>

(* A cleaner rectangle type, not tied to the seminal paper design decisions *)

(* Now that my treemap visualizer uses a minimap, it does not completely
 * use the full width.
 * old: was 16/9 = 1.777777
 *)
let xy_ratio = 1.71

(* The dimentions are in a  [0.0-1.0] range for y and [0.0-xyratio] for x,
 * where xyratio is used to cope with most 16/9 screens.
  *)
let rect_ortho =
  { p = {x = 0.0; y = 0.0; }; q = { x = xy_ratio; y = 1.0} }

(* the dimentions are in a  [0.0-1.0] range
 * opti? have a quad tree instead of a list, can improve search time
 *)
type treemap_rendering = treemap_rectangle list
 and treemap_rectangle = {
   tr_rect: rectangle;
   tr_color: int (* Simple_color.color *);
   tr_label: string;
   tr_depth: int;
   tr_is_node: bool;
 }
 (* with tarzan *)

<<type layout_func>>


(*****************************************************************************)
(* Accessors *)
(*****************************************************************************)

<<function treemap accessors>>

<<function algorithm accessors>>

(*****************************************************************************)
(* Treemap Helpers *)
(*****************************************************************************)

<<function treemap_of_tree>>

let treemap_of_tree ~size_of_leaf  ~color_of_leaf
    ?label_of_file ?label_of_dir tree =
 Common.profile_code "Treemap.treemap_of_tree" (fun () ->
   treemap_of_tree2 ~size_of_leaf  ~color_of_leaf
     ?label_of_file ?label_of_dir tree)

(*****************************************************************************)
(* Treemap algorithms *)
(*****************************************************************************)

(*---------------------------------------------------------------------------*)
(* basic algorithm *)
(*---------------------------------------------------------------------------*)

(* display_treemap and display_treemap_generic are now in
 * in treemap_graphics.ml, because of Graphics dependency.
 *)

(*---------------------------------------------------------------------------*)
(* slice and dice algorithm layout *)
(*---------------------------------------------------------------------------*)

<<layout slice and dice>>

(*---------------------------------------------------------------------------*)
(* squarified algorithm *)
(*---------------------------------------------------------------------------*)

<<squarified examples>>

<<type split>>

<<function ratio_rect_dim>>

<<function worst>>

<<function layout>>

(* the main algorithmic part of squarifying *)
<<function squarify_orig>>

<<function squarify>>



<<function test_squarify>>


<<layout squarify>>


(*---------------------------------------------------------------------------*)
(* Ordered squarified algorithm *)
(*---------------------------------------------------------------------------*)

<<ordered examples>>

<<type pivotized>>

<<function compute_rects_pivotized>>

<<function balayer_right_wrong>>

<<function orderify_children>>

<<function test_orderify>>


<<layout ordered>>

(*---------------------------------------------------------------------------*)
(* cushion algorithm *)
(*---------------------------------------------------------------------------*)

(* TODO *)

(*---------------------------------------------------------------------------*)
(* frontend *)
(*---------------------------------------------------------------------------*)

let layoutf_of_algo algo =
  match algo with
  | Classic -> slice_and_dicing_layout
  | Squarified -> squarify_layout
  | SquarifiedNoSort -> squarify_layout_no_sort_size
  | Ordered pivotf -> ordered_layout ~pivotf


let render_treemap_algo2 = fun ?(algo=Classic) ?(big_borders=false) treemap ->
  let flayout = layoutf_of_algo algo in

  let treemap_rects = ref [] in

  let rec aux_treemap root rect ~depth =
    let (p,q) = rect.p, rect.q in

    if not (valid_rect rect)
    then () (* TODO ? warning ? *)
    else

    (match root with
    | Leaf (tnode, _fileinfo) ->
        let color = color_of_treemap_node root in

        Common.push {
          tr_rect = rect;
          tr_color = color;
          tr_label = tnode.label;
          tr_depth = depth;
          tr_is_node = false;
        } treemap_rects;


    | Node (mode, children) ->

       (* let's draw some borders. Far better to see the structure. *)
        Common.push {
          tr_rect = rect;
          tr_color = Color.black;
          tr_label = (fst mode).label;
          tr_depth = depth;
          tr_is_node = true;
        } treemap_rects;

        (* does not work, weird *)
        let border =
          if not big_borders then
          match depth with
          | 1 -> 0.0
          | 2 -> 0.003
          | 3 -> 0.001
          | 4 -> 0.0005
          | 5 -> 0.0002
          | _ -> 0.0
          else
          match depth with
          | 1 -> 0.0
          | 2 -> 0.003
          | 3 -> 0.0015
          | 4 -> 0.0010
          | 5 -> 0.0008
          | 6 -> 0.0005
          | _ -> 0.0002
        in
        let p = {
          x = p.x +. border;
          y = p.y +. border;
        }
        in
        let q = {
          x = q.x -. border;
          y = q.y -. border;
        }
        in
        (* todo? can overflow ... check still inside previous rect *)
        let rect = { p = p; q = q } in

        let children' =
          children +> List.map (fun child ->
            float_of_int (size_of_treemap_node child),
            child
          )
        in

        let rects_with_info =
          (* generic call *)
          flayout children' depth rect
        in
        (* less: assert rects_with_info are inside rect ? *)

        rects_with_info +> List.iter (fun (_x, child, rect) ->
          aux_treemap child rect ~depth:(depth + 1)
        );


    )
  in
  aux_treemap treemap rect_ortho ~depth:1;

  List.rev !treemap_rects

let render_treemap ?algo ?big_borders x =
  Common.profile_code "Treemap.render_treemap" (fun () ->
    render_treemap_algo2 ?algo ?big_borders x)

(*****************************************************************************)
(* Main display function  *)
(*****************************************************************************)

(* now in treemap_graphics.ml *)

(*****************************************************************************)
(* Source converters  *)
(*****************************************************************************)

type directory_sort =
  | NoSort
  | SortDirThenFiles
  | SortDirAndFiles
  | SortDirAndFilesCaseInsensitive

let follow_symlinks = ref false

<<function tree_of_dir>>


(* specialized version *)
let tree_of_dir3
  ?(filter_file=(fun _ -> true))
  ?(filter_dir=(fun _ -> true))
  ?(sort=SortDirAndFilesCaseInsensitive)
  ~file_hook
  dir
 =
  if sort <> SortDirAndFilesCaseInsensitive
  then failwith "Only SortDirAndFilesCaseInsensitive is handled";

  let rec aux dir =

    let children = Sys.readdir dir in
    let children = Array.map (fun x -> Common2.lowercase x, x) children in

    Array.fast_sort (fun (a1, _b1) (a2, _b2) -> compare a1 a2) children;

    let res = ref [] in

    children +> Array.iter (fun (_, f) ->
      let full = Filename.concat dir f in

      let stat = Common2.unix_lstat_eff full in

      match stat.Unix.st_kind with
      | Unix.S_REG ->
          if filter_file full
          then Common.push (Leaf (full, file_hook full)) res
      | Unix.S_DIR ->
          if filter_dir full
          then Common.push (aux full) res
      | Unix.S_LNK ->
          if !follow_symlinks then
          (try
          (match (Unix.stat full).Unix.st_kind with
          | Unix.S_REG ->
              if filter_file full
              then Common.push (Leaf (full, file_hook full)) res
          | Unix.S_DIR ->
              if filter_dir full
              then Common.push (aux full) res
          | _ -> ()
          )
          with Unix.Unix_error _ ->
            pr2 (spf "PB stat link at %s" full);
          )
          else ()
      | _ -> ()
    );
    Node(dir, List.rev !res)
  in
  aux dir


let tree_of_dir ?filter_file ?filter_dir ?sort ~file_hook a =
  Common.profile_code "Treemap.tree_of_dir" (fun () ->
    tree_of_dir3 ?filter_file ?filter_dir ?sort ~file_hook a)

let tree_of_dir_or_file ?filter_file ?filter_dir ?sort ~file_hook path =
 if Common2.is_directory path
 then tree_of_dir ?filter_file ?filter_dir ?sort ~file_hook path
 else Leaf (path, file_hook path)



(* Some nodes may have stuff in common that we should factor.
 * todo: factorize code with Common.tree_of_files
 *)
let add_intermediate_nodes root_path nodes =
  let root = chop_dirsymbol root_path in
  if not (Common2.is_absolute root)
  then failwith ("must pass absolute path, not: " ^ root);

  let root = Common.split "/" root in

  (* extract dirs and file from file, e.g. ["home";"pad"], "__flib.php", path *)
  let xs = nodes +> List.map (fun x ->
    match x with
    | Leaf (file, _) -> Common2.dirs_and_base_of_file file, x
    | Node (dir, _) -> Common2.dirs_and_base_of_file dir, x
  )
  in
  (* remove the root part *)
  let xs = xs +> List.map (fun ((dirs, base), node) ->
    let n = List.length root in
    let (root', rest) =
      Common2.take n dirs,
      Common2.drop n dirs
    in
    assert(root' =*= root);
    (rest, base), node
  )
  in
  (* now ready to build the tree recursively *)
  let rec aux current_root xs =
    let files_here, rest =
      xs +> List.partition (fun ((dirs, _base), _) -> null dirs)
    in
    let groups =
      rest +> group_by_mapped_key (fun ((dirs, _base),_) ->
        (* would be a file if null dirs *)
        assert(not (null dirs));
        List.hd dirs
      ) in

    let nodes =
      groups +> List.map (fun (k, xs) ->
        let xs' = xs +> List.map (fun ((dirs, base), node) ->
          (List.tl dirs, base), node
        )
        in
        let dirname = Filename.concat current_root k in
        Node (dirname, aux dirname xs')
      )
    in
    let leaves = files_here +> List.map (fun ((_dir, _base), node) ->
      node
    ) in
    nodes @ leaves
  in
  aux root_path xs


let tree_of_dirs_or_files2 ?filter_file ?filter_dir ?sort ~file_hook paths =
  match paths with
  | [] -> failwith "tree_of_dirs_or_files: empty list"
  | [x] -> tree_of_dir_or_file ?filter_file ?filter_dir ?sort ~file_hook x
  | xs ->
      let nodes =
        xs +> List.map (fun x ->
          tree_of_dir_or_file ?filter_file ?filter_dir ?sort ~file_hook x
        )
      in
      let root = Common2.common_prefix_of_files_or_dirs xs in
      let nodes = add_intermediate_nodes root nodes in
      Node (root, nodes)

let tree_of_dirs_or_files ?filter_file ?filter_dir ?sort ~file_hook x =
  Common.profile_code "Treemap.tree_of_dirs_or_files" (fun () ->
    tree_of_dirs_or_files2 ?filter_file ?filter_dir ?sort ~file_hook x
  )

(* Some software, especially java have often a long chain
 * of single directory, like org/eclipse/...
 * which then introduce extra depth in the treemap which leads
 * to overlapping labels and very small labels for the actual
 * childrens. This function removes those intermediate singleton
 * sub directories.
 *)
let rec remove_singleton_subdirs tree =
  match tree with
  | Leaf _x -> tree
  | Node (x, [Node (_y, ys)]) ->
      (* todo? merge x and y ? *)
      remove_singleton_subdirs (Node (x, ys))
  | Node (x, ys) ->
      Node (x, List.map remove_singleton_subdirs ys)

(*****************************************************************************)
(* Testing *)
(*****************************************************************************)

<<concrete rectangles example>>



<<variable tree_ex_shneiderman_1991>>

<<variable tree_ex_wijk_1999>>

<<variable treemap_ex_ordered_2001>>









(*****************************************************************************)
(* Actions *)
(*****************************************************************************)

let actions () = [
  <<treemap actions>>
]
@


<<function treemap accessors>>=
let color_of_treemap_node x =
  match x with
  | Node (({color = c; _}, _), _) -> c
  | Leaf (({color = c; _}, _)) -> c

let size_of_treemap_node x =
  match x with
  | Node (({size = s; _}, _), _) -> s
  | Leaf (({size = s; _}, _)) -> s
@




<<function current_dim>>=
let current_dim ~w_legend ~h_status =

  let w, h = Graphics.size_x (), Graphics.size_y () in

  let w_view, h_view =
    Graphics.size_x () - w_legend,
    Graphics.size_y () - h_status
  in

  {
    w = w;
    h = h;
    w_view = w_view;
    h_view = h_view;
    h_status = h_status;
    w_legend = w_legend;
  }
@




<<function algorithm accessors>>=
let algo_of_s algo =
  match algo with
  | "classic" -> Classic
  | "squarified" -> Squarified
  | "squarified_no_sort" -> SquarifiedNoSort
  | "ordered" -> Ordered PivotBySize
  | "ordered_by_size" -> Ordered PivotBySize
  | "ordered_by_middle" -> Ordered PivotByMiddle


  | "default" -> Ordered PivotByMiddle
  | _ -> failwith "not a valid algorithm"

let s_of_algo algo =
  match algo with
  | Classic -> "classic"
  | Squarified -> "squarified"
  | SquarifiedNoSort -> "squarified_no_sort"
  | Ordered PivotBySize -> "ordered_by_size"
  | Ordered PivotByMiddle -> "ordered_by_middle"
@


<<graphic helpers>>=
let draw_string_centered str =
  let (w, h) = Graphics.text_size str in
  Graphics.rmoveto (- w / 2) (- h / 2);
  Graphics.draw_string str

let draw_text_center_rect_float_ortho ((x1, y1),(x2, y2)) color (w, h) str =
  let w = float_of_int w in
  let h = float_of_int h in

  let x1, y1 = int_of_float (x1 *. w), int_of_float (y1 *. h) in
  let x2, y2 = int_of_float (x2 *. w), int_of_float (y2 *. h) in

  let w = (x2 - x1) in
  let h = (y2 - y1) in

  Graphics.set_color color;
  Graphics.moveto (x1 + w / 2 ) (y1 + h / 2);
  let (w2, h2) = Graphics.text_size str in
  if str <> "" && w2 < w && h2 < h
  then begin
    (* does not work :( Graphics.set_text_size 40; *)
    draw_string_centered str;
    (*
    pr2 str;
    pr2_gen (x1, y1);
    *)
  end;
  ()


let draw_label rect (w, h) depth label ~is_dir =
  let (p, q) = rect.p, rect.q in

  let font_label_opt =
    if is_dir then
      match depth with
      | 1 -> None
      | 2 -> Some  "-misc-*-*-*-*-20-*-*-*-*-*-*"
      | 3 -> Some  "-misc-*-*-*-*-10-*-*-*-*-*-*"
      | 4 -> Some "-misc-*-*-*-*7-*-*-*-*-*-*"
      | _ -> None
    else
      Some "-misc-*-*-*-*-6-*-*-*-*-*-*"
  in

  font_label_opt +> Common.do_option (fun font ->
    Graphics.set_font font;

    draw_text_center_rect_float_ortho
      ((p.x, p.y),
      (q.x, q.y))
      (if is_dir then Graphics.black else Color.c "grey37")
      (w, h)
      label
  )
@


<<function treemap_of_tree>>=
let treemap_of_tree2
    ~size_of_leaf
    ~color_of_leaf
    ?(label_of_file=(fun _ -> ""))
    ?(label_of_dir=(fun _ -> ""))
    tree =
  let rec aux tree =
    match tree with
    | Node (nodeinfo, xs) ->
        let sizeme = ref 0 in

        let child = List.map (fun x ->
          let (res, size) = aux x in
          sizeme := !sizeme + size;
          res
        ) xs
        in
        (* old:
         * let children = xs +> List.map aux in
         * let child = children +> List.map fst in
         * let sizes = children +> List.map snd in
         * let sizeme = Common.sum sizes in
         *)
        let sizeme = !sizeme in
        Node((
          {
            size = sizeme;
            color = Color.black; (* TODO ? nodes have colors ? *)
            label = label_of_dir nodeinfo;
          }, nodeinfo),
            child), sizeme
    | Leaf leaf ->
        let sizeme = size_of_leaf leaf in
        let nodeinfo = leaf in
        Leaf((
          {
            size = sizeme;
            color = color_of_leaf leaf;
            label = label_of_file leaf;
          }, nodeinfo)
        ), sizeme
  in
  let (tree, _size) = aux tree in
  tree
@












<<concrete rectangles example>>=
(* src: python treemap.py
 * lower, upper, rgb
 *)
let treemap_rectangles_ex = [
 [0.0, 0.0], [1.0, 1.0],                                                                 (0.17778372236496054, 0.75183542244426871, 0.77892130219255096);
 [0.0, 0.0], [0.27659574468085107, 1.0],                                                 (0.54757582213226441, 0.945582381819014, 0.26427761420055917);
 [0.0, 0.0], [0.27659574468085107, 0.38461538461538464],                                 (0.71931501307446211, 0.95905644995588246, 0.28633110533256656);
 [0.0, 0.38461538461538464], [0.27659574468085107, 1.0],                                 (0.29508972521695809, 0.35521829137775873, 0.46070336222733932);
 [0.0, 0.38461538461538464], [0.10372340425531915, 1.0],                                 (0.51529552034735771, 0.53725734991812635, 0.22430742368105949);
 [0.10372340425531915, 0.38461538461538464], [0.27659574468085107, 1.0],                 (0.43861905319415506, 0.16281118710897469, 0.60250203640050937);
 [0.27659574468085107, 0.0], [0.36170212765957449, 1.0],                                 (0.3743827201120038, 0.07170428778373239, 0.09006244270341246);
 [0.36170212765957449, 0.0], [0.8936170212765957, 1.0],                                  (0.39117531981521536, 0.16579633978705666, 0.63690597944460248);
 [0.36170212765957449, 0.0], [0.8936170212765957, 0.20000000000000001],                  (0.34982099039431447, 0.54618822154424429, 0.19282777912183513);
 [0.36170212765957449, 0.20000000000000001], [0.8936170212765957, 0.28000000000000003],  (0.14570785913376116, 0.88033416430670342, 0.51911403487550056);
 [0.36170212765957449, 0.28000000000000003], [0.8936170212765957, 0.76000000000000001],  (0.79691567717907263, 0.3307536109585284, 0.95607296382731199);
 [0.36170212765957449, 0.28000000000000003], [0.45035460992907805, 0.76000000000000001], (0.7038680786604008, 0.12714028216462059, 0.17131117338368551);
 [0.45035460992907805, 0.28000000000000003], [0.58333333333333337, 0.76000000000000001], (0.036414279679915174, 0.94100891978030599, 0.017007582879843386);
 [0.58333333333333337, 0.28000000000000003], [0.8936170212765957, 0.76000000000000001],  (0.63659306932350279, 0.25303150185397794, 0.81066700006123815);
 [0.58333333333333337, 0.28000000000000003], [0.8936170212765957, 0.48571428571428577],  (0.38368601825375115, 0.083946154840038423, 0.048274714595522017);
 [0.58333333333333337, 0.48571428571428577], [0.8936170212765957, 0.62285714285714289],  (0.70513207607633877, 0.95785105976069096, 0.87735329563400943);
 [0.58333333333333337, 0.62285714285714289], [0.8936170212765957, 0.76000000000000001],  (0.80565735169264896, 0.75578523763882166, 0.10757369310766951);
 [0.36170212765957449, 0.76000000000000001], [0.8936170212765957, 1.0],                  (0.57042872206220896, 0.9335301149492965, 0.86254084187238389);
 [0.36170212765957449, 0.76000000000000001], [0.62765957446808507, 1.0],                 (0.31530318311042171, 0.97066142447913661, 0.93180609525183578);
 [0.62765957446808507, 0.76000000000000001], [0.8936170212765957, 1.0],                  (0.18330061581424317, 0.82234170300788867, 0.38303955663618716);
 [0.8936170212765957, 0.0], [1.0, 1.0],                                                    (0.20641218447120302, 0.35715481613716149, 0.86620796882602547);
 [0.8936170212765957, 0.0], [1.0, 0.59999999999999998],                                    (0.7942020522649591, 0.27351921049542915, 0.86191731793444748);
 [0.8936170212765957, 0.59999999999999998], [1.0, 1.0],                                  (0.27214488578650742, 0.41635201268319189, 0.1301335726270938);
]
@


<<function test_treemap_manual>>=
(* test draw_rect_treemap_float_ortho *)
let test_treemap_manual () =
  Graphics.open_graph " 640x640";
  Graphics.set_color (Graphics.rgb 1 1 1);
  let w, h = Graphics.size_x (), Graphics.size_y () in

  treemap_rectangles_ex +> List.iter (fun (upper, lower, (r,g,b)) ->
    match upper, lower with
    | [x1, y1], [x2, y2] ->
        let maxc = float_of_int 256 in
        let (r,g,b) =
          int_of_float (r *. maxc),
          int_of_float (g *. maxc),
          int_of_float (b *. maxc)
        in
        let color = Graphics.rgb (r) (g) (b) in

        draw_rect_treemap_float_ortho ((x1, y1),(x2, y2)) color (w, h)
        +> ignore
    | _ -> failwith "wront format"
  );
  Common.pause();
  ()
@



<<function test_treemap>>=
let test_treemap algorithm treemap =
  Graphics.open_graph " 640x640";
  Graphics.set_color (Graphics.rgb 1 1 1);
  let w, h = Graphics.size_x (), Graphics.size_y () in

  Graphics.set_line_width 2;

  display_treemap_algo ~algo:algorithm treemap (w, h) +> ignore;
  while true do
    let status = Graphics.wait_next_event [
        Graphics.Key_pressed;
      ]
    in
    if status.Graphics.keypressed (* Graphics.key_pressed () *)
    then raise (UnixExit 0);
  done;
  (* old: pause (); *)
  ()
@


<<function test_treemap_tree>>=
let test_treemap_tree algorithm ex =
  let maxc = 256 in

  let tree =
    match ex with
    | 1 -> tree_ex_shneiderman_1991
    | 2 -> tree_ex_wijk_1999
    | _ -> raise Impossible
  in

  let treemap = treemap_of_tree
    ~size_of_leaf:(fun intleaf -> intleaf)
    ~color_of_leaf:(fun intleaf ->
      Graphics.rgb (Random.int maxc) (Random.int maxc) (Random.int maxc)
    )
    ~label_of_file:(fun intleaf -> i_to_s intleaf)
    tree
  in
  test_treemap algorithm treemap
@


<<function test_treemap_dir>>=
let test_treemap_dir dir algo =

  let w_view_hint, h_view_hint = 640, 640 in
  let h_status = 30 in

  Graphics.open_graph (spf " %dx%d" w_view_hint (h_view_hint+ h_status));
  Graphics.set_color (Graphics.rgb 1 1 1);
  let w_view, h_view =
    Graphics.size_x (),
    Graphics.size_y () - h_status
  in
  let w, h = Graphics.size_x (), Graphics.size_y () in

  let maxc = 256 in
  let dim = {
    w = w;
    h = h;
    w_view = w_view;
    h_view = h_view;
    h_status = h_status;
    w_legend = 10;
  }
  in

  (* work ? Graphics.set_line_width 2; *)

  let tree =
    tree_of_dir ~file_hook:(fun file ->
      file, Common.filesize file
    )
      dir
  in

  let treemap = treemap_of_tree
    ~size_of_leaf:(fun (f, intleaf) -> intleaf)
    ~color_of_leaf:(fun (f, intleaf) ->
      Graphics.rgb (Random.int maxc) (Random.int maxc) (Random.int maxc)
    )
    ~label_of_dir:(fun dir -> basename dir)
    tree
  in

  display_treemap_interactive
    ~algo
    treemap
    dim
    ~info_of_file_under_cursor:(fun status (f, size) ->
      let s = f in
      if status.Graphics.button
      then begin
        pr2 (spf "%s" f);
        Sys.command (spf "/home/pad/packages/Linux/bin/emacsclient -n %s" f) +> ignore;
      end;

      if status.Graphics.keypressed (* Graphics.key_pressed () *)
      then raise (UnixExit 0);
      s
    );


  ()
@


<<treemap actions>>=
  "-test_squarify", "<>",
  Common.mk_action_0_arg (test_squarify);
  "-test_orderify", "<>",
  Common.mk_action_0_arg (test_orderify);
@


\subsection{[[treemap_json.mli]]}


<<treemap_json.mli>>=

<<signature treemap_of_json>>

<<signature json_of_treemap>>

val json_of_treemap_rendering:
  Treemap.treemap_rendering -> Json_type.json_type

val actions : unit -> Common.cmdline_actions

@

\subsection{[[treemap_json.ml]]}

<<treemap_json.ml>>=
<<Facebook copyright>>
open Common

module J = Json_type

open Treemap
open Figures

module Color = Simple_color

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Json -> Treemap *)
(*****************************************************************************)

<<function treemap_of_json>>

(*****************************************************************************)
(* Treemap -> Json *)
(*****************************************************************************)

<<function json_of_color>>

<<function json_of_treemap>>


(*****************************************************************************)
(* Treemap rendering *)
(*****************************************************************************)

let rec vof_rectangle { p = v_p; q = v_q } =
  let bnds = [] in
  let arg = vof_point v_q in
  let bnd = ("q", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_point v_p in
  let bnd = ("p", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds
and vof_point { x = v_x; y = v_y } =
  let bnds = [] in
  let arg = Ocaml.vof_float v_y in
  let bnd = ("y", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_float v_x in
  let bnd = ("x", arg) in let bnds = bnd :: bnds in Ocaml.VDict bnds

let rec vof_treemap_rendering v = Ocaml.vof_list vof_treemap_rectangle v
and
  vof_treemap_rectangle {
                          tr_rect = v_tr_rect;
                          tr_color = v_tr_color;
                          tr_label = v_tr_label;
                          tr_depth = v_tr_depth;
                          tr_is_node = v_tr_is_node;
                        } =
  let bnds = [] in
  let arg = Ocaml.vof_bool v_tr_is_node in
  let bnd = ("tr_is_node", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_int v_tr_depth in
  let bnd = ("tr_depth", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_string v_tr_label in
  let bnd = ("tr_label", arg) in
  let bnds = bnd :: bnds in
  let arg = Ocaml.vof_int v_tr_color in
  let bnd = ("tr_color", arg) in
  let bnds = bnd :: bnds in
  let arg = vof_rectangle v_tr_rect in
  let bnd = ("tr_rect", arg) in
  let bnds = bnd :: bnds in
  Ocaml.VDict bnds


let json_of_treemap_rendering rendering =
  let v = vof_treemap_rendering rendering in
  Ocaml.json_of_v v

(*****************************************************************************)
(* Testing *)
(*****************************************************************************)
<<function test_json_of>>

<<function test_of_json>>


(*****************************************************************************)
(* Actions *)
(*****************************************************************************)

let actions () = [
<<treemap_json actions>>

]

@

\subsection{[[treemap_graphics.mli]]}

<<treemap_graphics.mli>>=

open Treemap

(* seminal code and algorithm *)
<<signature display_treemap>>

<<signature display_treemap_algo>>

(* main entry point *)
<<signature display_treemap_interactive>>

<<signature graphic helpers>>

<<signature test treemap functions>>

@

\subsection{[[treemap_graphics.ml]]}

<<treemap_graphics.ml>>=
<<Facebook copyright>>

open Common

open Treemap

module Color = Simple_color

module F = Figures

(*****************************************************************************)
(* Graphics Helpers *)
(*****************************************************************************)

<<function current_dim>>

<<function draw_rect_treemap_float_ortho>>

<<graphic helpers>>

(*****************************************************************************)
(* Treemap Helpers *)
(*****************************************************************************)

<<function update_mat_with_fileinfo>>

(*****************************************************************************)
(* Main display function  *)
(*****************************************************************************)

<<function display_treemap>>


(*---------------------------------------------------------------------------*)
(* generic frontend, taking layout-maker function as a parameter  *)
(*---------------------------------------------------------------------------*)

<<function display_treemap_generic>>


<<function display_treemap_algo>>


<<function display_treemap_interactive>>

<<function info_of_file_under_cursor_default>>

(*****************************************************************************)
(* Testing *)
(*****************************************************************************)

<<function test_treemap_manual>>

<<function test_treemap>>

(* test tree_of_dir *)
<<function test_treemap_dir>>

(* test treemap_of_tree, and display_treemap *)
<<function test_treemap_tree>>

(*****************************************************************************)
(* Actions *)
(*****************************************************************************)

let actions () = [
<<treemap_graphics actions>>
]

@

<<treemap_graphics actions>>=
  "-test_treemap_manual", "<>",
  Common.mk_action_0_arg (test_treemap_manual);

  "-test_treemap", "<algorithm>",
  Common.mk_action_1_arg (fun s ->
    let treemap = treemap_ex_ordered_2001 in
    test_treemap (algo_of_s s) treemap

  );

  "-test_treemap_tree", "<algorithm> <ex>",
  Common.mk_action_2_arg (fun s i ->
    test_treemap_tree (algo_of_s s) (s_to_i i)
  );
  "-test_treemap_dir", "<dir> <algorithm>",
  Common.mk_action_2_arg (fun dir str ->
    test_treemap_dir dir (algo_of_s str)
  );

@


\subsection{[[main_treemap.ml]]}

<<function main_action>>=
let main_action jsonfile =
  let json = Json_in.load_json jsonfile in
  let treemap = Treemap_json.treemap_of_json json in

  let rendering = Treemap.render_treemap_algo treemap in
  let json = Treemap_json.json_of_treemap_rendering rendering in
  let s = Json_out.string_of_json json in
  pr2 s;

  let dim = init_graph !big_screen in

  Treemap_graphics.display_treemap_interactive
    ~algo:!algorithm
    ~info_of_file_under_cursor:Treemap_graphics.info_of_file_under_cursor_default
    treemap dim
  ;
  ()
@


<<treemap_viewer cmdline options>>=
    "-algorithm", Arg.String (fun s ->
      algorithm := Treemap.algo_of_s s;
    ),
    (spf " <algo> (choices are: %s, default = %s"
        (Treemap.algos +> List.map Treemap.s_of_algo +> Common.join ", ")
        (Treemap.s_of_algo !algorithm));

    "-big_screen", Arg.Set big_screen,
    " ";
    "-verbose", Arg.Set verbose,
    " ";
@


<<treemap_viewer flags>>=
let algorithm = ref Treemap.Squarified
let big_screen = ref false

let verbose = ref false
@


<<main_treemap.ml>>=
open Common

(*****************************************************************************)
(* Purpose *)
(*****************************************************************************)

(*****************************************************************************)
(* Flags *)
(*****************************************************************************)

<<treemap_viewer flags>>

(* action mode *)
let action = ref ""

let version = "0.1"

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let init_graph big_screen =

  let w_view_hint, h_view_hint =
    if big_screen
    then
      2300, 1500
    else
      640, 640
  in
  let h_status = 30 in
  let w_legend = 200 in

  Graphics.open_graph
    (spf " %dx%d" (w_view_hint + w_legend) (h_view_hint+ h_status));
  Graphics.set_color (Graphics.rgb 1 1 1);
  let w_view, h_view =
    Graphics.size_x () - w_legend,
    Graphics.size_y () - h_status
  in
  let w, h = Graphics.size_x (), Graphics.size_y () in

  {
    Treemap.w = w;
    h = h;
    w_view = w_view;
    h_view = h_view;
    h_status = h_status;
    w_legend = w_legend;
  }


(*****************************************************************************)
(* Main action *)
(*****************************************************************************)

<<function main_action>>

(*****************************************************************************)
(* The options *)
(*****************************************************************************)

let all_actions () =
 Treemap.actions () @
 Treemap_json.actions () @
 []

let options () =
  [
  <<treemap_viewer cmdline options>>
  ] @
  Common.options_of_actions action (all_actions()) @
  Common.cmdline_flags_devel () @
  Common.cmdline_flags_verbose () @
  Common.cmdline_flags_other () @
  [
  "-version",   Arg.Unit (fun () ->
    pr2 (spf "ocamltreemap version: %s" version);
    exit 0;
  ),
    "  guess what";

  (* this can not be factorized in Common *)
  "-date",   Arg.Unit (fun () ->
    pr2 "version: $Date: 2008/10/26 00:44:57 $";
    raise (Common.UnixExit 0)
    ),
  "   guess what";
  ] @
  []

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

let main () =
  let usage_msg =
    "Usage: " ^ Common.basename Sys.argv.(0) ^
      " [options] <json file> " ^ "\n" ^ "Options are:"
  in
  (* does side effect on many global flags *)
  let args = Common.parse_options (options()) usage_msg Sys.argv in

  (* must be done after Arg.parse, because Common.profile is set by it *)
  Common.profile_code "Main total" (fun () ->

    (match args with

    (* --------------------------------------------------------- *)
    (* actions, useful to debug subpart *)
    (* --------------------------------------------------------- *)
    | xs when List.mem !action (Common.action_list (all_actions())) ->
        Common.do_action !action xs (all_actions())

    | _ when not (Common.null_string !action) ->
        failwith ("unrecognized action or wrong params: " ^ !action)

    (* --------------------------------------------------------- *)
    (* main entry *)
    (* --------------------------------------------------------- *)
    | [x] ->
        main_action x

    (* --------------------------------------------------------- *)
    (* empty entry *)
    (* --------------------------------------------------------- *)
    | [] ->
        Common.usage usage_msg (options());
        failwith "too few arguments"

    | x::y::xs ->
        Common.usage usage_msg (options());
        failwith "too many arguments"
    )
  )

(*****************************************************************************)
let _ =
  Common.main_boilerplate (fun () ->
      main ();
  )

@

\section{Changelog}
\label{sec:changelog}

\section*{Indexes}
\addcontentsline{toc}{section}{Index}

%todo_lp: separate index with letters
%\subsection{Code Chunks}
\nowebchunks

%todo: need special support, cf smldefs
%\subsection{Identifiers}
%\nowebindex

%\chapter{References}
\addcontentsline{toc}{section}{References}


\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming},
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb},
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison},
\url{http://padator.org/software/project-syncweb/readme.txt}


\bibitem[4]{common-pad-manual} Yoann Padioleau,
{\em Commons Pad OCaml Library},
\url{http://padator.org/docs/Commons.pdf}


\bibitem[5]{treemap-wikipedia} Wikipedia,
{\em Treemapping},
\url{http://en.wikipedia.org/wiki/Treemapping}

\bibitem[6]{treemap-history} Ben Shneiderman,
{\em History of Treemap Research},
\url{http://www.cs.umd.edu/hcil/treemap-history/index.shtml}

\bibitem[7]{treemap-market} Martin Wattenberg,
{\em Map of the Market}, 1998,
\url{http://www.smartmoney.com/map-of-the-market/}




\bibitem[8]{treemap-seminal} Ben Shneiderman,
{\em Tree visualization with Tree-maps:
A 2-d space-filling approach History of Treemap Research},
1991,
\url{http://hcil.cs.umd.edu/trs/91-03/91-03.html}

\bibitem[9]{treemap-cushion} Jarke van Wijk, Huub van de Wetering,
{\em Cushion Treemaps: Visualization of Hierarchical Information}, 1999,
\url{TODO}


\bibitem[10]{treemap-squarified} Mark Bruls, Kees Huizing, and Jarke van Wijk,
{\em Squarified Treemaps}, 2000,
\url{www.win.tue.nl/~vanwijk/stm.pdf}

\bibitem[11]{treemap-ordered} Ben Shneiderman and Martin Wattenberg,
{\em Ordered Treemap Layouts}, 2001,
\url{ftp://ftp.cs.umd.edu/pub/hcil/Reports-Abstracts-Bibliography/2001-06html/2001-06.htm}

\bibitem[12]{treemap-list-software-wikipedia} Wikipedia
{\em List of treemapping software},
\url{http://en.wikipedia.org/wiki/List_of_treemapping_software}


% cluster

% xxxStat disk explorer

% SeeSoft and other code visualization


\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
