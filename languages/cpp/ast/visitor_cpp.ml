(* Yoann Padioleau
 *
 * Copyright (C) 2010 Facebook
 * Copyright (C) 2021 R2C
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * version 2.1 as published by the Free Software Foundation, with the
 * special exception on linking described in file license.txt.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
 * license.txt for more details.
 *)

open OCaml
open Ast_cpp

[@@@warning "-26-27"]

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

(* hooks *)
type visitor_in = {
  kexpr : expr vin;
  kstmt : stmt vin;
  kinit : initialiser vin;
  ktypeC : typeC vin;
  kclass_member : class_member vin;
  kparameter : parameter vin;
  kcompound : compound vin;
  kclass_def : class_definition vin;
  kfunc_def : func_definition vin;
  kcpp : cpp_directive vin;
  kdeclaration : decl vin;
  ktoplevel : toplevel vin;
  kinfo : tok vin;
}

and visitor_out = any -> unit
and 'a vin = ('a -> unit) * visitor_out -> 'a -> unit

let default_visitor =
  {
    kexpr = (fun (k, _) x -> k x);
    kparameter = (fun (k, _) x -> k x);
    ktypeC = (fun (k, _) x -> k x);
    kcompound = (fun (k, _) x -> k x);
    kstmt = (fun (k, _) x -> k x);
    kinfo = (fun (k, _) x -> k x);
    kclass_def = (fun (k, _) x -> k x);
    kfunc_def = (fun (k, _) x -> k x);
    kclass_member = (fun (k, _) x -> k x);
    kcpp = (fun (k, _) x -> k x);
    kdeclaration = (fun (k, _) x -> k x);
    ktoplevel = (fun (k, _) x -> k x);
    kinit = (fun (k, _) x -> k x);
  }

let (mk_visitor : visitor_in -> visitor_out) =
 fun vin ->
  (* start of auto generation *)
  (* generated by ocamltarzan with: camlp4o -o /tmp/yyy.ml -I pa/ pa_type_conv.cmo pa_visitor.cmo  pr_o.cmo /tmp/xxx.ml  *)
  let rec v_info x =
    let k _ = () in
    vin.kinfo (k, all_functions) x
  and v_tok v = v_info v
  and v_wrap : 'a. ('a -> unit) -> 'a wrap -> unit =
   fun _of_a (v1, v2) ->
    let v1 = _of_a v1 and v2 = v_info v2 in
    ()
  and v_paren : 'a. ('a -> unit) -> 'a paren -> unit =
   fun _of_a (v1, v2, v3) ->
    let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in
    ()
  and v_brace : 'a. ('a -> unit) -> 'a brace -> unit =
   fun _of_a (v1, v2, v3) ->
    let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in
    ()
  and v_bracket : 'a. ('a -> unit) -> 'a bracket -> unit =
   fun _of_a (v1, v2, v3) ->
    let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in
    ()
  and v_angle : 'a. ('a -> unit) -> 'a angle -> unit =
   fun _of_a (v1, v2, v3) ->
    let v1 = v_tok v1 and v2 = _of_a v2 and v3 = v_tok v3 in
    ()
  and v_name (v1, v2, v3) =
    let v1 = v_option v_tok v1
    and v2 = v_list v_qualifier v2
    and v3 = v_ident_or_op v3 in
    ()
  and v_ident v = v_wrap v_string v
  and v_ident_or_op = function
    | IdIdent v1 ->
        let v1 = v_wrap v_string v1 in
        ()
    | IdOperator (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_wrap v_operator v2 in
        ()
    | IdConverter (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_fullType v2 in
        ()
    | IdDestructor (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_wrap v_string v2 in
        ()
    | IdTemplated (v1, v2) ->
        let v1 = v_ident_or_op v1 and v2 = v_template_arguments v2 in
        ()
  and v_template_arguments v = v_angle (v_list v_template_argument) v
  and v_template_argument v = OCaml.v_either v_fullType v_expression v
  and v_either_ft_or_expr v = OCaml.v_either v_fullType v_expression v
  and v_qualifier = function
    | QClassname v1 ->
        let v1 = v_wrap v_string v1 in
        ()
    | QTemplateId (v1, v2) ->
        let v1 = v_wrap v_string v1 and v2 = v_template_arguments v2 in
        ()
  and v_fullType (v1, v2) =
    let v1 = v_typeQualifiers v1 and v2 = v_typeC v2 in
    ()
  and v_type_ x = v_fullType x
  and v_typeC v =
    let k v = v_typeCbis v in
    vin.ktypeC (k, all_functions) v
  and v_todo_category x = v_wrap v_string x
  and v_pointer_modifier = function
    | Based (v1, v2) ->
        v_tok v1;
        v_paren (v_list v_argument) v2
    | PtrRestrict v1 -> v_tok v1
    | Uptr v1 -> v_tok v1
    | Sptr v1 -> v_tok v1
    | Unaligned v1 -> v_tok v1
  and v_typeCbis = function
    | TPointer (v0, v1, v2) ->
        v_tok v0;
        let v1 = v_fullType v1 in
        v_list v_pointer_modifier v2
    | TReference (v0, v1) ->
        v_tok v0;
        let v1 = v_fullType v1 in
        ()
    | TArray (v1, v2) ->
        let v1 = v_bracket (v_option v_constExpression) v1
        and v2 = v_fullType v2 in
        ()
    | TFunction v1 ->
        let v1 = v_functionType v1 in
        ()
    | EnumDef v1 -> v_enum_definition v1
    | ClassDef v1 ->
        let v1 = v_class_definition v1 in
        ()
    | EnumName (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_name v2 in
        ()
    | ClassName (v1, v2) ->
        let v1 = v_wrap v_structUnion v1 and v2 = v_name v2 in
        ()
    | TypeName v1 ->
        let v1 = v_name v1 in
        ()
    | TypenameKwd (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_type_ v2 in
        ()
    | TypeOf (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_paren v_either_ft_or_expr v2 in
        ()
    | ParenType v1 ->
        let v1 = v_paren v_fullType v1 in
        ()
    | TSized (v1, v2) ->
        let v1 = v_list (v_wrap v_sized_type) v1 and v2 = v_option v_type_ v2 in
        ()
    | TAuto v1 ->
        let v1 = v_tok v1 in
        ()
    | TRefRef (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_type_ v2 in
        ()
    | TPrimitive v1 ->
        let v1 = v_wrap v_primitive_type v1 in
        ()
    | TypeTodo (v1, v2) ->
        let v1 = v_todo_category v1 and v2 = v_list v_type_ v2 in
        ()
  and v_primitive_type = function
    | TVoid -> ()
    | TBool -> ()
    | TChar -> ()
    | TInt -> ()
    | TFloat -> ()
    | TDouble -> ()
  and v_sized_type = function
    | TSigned -> ()
    | TUnsigned -> ()
    | TShort -> ()
    | TLong -> ()
  and v_enum_definition { enum_kind = v1; enum_name = v2; enum_body = v3 } =
    let v1 = v_tok v1
    and v2 = v_option v_name v2
    and v3 = v_brace (v_list v_enum_elem) v3 in
    ()
  and v_enum_elem { e_name = v_e_name; e_val = v_e_val } =
    let arg = v_wrap v_string v_e_name in
    let arg =
      v_option
        (fun (v1, v2) ->
          let v1 = v_tok v1 and v2 = v_constExpression v2 in
          ())
        v_e_val
    in
    ()
  and v_typeQualifiers v = v_list (v_wrap v_type_qualifier) v
  and v_type_qualifier = function
    | Const -> ()
    | Volatile -> ()
    | Restrict -> ()
    | Atomic -> ()
    | Mutable -> ()
    | Constexpr -> ()
    | Constinit -> ()
    | Consteval -> ()
  and v_expression v =
    let k x = v_expressionbis x in
    vin.kexpr (k, all_functions) v
  and v_expr x = v_expression x
  and v_expressionbis = function
    | N v1 ->
        let v1 = v_name v1 in
        ()
    | C v1 ->
        let v1 = v_constant v1 in
        ()
    | Ellipsis v1 ->
        let v1 = v_tok v1 in
        ()
    | Call (v1, v2) ->
        let v1 = v_expression v1 and v2 = v_paren (v_list v_argument) v2 in
        ()
    | CondExpr (v1, t1, v2, t2, v3) ->
        let v1 = v_expression v1 in
        v_tok t1;
        let v2 = v_option v_expression v2 in
        v_tok t2;
        let v3 = v_expression v3 in
        ()
    | Sequence (v1, t1, v2) ->
        let v1 = v_expression v1 in
        v_tok t1;
        let v2 = v_expression v2 in
        ()
    | Assign (v1, v2, v3) ->
        let v1 = v_expression v1
        and v2 = v_assignOp v2
        and v3 = v_expression v3 in
        ()
    | Postfix (v1, v2) ->
        let v1 = v_expression v1 and v2 = v_wrap v_fixOp v2 in
        ()
    | Prefix (v1, v2) ->
        v_wrap v_fixOp v1;
        v_expression v2
    | Unary (v1, v2) ->
        v_wrap v_unaryOp v1;
        v_expression v2
    | Binary (v1, v2, v3) ->
        let v1 = v_expression v1
        and v2 = v_wrap v_binaryOp v2
        and v3 = v_expression v3 in
        ()
    | ArrayAccess (v1, v2) ->
        let v1 = v_expression v1 and v2 = v_bracket v_initialiser v2 in
        ()
    | DotAccess (v1, t, v2) ->
        let v1 = v_expression v1 and t = v_wrap v_dotOp t and v2 = v_name v2 in
        ()
    | DotStarAccess (v1, t, v2) ->
        let v1 = v_expression v1
        and t = v_wrap v_dotOp t
        and v2 = v_expression v2 in
        ()
    | SizeOf (v1, v2) ->
        let v1 = v_tok v1 and v2 = OCaml.v_either v_expr (v_paren v_type_) v2 in
        ()
    | Cast (v1, v2) ->
        let v1 = v_paren v_fullType v1 and v2 = v_expression v2 in
        ()
    | StatementExpr v1 ->
        let v1 = v_paren v_compound v1 in
        ()
    | GccConstructor (v1, v2) ->
        let v1 = v_paren v_fullType v1
        and v2 = v_brace (v_list v_initialiser) v2 in
        ()
    | ConstructedObject (v1, v2) ->
        let v1 = v_fullType v1 and v2 = v_obj_init v2 in
        ()
    | TypeId (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_paren v_either_ft_or_expr v2 in
        ()
    | CplusplusCast (v1, v2, v3) ->
        let v1 = v_wrap v_cast_operator v1
        and v2 = v_angle v_fullType v2
        and v3 = v_paren v_expression v3 in
        ()
    | New (v1, v2, v3, v4, v5) ->
        let v1 = v_option v_tok v1
        and v2 = v_tok v2
        and v3 = v_option (v_paren (v_list v_argument)) v3
        and v4 = v_fullType v4
        and v5 = v_option v_obj_init v5 in
        ()
    | Delete (v1, v2, v3, v4) ->
        let v1 = v_option v_tok v1
        and v2 = v_tok v2
        and v3 = v_option (v_bracket v_unit) v3
        and v4 = v_expr v4 in
        ()
    | Throw (t1, v1) ->
        v_tok t1;
        let v1 = v_option v_expression v1 in
        ()
    | ParenExpr v1 ->
        let v1 = v_paren v_expression v1 in
        ()
    | IdSpecial v1 ->
        let v1 = v_wrap v_special v1 in
        ()
    | Lambda v1 ->
        let v1 = v_lambda_definition v1 in
        ()
    | ParamPackExpansion (v1, v2) ->
        let v1 = v_expr v1 and v2 = v_tok v2 in
        ()
    | FoldExpr x ->
        let v = v_paren v_fold_expr x in
        ()
    | RequiresExpr (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_paren (v_list v_parameter) v2
        and v3 = v_paren (v_list v_requirement) v3 in
        ()
    | DeepEllipsis v1 ->
        let v1 = v_bracket v_expr v1 in
        ()
    | TypedMetavar (v1, v2) ->
        let v1 = v_ident v1 and v2 = v_type_ v2 in
        ()
    | ExprTodo (v1, v2) ->
        let v1 = v_todo_category v1 and v2 = v_list v_expr v2 in
        ()
  and v_special = function
    | This -> ()
    | Defined -> ()
  and v_lambda_definition (v1, v2) =
    let v1 = v_bracket (v_list v_lambda_capture) v1
    and v2 = v_function_definition v2 in
    ()
  and v_lambda_capture = function
    | CaptureEq v1 ->
        let v1 = v_tok v1 in
        ()
    | CaptureRef v1 ->
        let v1 = v_tok v1 in
        ()
    | CaptureOther v1 ->
        let v1 = v_expr v1 in
        ()
  and v_obj_init = function
    | Args v1 ->
        let v1 = v_paren (v_list v_argument) v1 in
        ()
    | Inits v1 ->
        let v1 = v_brace (v_list v_initialiser) v1 in
        ()
  and v_argument = function
    | Arg e -> v_expression e
    | ArgType v1 ->
        let v1 = v_fullType v1 in
        ()
    | ArgAction v1 ->
        let v1 = v_action_macro v1 in
        ()
    | ArgInits v1 ->
        let v1 = v_brace (v_list v_initialiser) v1 in
        ()
  and v_action_macro = function
    | ActMisc v1 ->
        let v1 = v_list v_tok v1 in
        ()
  and v_constant = function
    | String v1 -> v_wrap v_string v1
    | MultiString v1 -> v_list (v_wrap v_string) v1
    | Char v1 -> v_wrap v_string v1
    | Int v1 ->
        let v1 = v_wrap (v_option v_int) v1 in
        ()
    | Float v1 ->
        let v1 = v_wrap (v_option v_float) v1 in
        ()
    | Bool v1 -> v_wrap v_bool v1
    | Nullptr v1 -> v_tok v1
  and v_unaryOp = function
    | GetRef -> ()
    | DeRef -> ()
    | UnPlus -> ()
    | UnMinus -> ()
    | Tilde -> ()
    | Not -> ()
    | GetRefLabel -> ()
  and v_assignOp = function
    | SimpleAssign v1 -> v_tok v1
    | OpAssign v1 -> v_wrap v_arithOp v1
  and v_fixOp = function
    | Dec -> ()
    | Inc -> ()
  and v_binaryOp = function
    | Arith v1 ->
        let v1 = v_arithOp v1 in
        ()
    | Logical v1 ->
        let v1 = v_logicalOp v1 in
        ()
  and v_arithOp = function
    | Plus -> ()
    | Minus -> ()
    | Mul -> ()
    | Div -> ()
    | Mod -> ()
    | DecLeft -> ()
    | DecRight -> ()
    | And -> ()
    | Or -> ()
    | Xor -> ()
  and v_logicalOp = function
    | Inf -> ()
    | Sup -> ()
    | InfEq -> ()
    | SupEq -> ()
    | Eq -> ()
    | NotEq -> ()
    | AndLog -> ()
    | OrLog -> ()
    | Spaceship -> ()
  and v_ptrOp = function
    | PtrStarOp -> ()
    | PtrOp -> ()
  and v_allocOp = function
    | NewOp -> ()
    | DeleteOp -> ()
    | NewArrayOp -> ()
    | DeleteArrayOp -> ()
  and v_accessop = function
    | ParenOp -> ()
    | ArrayOp -> ()
  and v_operator = function
    | BinaryOp v1 ->
        let v1 = v_binaryOp v1 in
        ()
    | AssignOp v1 ->
        let v1 = v_assignOp v1 in
        ()
    | FixOp v1 ->
        let v1 = v_fixOp v1 in
        ()
    | PtrOpOp v1 ->
        let v1 = v_ptrOp v1 in
        ()
    | AccessOp v1 ->
        let v1 = v_accessop v1 in
        ()
    | AllocOp v1 ->
        let v1 = v_allocOp v1 in
        ()
    | UnaryTildeOp -> ()
    | DotStarOp -> ()
    | CoAwaitOp -> ()
    | UnaryNotOp -> ()
    | CommaOp -> ()
  and v_cast_operator = function
    | Static_cast -> ()
    | Dynamic_cast -> ()
    | Const_cast -> ()
    | Reinterpret_cast -> ()
  and v_constExpression v = v_expression v
  and v_dotOp = function
    | Dot -> ()
    | Arrow -> ()
  and v_fold_expr = function
    | LeftFold (v1, v2, v3) ->
        let v1 = v_tok v1 and v2 = v_wrap v_operator v2 and v3 = v_expr v3 in
        ()
    | RightFold (v1, v2, v3) ->
        let v1 = v_expr v1 and v2 = v_wrap v_operator v2 and v3 = v_tok v3 in
        ()
    | BinaryFold (v1, (v2, v3, v4), v5) ->
        let v1 = v_expr v1
        and v2 = v_wrap v_operator v2
        and v3 = v_tok v3
        and v4 = v_wrap v_operator v4
        and v5 = v_expr v5 in
        ()
  and v_requirement = function
    | ExprReq (v1, v2) ->
        let v1 = v_option v_expr v1 and v2 = v_tok v2 in
        ()
    | TypeNameReq (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_name v2 in
        ()
    | CompoundReq (v1, v2, v3, v4) ->
        let v1 = v_paren v_expr v1
        and v2 = v_option v_tok v2
        and v3 = v_option v_type_ v3
        and v4 = v_tok v4 in
        ()
  and v_statement v =
    let k v = v_statementbis v in
    vin.kstmt (k, all_functions) v
  and v_case_body v = v_list v_stmt_or_decl v
  and v_stmt x = v_statement x
  and v_statementbis = function
    | Compound v1 ->
        let v1 = v_compound v1 in
        ()
    | ExprStmt v1 ->
        let v1 = v_exprStatement v1 in
        ()
    | Label (v1, t, v2) ->
        v_wrap v_string v1;
        v_tok t;
        v_statement v2
    | Case (t1, v1, t2, v2) ->
        v_tok t1;
        v_expression v1;
        v_tok t2;
        v_case_body v2
    | CaseRange (t1, v1, t2, v2, t3, v3) ->
        v_tok t1;
        v_expression v1;
        v_tok t2;
        v_expression v2;
        v_tok t3;
        v_case_body v3
    | Default (t1, t2, v1) ->
        v_tok t1;
        v_tok t2;
        v_case_body v1
    | Jump (v1, v2) ->
        v_jump v1;
        v_tok v2
    | Try (v1, v2, v3) ->
        let v1 = v_tok v1 and v2 = v_compound v2 and v3 = v_list v_handler v3 in
        ()
    | MacroStmt v1 -> v_tok v1
    | StmtTodo (v1, v2) ->
        let v1 = v_todo_category v1 and v2 = v_list v_stmt v2 in
        ()
    | If (v1, t1, v2, v3, v4) ->
        v_tok v1;
        v_option v_tok t1;
        v_paren v_condition_clause v2;
        v_statement v3;
        v_option
          (fun (v1, v2) ->
            v_tok v1;
            v_statement v2)
          v4
    | Switch (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_paren v_condition_clause v2
        and v3 = v_statement v3 in
        ()
    | While (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_paren v_condition_clause v2
        and v3 = v_statement v3 in
        ()
    | DoWhile (v1, v2, v3, v4, v5) ->
        let v1 = v_tok v1
        and v2 = v_statement v2
        and v3 = v_tok v3
        and v4 = v_paren v_expression v4
        and v5 = v_tok v5 in
        ()
    | For (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_paren v_for_header v2
        and v3 = v_statement v3 in
        ()
    | MacroIteration (v1, v2, v3) ->
        let v1 = v_wrap v_string v1
        and v2 = v_paren (v_list v_argument) v2
        and v3 = v_statement v3 in
        ()
  and v_compound v =
    let k v = v_brace (v_list (v_sequencable v_stmt_or_decl)) v in
    vin.kcompound (k, all_functions) v
  and v_for_header = function
    | ForEllipsis v1 -> v_tok v1
    | ForClassic (v1, v2, v3) ->
        let v1 = v_a_expr_or_vars v1
        and v2 = v_option v_expr v2
        and v3 = v_option v_expr v3 in
        ()
    | ForRange (v1, v2, v3) ->
        let v1 = v_var_decl v1 and v2 = v_tok v2 and v3 = v_initialiser v3 in
        ()
  and v_a_expr_or_vars v = OCaml.v_either v_expr_stmt v_vars_decl v
  and v_vars_decl (v1, v2) =
    let v1 = v_list v_onedecl v1 and v2 = v_sc v2 in
    ()
  and v_sc x = v_tok x
  and v_var_decl (v1, v2) =
    let v1 = v_entity v1 and v2 = v_variable_definition v2 in
    ()
  and v_variable_definition { v_init = v_v_init; v_type = v_v_type } =
    let arg = v_option v_init v_v_init in
    let arg = v_type_ v_v_type in
    ()
  and v_condition_initializer = function
    | InitVarsDecl v1 ->
        let v1 = v_vars_decl v1 in
        ()
    | InitExprStmt v1 ->
        let v1 = v_expr_stmt v1 in
        ()
    | InitUsing v1 ->
        let v1 = v_using v1 in
        ()
  and v_condition_subject = function
    | CondClassic v1 ->
        let v1 = v_expr v1 in
        ()
    | CondOneDecl v1 ->
        let v1 = v_var_decl v1 in
        ()
  and v_condition_clause (v1, v2) =
    let v1 = v_option v_condition_initializer v1
    and v2 = v_condition_subject v2 in
    ()
  and v_stmt_or_decl = function
    | S v1 ->
        let v1 = v_stmt v1 in
        ()
    | D v1 ->
        let v1 = v_decl v1 in
        ()
  and v_decl x = v_declaration x
  and v_sequencable _of_a = function
    | X v1 ->
        let v1 = _of_a v1 in
        ()
    | CppDirective v1 ->
        let v1 = v_cpp_directive v1 in
        ()
    | CppIfdef v1 ->
        let v1 = v_ifdef_directive v1 in
        ()
    | MacroDecl (v1, v2, v3, v4) ->
        let v1 = v_list v_specifier v1
        and v2 = v_ident v2
        and v3 = v_paren (v_list v_argument) v3
        and v4 = v_sc v4 in
        ()
    | MacroVar (v1, v2) ->
        let v1 = v_ident v1 and v2 = v_sc v2 in
        ()
  and v_sequencable2 _of_a = function
    | X v1 ->
        let v1 = _of_a v1 in
        ()
    | CppDirective v1 ->
        let v1 = v_cpp_directive v1 in
        ()
    | CppIfdef v1 ->
        let v1 = v_ifdef_directive v1 in
        ()
    | MacroDecl (v1, v2, v3, v4) ->
        let v1 = v_list v_specifier v1
        and v2 = v_ident v2
        and v3 = v_paren (v_list v_argument) v3
        and v4 = v_sc v4 in
        ()
    | MacroVar (v1, v2) ->
        let v1 = v_ident v1 and v2 = v_sc v2 in
        ()
  and v_expr_stmt x = v_exprStatement x
  and v_exprStatement (v1, v2) =
    v_option v_expression v1;
    v_tok v2
  and v_jump = function
    | Goto (t, v1) ->
        v_tok t;
        let v1 = v_wrap v_string v1 in
        ()
    | Continue t -> v_tok t
    | Break t -> v_tok t
    | Return (t, v1) ->
        v_tok t;
        v_option v_argument v1
    | GotoComputed (t1, t2, v1) ->
        v_tok t1;
        v_tok t2;
        let v1 = v_expression v1 in
        ()
  and v_handler (v1, v2, v3) =
    let v1 = v_tok v1
    and v2 = v_paren v_exception_declaration v2
    and v3 = v_compound v3 in
    ()
  and v_exception_declaration = function
    | ExnDecl v1 ->
        let v1 = v_parameter v1 in
        ()
  and v_storage = function
    | Auto -> ()
    | Static -> ()
    | Register -> ()
    | Extern -> ()
    | StoInline -> ()
    | ThreadLocal -> ()
  and v_init = function
    | EqInit (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_initialiser v2 in
        ()
    | ObjInit v1 ->
        let v1 = v_obj_init v1 in
        ()
    | Bitfield (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_a_const_expr v2 in
        ()
  and v_a_const_expr v = v_expr v
  and v_initialiser x =
    let k x =
      match x with
      | InitExpr v1 ->
          let v1 = v_expression v1 in
          ()
      | InitList v1 ->
          let v1 = v_brace (v_list v_initialiser) v1 in
          ()
      | InitDesignators (v1, v2, v3) ->
          let v1 = v_list v_designator v1
          and v2 = v_tok v2
          and v3 = v_initialiser v3 in
          ()
      | InitFieldOld (v1, v2, v3) ->
          let v1 = v_wrap v_string v1
          and v2 = v_tok v2
          and v3 = v_initialiser v3 in
          ()
      | InitIndexOld (v1, v2) ->
          let v1 = v_bracket v_expression v1 and v2 = v_initialiser v2 in
          ()
    in
    vin.kinit (k, all_functions) x
  and v_designator = function
    | DesignatorField (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_wrap v_string v2 in
        ()
    | DesignatorIndex v1 ->
        let v1 = v_bracket v_expression v1 in
        ()
    | DesignatorRange v1 ->
        let v1 =
          v_bracket
            (fun (v1, v2, v3) ->
              let v1 = v_expression v1
              and v2 = v_tok v2
              and v3 = v_expression v3 in
              ())
            v1
        in
        ()
  and v_asmbody (v1, v2) =
    let v1 = v_list (v_wrap v_string) v1 and v2 = v_list v_colon v2 in
    ()
  and v_colon = function
    | Colon (v1, v2) ->
        v_tok v1;
        v_list v_colon_option v2
  and v_colon_option = function
    | ColonMisc v1 -> v_list v_tok v1
    | ColonExpr (v1, v2) ->
        v_list v_tok v1;
        v_paren v_expression v2
  and v_func_definition x =
    let k (v1, v2) =
      v_entity v1;
      v_function_definition v2
    in
    vin.kfunc_def (k, all_functions) x
  and v_entity { name = v1; specs = v_specs } =
    let arg = v_name v1 in
    let arg = v_list v_specifier v_specs in
    ()
  and v_function_definition x =
    match x with
    | { f_type = v_f_type; f_specs = v_f_storage; f_body = v_f_body } ->
        let arg = v_functionType v_f_type in
        let arg = v_list v_specifier v_f_storage in
        let arg = v_function_body v_f_body in
        ()
  and v_function_body = function
    | FBDef v1 ->
        let v1 = v_compound v1 in
        ()
    | FBDecl v1 ->
        let v1 = v_sc v1 in
        ()
    | FBZero (v1, v2, v3) ->
        let v1 = v_tok v1 and v2 = v_tok v2 and v3 = v_sc v3 in
        ()
    | FBDefault (v1, v2, v3) ->
        let v1 = v_tok v1 and v2 = v_tok v2 and v3 = v_sc v3 in
        ()
    | FBDelete (v1, v2, v3) ->
        let v1 = v_tok v1 and v2 = v_tok v2 and v3 = v_sc v3 in
        ()
    | FBTry (v1, v2, v3) ->
        let v1 = v_tok v1 and v2 = v_compound v2 and v3 = v_list v_handler v3 in
        ()
  and v_specifier = function
    | A v1 ->
        let v1 = v_attribute v1 in
        ()
    | M v1 ->
        let v1 = v_modifier v1 in
        ()
    | TQ v1 ->
        let v1 = v_wrap v_type_qualifier v1 in
        ()
    | ST v1 ->
        let v1 = v_wrap v_storage v1 in
        ()
  and v_attribute = function
    | UnderscoresAttr (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_paren (v_paren (v_list v_argument)) v2 in
        ()
    | BracketsAttr v1 ->
        let v1 = v_bracket (v_list v_expr) v1 in
        ()
    | DeclSpec (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_paren v_ident v2 in
        ()
  and v_functionType
      {
        ft_ret = v_ft_ret;
        ft_params = v_ft_params;
        ft_specs = v_ft_dots;
        ft_const = v_ft_const;
        ft_throw = v_ft_throw;
      } =
    let arg = v_fullType v_ft_ret in
    let arg = v_paren (v_list v_parameter) v_ft_params in
    let arg = v_list v_specifier v_ft_dots in
    let arg = v_option v_tok v_ft_const in
    let arg = v_list v_exn_spec v_ft_throw in
    ()
  and v_parameter x =
    let k x =
      match x with
      | P v1 ->
          let v1 = v_parameter_classic v1 in
          ()
      | ParamVariadic (v1, v2, v3) ->
          let v1 = v_option v_tok v1
          and v2 = v_tok v2
          and v3 = v_parameter_classic v3 in
          ()
      | ParamEllipsis v1 ->
          let v1 = v_tok v1 in
          ()
      | ParamTodo (v1, v2) ->
          let v1 = v_todo_category v1 and v2 = v_list v_parameter v2 in
          ()
    in
    vin.kparameter (k, all_functions) x
  and v_parameter_classic x =
    match x with
    | {
     p_name = v_p_name;
     p_type = v_p_type;
     p_specs = v_p_register;
     p_val = v_p_val;
    } ->
        let arg = v_option (v_wrap v_string) v_p_name in
        let arg = v_fullType v_p_type in
        let arg = v_list v_specifier v_p_register in
        let arg =
          v_option
            (fun (v1, v2) ->
              let v1 = v_tok v1 and v2 = v_expression v2 in
              ())
            v_p_val
        in
        ()
  and v_exn_spec = function
    | ThrowSpec (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_paren (v_list v_type_) v2 in
        ()
    | Noexcept (v1, v2) ->
        let v1 = v_tok v1
        and v2 = v_option (v_paren (v_option v_a_const_expr)) v2 in
        ()
  and v_class_definition x =
    let k (v1, v2) =
      let v1 = v_option v_name v1 and v2 = v_class_definition_bis v2 in
      ()
    in
    vin.kclass_def (k, all_functions) x
  and v_class_definition_bis x =
    match x with
    | { c_kind = v_c_kind; c_inherit = v_c_inherit; c_members = v_c_members } ->
        let arg = v_wrap v_structUnion v_c_kind in
        let arg = v_list v_base_clause v_c_inherit in
        let arg =
          v_brace (v_list (v_sequencable2 v_class_member)) v_c_members
        in
        ()
  and v_structUnion = function
    | Struct -> ()
    | Union -> ()
    | Class -> ()
  and v_base_clause
      { i_name = v_i_name; i_virtual = v_i_virtual; i_access = v_i_access } =
    let arg = v_name v_i_name in
    let arg = v_option v_modifier v_i_virtual in
    let arg = v_option (v_wrap v_access_spec) v_i_access in
    ()
  and v_access_spec = function
    | Public -> ()
    | Private -> ()
    | Protected -> ()
  and v_modifier = function
    | Inline v1 ->
        let v1 = v_tok v1 in
        ()
    | Virtual v1 ->
        let v1 = v_tok v1 in
        ()
    | Final v1 ->
        let v1 = v_tok v1 in
        ()
    | Override v1 ->
        let v1 = v_tok v1 in
        ()
    | MsCall v1 ->
        let v1 = v_wrap v_string v1 in
        ()
    | Explicit (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_option (v_paren v_expr) v2 in
        ()
  and v_class_member x =
    let k = function
      | Access (v1, v2) ->
          let v1 = v_wrap v_access_spec v1 and v2 = v_tok v2 in
          ()
      | QualifiedIdInClass (v1, v2) ->
          let v1 = v_name v1 and v2 = v_tok v2 in
          ()
      | Friend (v1, v2) ->
          let v1 = v_tok v1 and v2 = v_decl v2 in
          ()
      | F v1 ->
          let v1 = v_decl v1 in
          ()
    in
    vin.kclass_member (k, all_functions) x
  and v_cpp_directive x =
    let k = function
      | Define (v1, v2, v3, v4) ->
          let v1 = v_tok v1
          and v2 = v_wrap v_string v2
          and v3 = v_define_kind v3
          and v4 = v_define_val v4 in
          ()
      | Include (v1, v2) ->
          let v1 = v_tok v1 and v2 = v_inc_kind v2 in
          ()
      | Undef v1 ->
          let v1 = v_wrap v_string v1 in
          ()
      | PragmaAndCo v1 ->
          let v1 = v_tok v1 in
          ()
    in
    vin.kcpp (k, all_functions) x
  and v_define_kind = function
    | DefineVar -> ()
    | DefineMacro v1 ->
        let v1 = v_paren (v_list (v_wrap v_string)) v1 in
        ()
  and v_define_val = function
    | DefinePrintWrapper (v1, v2, v3) ->
        let v1 = v_tok v1 and v2 = v_paren v_expression v2 and v3 = v_name v3 in
        ()
    | DefineExpr v1 ->
        let v1 = v_expression v1 in
        ()
    | DefineStmt v1 ->
        let v1 = v_statement v1 in
        ()
    | DefineType v1 ->
        let v1 = v_fullType v1 in
        ()
    | DefineDoWhileZero (v1, v2, v3, v4) ->
        let v1 = v_tok v1
        and v2 = v_stmt v2
        and v3 = v_tok v3
        and v4 = v_paren v_tok v4 in
        ()
    | DefineFunction v1 ->
        let v1 = v_func_definition v1 in
        ()
    | DefineInit v1 ->
        let v1 = v_initialiser v1 in
        ()
    | DefineEmpty -> ()
    | DefineTodo v1 ->
        let v1 = v_todo_category v1 in
        ()
  and v_inc_kind = function
    | IncLocal v1 -> v_wrap v_string v1
    | IncSystem v1 -> v_wrap v_string v1
    | IncOther v1 -> v_expression v1
  and v_ifdef_directive = function
    | Ifdef v1 -> v_tok v1
    | IfdefElse v1 -> v_tok v1
    | IfdefElseif v1 -> v_tok v1
    | IfdefEndif v1 -> v_tok v1
  and v_declarations v = v_brace (v_list (v_sequencable v_stmt_or_decl)) v
  and v_declaration x =
    let k = function
      | Func v1 ->
          let v1 = v_func_definition v1 in
          ()
      | TemplateDecl (v1, v2, v3) ->
          let v1 = v_tok v1
          and v2 = v_template_parameters v2
          and v3 = v_declaration v3 in
          ()
      | ExternDecl (v1, v2, v3) ->
          let v1 = v_tok v1
          and v2 = v_wrap v_string v2
          and v3 = v_declaration v3 in
          ()
      | ExternList (v1, v2, v3) ->
          let v1 = v_tok v1
          and v2 = v_wrap v_string v2
          and v3 = v_declarations v3 in
          ()
      | Namespace (v1, v2, v3) ->
          let v1 = v_tok v1
          and v2 = v_option (v_wrap v_string) v2
          and v3 = v_declarations v3 in
          ()
      | EmptyDef v1 ->
          let v1 = v_tok v1 in
          ()
      | DeclTodo v1 -> v_todo_category v1
      | DeclList (v1, v2) ->
          let v1 = v_list v_onedecl v1 and v2 = v_tok v2 in
          ()
      | UsingDecl v1 -> v_using v1
      | NamespaceAlias (v1, v2, v3, v4, v5) ->
          let v1 = v_tok v1
          and v2 = v_wrap v_string v2
          and v3 = v_tok v3
          and v4 = v_name v4
          and v5 = v_tok v5 in
          ()
      | Asm (v1, v2, v3, v4) ->
          let v1 = v_tok v1
          and v2 = v_option v_tok v2
          and v3 = v_paren v_asmbody v3
          and v4 = v_tok v4 in
          ()
      | TemplateInstanciation (v1, v2, v3) ->
          let v1 = v_tok v1 and v2 = v_var_decl v2 and v3 = v_sc v3 in
          ()
      | StaticAssert (v1, v2) ->
          let v1 = v_tok v1 and v2 = v_paren (v_list v_argument) v2 in
          ()
      | NotParsedCorrectly v1 ->
          let v1 = v_list v_tok v1 in
          ()
    in

    vin.kdeclaration (k, all_functions) x
  and v_using (v1, v2, v3) =
    let v1 = v_tok v1 and v2 = v_using_kind v2 and v3 = v_sc v3 in
    ()
  and v_using_kind = function
    | UsingName v1 ->
        let v1 = v_name v1 in
        ()
    | UsingNamespace (v1, v2) ->
        let v1 = v_tok v1 and v2 = v_name v2 in
        ()
    | UsingAlias (v1, v2, v3) ->
        let v1 = v_ident v1 and v2 = v_tok v2 and v3 = v_type_ v3 in
        ()
  and v_onedecl = function
    | TypedefDecl (v1, v2, v3) ->
        let v1 = v_tok v1 and v2 = v_type_ v2 and v3 = v_ident v3 in
        ()
    | EmptyDecl v1 ->
        let v1 = v_type_ v1 in
        ()
    | V v1 ->
        let v1 = v_var_decl v1 in
        ()
    | StructuredBinding (v1, v2, v3) ->
        let v1 = v_type_ v1
        and v2 = v_bracket (v_list v_ident) v2
        and v3 = v_init v3 in
        ()
    | BitField (v1, v2, v3, v4) ->
        let v1 = v_option v_ident v1
        and v2 = v_tok v2
        and v3 = v_type_ v3
        and v4 = v_a_const_expr v4 in
        ()
  and v_template_parameter = function
    | TP v1 ->
        let v1 = v_parameter v1 in
        ()
    | TPClass (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_option v_ident v2
        and v3 = v_option v_type_ v3 in
        ()
    | TPVariadic (v1, v2, v3) ->
        let v1 = v_tok v1 and v2 = v_tok v2 and v3 = v_option v_ident v3 in
        ()
    | TPNested (v1, v2, v3) ->
        let v1 = v_tok v1
        and v2 = v_template_parameters v2
        and v3 = v_template_parameter v3 in
        ()
  and v_template_parameters v = v_angle (v_list v_template_parameter) v
  and v_toplevel v =
    let k x = v_sequencable v_stmt_or_decl x in
    vin.ktoplevel (k, all_functions) v
  and v_program v = v_list v_toplevel v
  and v_any = function
    | Toplevels v1 -> v_list v_toplevel v1
    | Program v1 ->
        let v1 = v_program v1 in
        ()
    | Toplevel v1 ->
        let v1 = v_toplevel v1 in
        ()
    | Stmt v1 ->
        let v1 = v_statement v1 in
        ()
    | Stmts v1 ->
        let v1 = v_list v_statement v1 in
        ()
    | Expr v1 ->
        let v1 = v_expression v1 in
        ()
    | Init v1 ->
        let v1 = v_initialiser v1 in
        ()
    | Type v1 ->
        let v1 = v_fullType v1 in
        ()
    | Name v1 ->
        let v1 = v_name v1 in
        ()
    | Cpp v1 ->
        let v1 = v_cpp_directive v1 in
        ()
    | Constant v1 ->
        let v1 = v_constant v1 in
        ()
    | Argument v1 ->
        let v1 = v_argument v1 in
        ()
    | Parameter v1 ->
        let v1 = v_parameter v1 in
        ()
    | Body v1 ->
        let v1 = v_compound v1 in
        ()
    | Info v1 ->
        let v1 = v_info v1 in
        ()
    | InfoList v1 ->
        let v1 = v_list v_info v1 in
        ()
    | ClassMember v1 ->
        let v1 = v_class_member v1 in
        ()
    | OneDecl v1 ->
        let v1 = v_onedecl v1 in
        ()
  (* end of auto generation *)
  and all_functions x = v_any x in
  v_any
