(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

let debug = ref false

type mt = Run.matcher_token

external create_parser : unit -> Tree_sitter_API.ts_parser
  = "octs_create_parser_dart"

let ts_parser = create_parser ()

let parse_source_string ?src_file contents =
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [ "comment"; "documentation_comment" ]

let children_regexps : (string * Run.exp option) list =
  [
    ("equality_operator", None);
    ("increment_operator", None);
    ("this", None);
    ("exclamation_operator", None);
    ("as", None);
    ("false", None);
    ("mixin", None);
    ("new_builtin", None);
    ("set", None);
    ("break_builtin", None);
    ("inferred_type", None);
    ("unused_escape_sequence", None);
    ("template_chars_single", None);
    ("semgrep_ellipsis", None);
    ("minus_operator", None);
    ("export", None);
    ("import", None);
    ("hex_integer_literal", None);
    ( "multiplicative_operator_",
      Some
        (Alt
           [|
             Token (Literal "*");
             Token (Literal "/");
             Token (Literal "%");
             Token (Literal "~/");
           |]) );
    ("decimal_integer_literal", None);
    ("implements", None);
    ("get", None);
    ("pat_a3d33dc", None);
    ( "bitwise_operator",
      Some
        (Alt [| Token (Literal "&"); Token (Literal "^"); Token (Literal "|") |])
    );
    ("semgrep_named_ellipsis", None);
    ("case_builtin", None);
    ("deferred", None);
    ("function_builtin_identifier", None);
    ("factory", None);
    ("static", None);
    ("external_builtin", None);
    ("template_chars_single_single", None);
    ("template_chars_double", None);
    ("assert_builtin", None);
    ("semicolon", Some (Seq [ Token (Literal ";") ]));
    ("required", None);
    ("super", None);
    ("nullable_type", None);
    ("tok_is", None);
    ("covariant", None);
    ("null_literal", None);
    ("tilde_operator", None);
    ("identifier", None);
    ( "shift_operator_",
      Some
        (Alt
           [|
             Token (Literal "<<"); Token (Literal ">>"); Token (Literal ">>>");
           |]) );
    ("as_operator", None);
    ("void_type", None);
    ("template_chars_double_single", None);
    ("template_chars_raw_slash", None);
    ("identifier_dollar_escaped", None);
    ("operator", None);
    ("final_builtin", None);
    ("pat_0017fb0", None);
    ("late_builtin", None);
    ( "relational_operator",
      Some
        (Alt
           [|
             Token (Literal "<");
             Token (Literal ">");
             Token (Literal "<=");
             Token (Literal ">=");
           |]) );
    ( "assignment_operator",
      Some
        (Alt
           [|
             Token (Literal "=");
             Token (Literal "+=");
             Token (Literal "-=");
             Token (Literal "*=");
             Token (Literal "/=");
             Token (Literal "%=");
             Token (Literal "~/=");
             Token (Literal "<<=");
             Token (Literal ">>=");
             Token (Literal ">>>=");
             Token (Literal "&=");
             Token (Literal "^=");
             Token (Literal "|=");
             Token (Literal "??=");
           |]) );
    ("decimal_floating_point_literal", None);
    ("true", None);
    ("const_builtin", None);
    ("typedef", None);
    ("additive_operator_", None);
    ("postfix_operator", Some (Token (Name "increment_operator")));
    ("negation_operator", Some (Token (Name "exclamation_operator")));
    ("escape_sequence", Some (Token (Name "unused_escape_sequence")));
    ("multiplicative_operator", Some (Token (Name "multiplicative_operator_")));
    ( "sub_string_test",
      Some (Seq [ Token (Literal "$"); Token (Name "pat_a3d33dc") ]) );
    ("bitwise_operator_", Some (Token (Name "bitwise_operator")));
    ("external", Some (Token (Name "external_builtin")));
    ( "is_operator",
      Some
        (Seq
           [ Token (Name "tok_is"); Opt (Token (Name "exclamation_operator")) ])
    );
    ( "catch_clause",
      Some
        (Seq
           [
             Token (Literal "catch");
             Token (Literal "(");
             Token (Name "identifier");
             Opt (Seq [ Token (Literal ","); Token (Name "identifier") ]);
             Token (Literal ")");
           ]) );
    ( "symbol_literal",
      Some (Seq [ Token (Literal "#"); Token (Name "identifier") ]) );
    ( "dotted_identifier_list",
      Some
        (Seq
           [
             Token (Name "identifier");
             Repeat (Seq [ Token (Literal "."); Token (Name "identifier") ]);
           ]) );
    ( "qualified",
      Some
        (Seq
           [
             Token (Name "identifier");
             Opt (Seq [ Token (Literal "."); Token (Name "identifier") ]);
           ]) );
    ( "break_statement",
      Some
        (Seq
           [
             Token (Name "break_builtin");
             Opt (Token (Name "identifier"));
             Token (Name "semicolon");
           ]) );
    ( "conditional_assignable_selector",
      Some (Seq [ Token (Literal "?."); Token (Name "identifier") ]) );
    ( "type_dot_identifier",
      Some (Seq [ Token (Literal "."); Token (Name "identifier") ]) );
    ("label", Some (Seq [ Token (Name "identifier"); Token (Literal ":") ]));
    ( "identifier_list_",
      Some
        (Seq
           [
             Token (Name "identifier");
             Repeat (Seq [ Token (Literal ","); Token (Name "identifier") ]);
           ]) );
    ( "scoped_identifier",
      Some
        (Seq
           [
             Alt
               [| Token (Name "identifier"); Token (Name "scoped_identifier") |];
             Token (Literal ".");
             Token (Name "identifier");
           ]) );
    ( "identifier_list",
      Some
        (Seq
           [
             Token (Name "identifier");
             Repeat (Seq [ Token (Literal ","); Token (Name "identifier") ]);
           ]) );
    ( "dot_identifier",
      Some (Seq [ Token (Literal "."); Token (Name "identifier") ]) );
    ( "continue_statement",
      Some
        (Seq
           [
             Token (Literal "continue");
             Opt (Token (Name "identifier"));
             Token (Name "semicolon");
           ]) );
    ("shift_operator", Some (Token (Name "shift_operator_")));
    ( "script_tag",
      Some
        (Seq
           [
             Token (Literal "#!");
             Token (Name "pat_0017fb0");
             Token (Literal "\n");
           ]) );
    ( "final_or_const",
      Some
        (Alt [| Token (Name "final_builtin"); Token (Name "const_builtin") |])
    );
    ("additive_operator", Some (Token (Name "additive_operator_")));
    ( "prefix_operator",
      Some
        (Alt
           [|
             Token (Name "minus_operator");
             Token (Name "negation_operator");
             Token (Name "tilde_operator");
           |]) );
    ( "raw_string_literal_double_quotes",
      Some
        (Seq
           [
             Token (Literal "r\"");
             Repeat
               (Alt
                  [|
                    Token (Name "template_chars_double_single");
                    Token (Literal "'");
                    Token (Name "template_chars_raw_slash");
                    Token (Name "unused_escape_sequence");
                    Token (Name "sub_string_test");
                    Token (Literal "$");
                  |]);
             Token (Literal "\"");
           ]) );
    ( "raw_string_literal_double_quotes_multiple",
      Some
        (Seq
           [
             Token (Literal "r\"\"\"");
             Repeat
               (Alt
                  [|
                    Token (Name "template_chars_double");
                    Token (Literal "'");
                    Token (Name "template_chars_raw_slash");
                    Token (Literal "\"");
                    Token (Name "unused_escape_sequence");
                    Token (Name "sub_string_test");
                    Token (Literal "$");
                  |]);
             Token (Literal "\"\"\"");
           ]) );
    ( "raw_string_literal_single_quotes",
      Some
        (Seq
           [
             Token (Literal "r'");
             Repeat
               (Alt
                  [|
                    Token (Name "template_chars_single_single");
                    Token (Literal "\"");
                    Token (Name "template_chars_raw_slash");
                    Token (Name "unused_escape_sequence");
                    Token (Name "sub_string_test");
                    Token (Literal "$");
                  |]);
             Token (Literal "'");
           ]) );
    ( "raw_string_literal_single_quotes_multiple",
      Some
        (Seq
           [
             Token (Literal "r'''");
             Repeat
               (Alt
                  [|
                    Token (Name "template_chars_single");
                    Token (Literal "\"");
                    Token (Literal "'");
                    Token (Name "template_chars_raw_slash");
                    Token (Name "unused_escape_sequence");
                    Token (Name "sub_string_test");
                    Token (Literal "$");
                  |]);
             Token (Literal "'''");
           ]) );
    ( "external_and_static",
      Some (Seq [ Token (Name "external"); Opt (Token (Name "static")) ]) );
    ( "type_name",
      Some
        (Seq
           [
             Token (Name "identifier"); Opt (Token (Name "type_dot_identifier"));
           ]) );
    ( "marker_annotation",
      Some
        (Seq
           [
             Token (Literal "@");
             Alt
               [| Token (Name "identifier"); Token (Name "scoped_identifier") |];
           ]) );
    ( "combinator",
      Some
        (Alt
           [|
             Seq [ Token (Literal "show"); Token (Name "identifier_list") ];
             Seq [ Token (Literal "hide"); Token (Name "identifier_list") ];
           |]) );
    ( "binary_operator",
      Some
        (Alt
           [|
             Token (Name "multiplicative_operator");
             Token (Name "additive_operator");
             Token (Name "shift_operator");
             Token (Name "relational_operator");
             Token (Literal "==");
             Token (Name "bitwise_operator_");
           |]) );
    ( "additive_expression",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "real_expression");
                 Repeat1
                   (Seq
                      [
                        Token (Name "additive_operator");
                        Token (Name "real_expression");
                      ]);
               ];
             Seq
               [
                 Token (Name "super");
                 Repeat1
                   (Seq
                      [
                        Token (Name "additive_operator");
                        Token (Name "real_expression");
                      ]);
               ];
           |]) );
    ( "annotation",
      Some
        (Seq
           [
             Token (Literal "@");
             Alt
               [| Token (Name "identifier"); Token (Name "scoped_identifier") |];
             Token (Name "arguments");
           ]) );
    ( "annotation_",
      Some
        (Alt [| Token (Name "marker_annotation"); Token (Name "annotation") |])
    );
    ("argument", Some (Token (Name "expression")));
    ( "argument_list",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "named_argument");
                 Repeat
                   (Seq [ Token (Literal ","); Token (Name "named_argument") ]);
               ];
             Seq
               [
                 Token (Name "argument");
                 Repeat (Seq [ Token (Literal ","); Token (Name "argument") ]);
                 Repeat
                   (Seq
                      [
                        Token (Literal ",");
                        Token (Name "named_argument");
                        Repeat
                          (Seq
                             [
                               Token (Literal ",");
                               Token (Name "named_argument");
                             ]);
                      ]);
               ];
           |]) );
    ( "argument_part",
      Some
        (Seq [ Opt (Token (Name "type_arguments")); Token (Name "arguments") ])
    );
    ( "arguments",
      Some
        (Seq
           [
             Token (Literal "(");
             Opt
               (Seq [ Token (Name "argument_list"); Opt (Token (Literal ",")) ]);
             Token (Literal ")");
           ]) );
    ( "assert_statement",
      Some (Seq [ Token (Name "assertion"); Token (Literal ";") ]) );
    ( "assertion",
      Some
        (Seq
           [
             Token (Name "assert_builtin");
             Token (Literal "(");
             Token (Name "expression");
             Opt (Seq [ Token (Literal ","); Token (Name "expression") ]);
             Opt (Token (Literal ","));
             Token (Literal ")");
           ]) );
    ( "assignable_expression",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "primary"); Token (Name "assignable_selector_part");
               ];
             Seq
               [
                 Token (Name "super");
                 Token (Name "unconditional_assignable_selector");
               ];
             Seq
               [
                 Token (Name "constructor_invocation");
                 Token (Name "assignable_selector_part");
               ];
             Token (Name "identifier");
           |]) );
    ( "assignable_selector",
      Some
        (Alt
           [|
             Token (Name "unconditional_assignable_selector");
             Token (Name "conditional_assignable_selector");
           |]) );
    ( "assignable_selector_part",
      Some
        (Seq
           [
             Repeat (Token (Name "selector"));
             Token (Name "assignable_selector");
           ]) );
    ( "assignment_expression",
      Some
        (Seq
           [
             Token (Name "assignable_expression");
             Token (Name "assignment_operator");
             Token (Name "expression");
           ]) );
    ( "assignment_expression_without_cascade",
      Some
        (Seq
           [
             Token (Name "assignable_expression");
             Token (Name "assignment_operator");
             Token (Name "expression_without_cascade");
           ]) );
    ( "await_expression",
      Some (Seq [ Token (Literal "await"); Token (Name "unary_expression") ]) );
    ( "bitwise_and_expression",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "real_expression");
                 Repeat1
                   (Seq [ Token (Literal "&"); Token (Name "real_expression") ]);
               ];
             Seq
               [
                 Token (Name "super");
                 Repeat1
                   (Seq [ Token (Literal "&"); Token (Name "real_expression") ]);
               ];
           |]) );
    ( "bitwise_or_expression",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "real_expression");
                 Repeat1
                   (Seq [ Token (Literal "|"); Token (Name "real_expression") ]);
               ];
             Seq
               [
                 Token (Name "super");
                 Repeat1
                   (Seq [ Token (Literal "|"); Token (Name "real_expression") ]);
               ];
           |]) );
    ( "bitwise_xor_expression",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "real_expression");
                 Repeat1
                   (Seq [ Token (Literal "^"); Token (Name "real_expression") ]);
               ];
             Seq
               [
                 Token (Name "super");
                 Repeat1
                   (Seq [ Token (Literal "^"); Token (Name "real_expression") ]);
               ];
           |]) );
    ( "block",
      Some
        (Seq
           [
             Token (Literal "{");
             Repeat (Token (Name "statement"));
             Token (Literal "}");
           ]) );
    ( "cascade_assignment_section",
      Some
        (Seq
           [
             Token (Name "assignment_operator");
             Token (Name "expression_without_cascade");
           ]) );
    ( "cascade_section",
      Some
        (Seq
           [
             Alt [| Token (Literal ".."); Token (Literal "?..") |];
             Token (Name "cascade_selector");
             Repeat (Token (Name "argument_part"));
             Repeat (Token (Name "cascade_subsection"));
             Opt (Token (Name "cascade_assignment_section"));
           ]) );
    ( "cascade_selector",
      Some
        (Alt
           [|
             Seq
               [
                 Opt (Token (Name "nullable_type"));
                 Token (Literal "[");
                 Token (Name "expression");
                 Token (Literal "]");
               ];
             Token (Name "identifier");
           |]) );
    ( "cascade_subsection",
      Some
        (Seq
           [
             Token (Name "assignable_selector");
             Repeat (Token (Name "argument_part"));
           ]) );
    ( "conditional_expression",
      Some
        (Seq
           [
             Token (Name "real_expression");
             Token (Literal "?");
             Token (Name "expression_without_cascade");
             Token (Literal ":");
             Token (Name "expression_without_cascade");
           ]) );
    ( "const_object_expression",
      Some
        (Seq
           [
             Token (Name "const_builtin");
             Token (Name "type_not_void");
             Opt (Token (Name "dot_identifier"));
             Token (Name "arguments");
           ]) );
    ( "constructor_invocation",
      Some
        (Seq
           [
             Token (Name "type_name");
             Token (Name "type_arguments");
             Token (Literal ".");
             Token (Name "identifier");
             Token (Name "arguments");
           ]) );
    ( "constructor_param",
      Some
        (Seq
           [
             Opt (Token (Name "final_const_var_or_type"));
             Token (Name "this");
             Token (Literal ".");
             Token (Name "identifier");
             Opt (Token (Name "formal_parameter_part"));
           ]) );
    ( "declared_identifier",
      Some
        (Seq
           [
             Opt (Token (Name "metadata"));
             Opt (Token (Name "covariant"));
             Token (Name "final_const_var_or_type");
             Token (Name "identifier");
           ]) );
    ( "deep_ellipsis",
      Some
        (Seq
           [
             Token (Literal "<...");
             Token (Name "expression");
             Token (Literal "...>");
           ]) );
    ( "default_formal_parameter",
      Some
        (Seq
           [
             Token (Name "formal_parameter");
             Opt (Seq [ Token (Literal "="); Token (Name "expression") ]);
           ]) );
    ( "default_named_parameter",
      Some
        (Alt
           [|
             Seq
               [
                 Opt (Token (Name "required"));
                 Token (Name "formal_parameter");
                 Opt (Seq [ Token (Literal "="); Token (Name "expression") ]);
               ];
             Seq
               [
                 Opt (Token (Name "required"));
                 Token (Name "formal_parameter");
                 Opt (Seq [ Token (Literal ":"); Token (Name "expression") ]);
               ];
           |]) );
    ( "do_statement",
      Some
        (Seq
           [
             Token (Literal "do");
             Token (Name "statement");
             Token (Literal "while");
             Token (Name "parenthesized_expression");
             Token (Name "semicolon");
           ]) );
    ( "element",
      Some
        (Alt
           [|
             Token (Name "expression");
             Token (Name "pair");
             Token (Name "spread_element");
             Token (Name "if_element");
             Token (Name "for_element");
           |]) );
    ( "equality_expression",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "real_expression");
                 Token (Name "equality_operator");
                 Token (Name "real_expression");
               ];
             Seq
               [
                 Token (Name "super");
                 Token (Name "equality_operator");
                 Token (Name "real_expression");
               ];
           |]) );
    ( "expression",
      Some
        (Alt
           [|
             Alt
               [|
                 Token (Name "assignment_expression");
                 Token (Name "throw_expression");
                 Seq
                   [
                     Token (Name "real_expression");
                     Repeat (Token (Name "cascade_section"));
                   ];
               |];
             Token (Name "semgrep_ellipsis");
             Token (Name "semgrep_named_ellipsis");
             Token (Name "deep_ellipsis");
           |]) );
    ( "expression_statement",
      Some
        (Alt
           [|
             Seq [ Token (Name "expression"); Token (Name "semicolon") ];
             Token (Name "semgrep_ellipsis");
           |]) );
    ( "expression_without_cascade",
      Some
        (Alt
           [|
             Token (Name "assignment_expression_without_cascade");
             Token (Name "real_expression");
             Token (Name "throw_expression_without_cascade");
           |]) );
    ( "final_const_var_or_type",
      Some
        (Alt
           [|
             Seq
               [
                 Opt (Token (Name "late_builtin"));
                 Token (Name "final_builtin");
                 Opt (Token (Name "type"));
               ];
             Seq [ Token (Name "const_builtin"); Opt (Token (Name "type")) ];
             Seq
               [ Opt (Token (Name "late_builtin")); Token (Name "var_or_type") ];
           |]) );
    ( "finally_clause",
      Some (Seq [ Token (Literal "finally"); Token (Name "block") ]) );
    ( "for_element",
      Some
        (Seq
           [
             Opt (Token (Literal "await"));
             Token (Literal "for");
             Token (Literal "(");
             Token (Name "for_loop_parts");
             Token (Literal ")");
             Token (Name "element");
           ]) );
    ( "for_loop_parts",
      Some
        (Alt
           [|
             Seq
               [
                 Alt
                   [|
                     Token (Name "declared_identifier");
                     Token (Name "identifier");
                   |];
                 Token (Literal "in");
                 Token (Name "expression");
               ];
             Seq
               [
                 Opt
                   (Alt
                      [|
                        Token (Name "local_variable_declaration");
                        Seq
                          [
                            Opt
                              (Seq
                                 [
                                   Token (Name "expression");
                                   Repeat
                                     (Seq
                                        [
                                          Token (Literal ",");
                                          Token (Name "expression");
                                        ]);
                                 ]);
                            Token (Name "semicolon");
                          ];
                      |]);
                 Opt (Token (Name "expression"));
                 Token (Name "semicolon");
                 Opt
                   (Seq
                      [
                        Token (Name "expression");
                        Repeat
                          (Seq
                             [ Token (Literal ","); Token (Name "expression") ]);
                      ]);
               ];
           |]) );
    ( "for_statement",
      Some
        (Seq
           [
             Opt (Token (Literal "await"));
             Token (Literal "for");
             Token (Literal "(");
             Token (Name "for_loop_parts");
             Token (Literal ")");
             Token (Name "statement");
           ]) );
    ( "formal_parameter",
      Some
        (Alt
           [|
             Token (Name "semgrep_ellipsis");
             Token (Name "normal_formal_parameter");
           |]) );
    ("formal_parameter_list", Some (Token (Name "strict_formal_parameter_list")));
    ( "formal_parameter_part",
      Some
        (Seq
           [
             Opt (Token (Name "type_parameters"));
             Token (Name "formal_parameter_list");
           ]) );
    ( "function_body",
      Some
        (Alt
           [|
             Seq
               [
                 Opt (Token (Literal "async"));
                 Token (Literal "=>");
                 Token (Name "expression");
                 Token (Name "semicolon");
               ];
             Seq
               [
                 Opt
                   (Alt
                      [|
                        Token (Literal "async");
                        Token (Literal "async*");
                        Token (Literal "sync*");
                      |]);
                 Token (Name "block");
               ];
           |]) );
    ( "function_expression",
      Some
        (Seq
           [
             Token (Name "formal_parameter_part");
             Token (Name "function_expression_body");
           ]) );
    ( "function_expression_body",
      Some
        (Alt
           [|
             Seq
               [
                 Opt (Token (Literal "async"));
                 Token (Literal "=>");
                 Token (Name "expression");
               ];
             Seq
               [
                 Opt
                   (Alt
                      [|
                        Token (Literal "async");
                        Token (Literal "async*");
                        Token (Literal "sync*");
                      |]);
                 Token (Name "block");
               ];
           |]) );
    ( "function_formal_parameter",
      Some
        (Seq
           [
             Opt (Token (Name "covariant"));
             Opt (Token (Name "type"));
             Token (Name "identifier");
             Token (Name "formal_parameter_part");
             Opt (Token (Name "nullable_type"));
           ]) );
    ( "function_signature",
      Some
        (Seq
           [
             Opt (Token (Name "type"));
             Alt
               [|
                 Token (Name "get");
                 Token (Name "set");
                 Token (Name "identifier");
               |];
             Token (Name "formal_parameter_part");
             Opt (Token (Name "native"));
           ]) );
    ( "function_type",
      Some
        (Alt
           [|
             Token (Name "function_type_tails");
             Seq
               [
                 Token (Name "type_not_function");
                 Token (Name "function_type_tails");
               ];
           |]) );
    ( "function_type_tail",
      Some
        (Seq
           [
             Token (Name "function_builtin_identifier");
             Opt (Token (Name "type_parameters"));
             Opt (Token (Name "nullable_type"));
             Opt (Token (Name "parameter_type_list"));
             Opt (Token (Name "nullable_type"));
           ]) );
    ("function_type_tails", Some (Repeat1 (Token (Name "function_type_tail"))));
    ( "if_element",
      Some
        (Seq
           [
             Token (Literal "if");
             Token (Name "parenthesized_expression");
             Token (Name "element");
             Opt (Seq [ Token (Literal "else"); Token (Name "element") ]);
           ]) );
    ( "if_null_expression",
      Some
        (Seq
           [
             Token (Name "real_expression");
             Repeat1
               (Seq [ Token (Literal "??"); Token (Name "real_expression") ]);
           ]) );
    ( "if_statement",
      Some
        (Seq
           [
             Token (Literal "if");
             Token (Name "parenthesized_expression");
             Token (Name "statement");
             Opt (Seq [ Token (Literal "else"); Token (Name "statement") ]);
           ]) );
    ( "initialized_identifier",
      Some
        (Seq
           [
             Token (Name "identifier");
             Opt (Seq [ Token (Literal "="); Token (Name "expression") ]);
           ]) );
    ( "initialized_variable_definition",
      Some
        (Seq
           [
             Token (Name "declared_identifier");
             Opt (Seq [ Token (Literal "="); Token (Name "expression") ]);
             Repeat
               (Seq
                  [ Token (Literal ","); Token (Name "initialized_identifier") ]);
           ]) );
    ( "lambda_expression",
      Some
        (Seq [ Token (Name "function_signature"); Token (Name "function_body") ])
    );
    ( "list_literal",
      Some
        (Seq
           [
             Opt (Token (Name "const_builtin"));
             Opt (Token (Name "type_arguments"));
             Token (Literal "[");
             Opt
               (Seq
                  [
                    Token (Name "element");
                    Repeat (Seq [ Token (Literal ","); Token (Name "element") ]);
                    Opt (Token (Literal ","));
                  ]);
             Token (Literal "]");
           ]) );
    ( "literal",
      Some
        (Alt
           [|
             Token (Name "decimal_integer_literal");
             Token (Name "hex_integer_literal");
             Token (Name "decimal_floating_point_literal");
             Token (Name "true");
             Token (Name "false");
             Token (Name "string_literal");
             Token (Name "null_literal");
             Token (Name "symbol_literal");
             Token (Name "list_literal");
             Token (Name "set_or_map_literal");
           |]) );
    ( "local_function_declaration",
      Some
        (Seq [ Opt (Token (Name "metadata")); Token (Name "lambda_expression") ])
    );
    ( "local_variable_declaration",
      Some
        (Seq
           [
             Token (Name "initialized_variable_definition");
             Token (Name "semicolon");
           ]) );
    ( "logical_and_expression",
      Some
        (Seq
           [
             Token (Name "real_expression");
             Repeat1
               (Seq [ Token (Literal "&&"); Token (Name "real_expression") ]);
           ]) );
    ( "logical_or_expression",
      Some
        (Seq
           [
             Token (Name "real_expression");
             Repeat1
               (Seq [ Token (Literal "||"); Token (Name "real_expression") ]);
           ]) );
    ("metadata", Some (Repeat1 (Token (Name "annotation_"))));
    ( "multiplicative_expression",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "unary_expression");
                 Repeat1
                   (Seq
                      [
                        Token (Name "multiplicative_operator");
                        Token (Name "unary_expression");
                      ]);
               ];
             Seq
               [
                 Token (Name "super");
                 Repeat1
                   (Seq
                      [
                        Token (Name "multiplicative_operator");
                        Token (Name "unary_expression");
                      ]);
               ];
           |]) );
    ( "named_argument",
      Some (Seq [ Token (Name "label"); Token (Name "expression") ]) );
    ( "named_formal_parameters",
      Some
        (Seq
           [
             Token (Literal "{");
             Token (Name "default_named_parameter");
             Repeat
               (Seq
                  [
                    Token (Literal ","); Token (Name "default_named_parameter");
                  ]);
             Opt (Token (Literal ","));
             Token (Literal "}");
           ]) );
    ( "named_parameter_type",
      Some
        (Seq
           [
             Opt (Token (Name "metadata"));
             Opt (Token (Name "required"));
             Token (Name "typed_identifier");
           ]) );
    ( "named_parameter_types",
      Some
        (Seq
           [
             Token (Literal "{");
             Token (Name "named_parameter_type");
             Repeat
               (Seq [ Token (Literal ","); Token (Name "named_parameter_type") ]);
             Opt (Token (Literal ","));
             Token (Literal "}");
           ]) );
    ( "native",
      Some
        (Seq [ Token (Literal "native"); Opt (Token (Name "string_literal")) ])
    );
    ( "new_expression",
      Some
        (Seq
           [
             Token (Name "new_builtin");
             Token (Name "type_not_void");
             Opt (Token (Name "dot_identifier"));
             Token (Name "arguments");
           ]) );
    ( "normal_formal_parameter",
      Some
        (Seq
           [
             Opt (Token (Name "metadata"));
             Alt
               [|
                 Token (Name "function_formal_parameter");
                 Token (Name "simple_formal_parameter");
                 Token (Name "constructor_param");
                 Token (Name "super_formal_parameter");
               |];
           ]) );
    ( "normal_formal_parameters",
      Some
        (Seq
           [
             Token (Name "formal_parameter");
             Repeat
               (Seq [ Token (Literal ","); Token (Name "formal_parameter") ]);
           ]) );
    ( "normal_parameter_type",
      Some
        (Seq
           [
             Opt (Token (Name "metadata"));
             Alt [| Token (Name "typed_identifier"); Token (Name "type") |];
           ]) );
    ( "on_part",
      Some
        (Alt
           [|
             Seq [ Token (Name "catch_clause"); Token (Name "block") ];
             Seq
               [
                 Token (Literal "on");
                 Token (Name "type_not_void");
                 Opt (Token (Name "catch_clause"));
                 Token (Name "block");
               ];
           |]) );
    ( "optional_formal_parameters",
      Some
        (Alt
           [|
             Token (Name "optional_postional_formal_parameters");
             Token (Name "named_formal_parameters");
           |]) );
    ( "optional_parameter_types",
      Some
        (Alt
           [|
             Token (Name "optional_positional_parameter_types");
             Token (Name "named_parameter_types");
           |]) );
    ( "optional_positional_parameter_types",
      Some
        (Seq
           [
             Token (Literal "[");
             Token (Name "normal_parameter_type");
             Repeat
               (Seq
                  [ Token (Literal ","); Token (Name "normal_parameter_type") ]);
             Opt (Token (Literal ","));
             Token (Literal "]");
           ]) );
    ( "optional_postional_formal_parameters",
      Some
        (Seq
           [
             Token (Literal "[");
             Token (Name "default_formal_parameter");
             Repeat
               (Seq
                  [
                    Token (Literal ","); Token (Name "default_formal_parameter");
                  ]);
             Opt (Token (Literal ","));
             Token (Literal "]");
           ]) );
    ( "pair",
      Some
        (Seq
           [
             Token (Name "expression");
             Token (Literal ":");
             Token (Name "expression");
           ]) );
    ( "parameter_type_list",
      Some
        (Seq
           [
             Token (Literal "(");
             Opt
               (Alt
                  [|
                    Seq
                      [
                        Token (Name "normal_parameter_type");
                        Repeat
                          (Seq
                             [
                               Token (Literal ",");
                               Token (Name "normal_parameter_type");
                             ]);
                        Opt (Token (Literal ","));
                      ];
                    Seq
                      [
                        Token (Name "normal_parameter_type");
                        Repeat
                          (Seq
                             [
                               Token (Literal ",");
                               Token (Name "normal_parameter_type");
                             ]);
                        Token (Literal ",");
                        Token (Name "optional_parameter_types");
                      ];
                    Token (Name "optional_parameter_types");
                  |]);
             Token (Literal ")");
           ]) );
    ( "parenthesized_expression",
      Some
        (Seq
           [
             Token (Literal "("); Token (Name "expression"); Token (Literal ")");
           ]) );
    ( "postfix_expression",
      Some
        (Alt
           [|
             Seq [ Token (Name "primary"); Repeat (Token (Name "selector")) ];
             Token (Name "postfix_expression_");
           |]) );
    ( "postfix_expression_",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "assignable_expression");
                 Token (Name "postfix_operator");
               ];
             Seq
               [
                 Token (Name "constructor_invocation");
                 Repeat (Token (Name "selector"));
               ];
           |]) );
    ( "primary",
      Some
        (Alt
           [|
             Token (Name "literal");
             Token (Name "function_expression");
             Token (Name "identifier");
             Token (Name "new_expression");
             Token (Name "const_object_expression");
             Seq
               [
                 Token (Literal "(");
                 Token (Name "expression");
                 Token (Literal ")");
               ];
             Token (Name "this");
             Seq
               [
                 Token (Name "super");
                 Token (Name "unconditional_assignable_selector");
               ];
           |]) );
    ( "real_expression",
      Some
        (Alt
           [|
             Token (Name "conditional_expression");
             Token (Name "logical_or_expression");
             Token (Name "if_null_expression");
             Token (Name "additive_expression");
             Token (Name "multiplicative_expression");
             Token (Name "relational_expression");
             Token (Name "equality_expression");
             Token (Name "logical_and_expression");
             Token (Name "bitwise_and_expression");
             Token (Name "bitwise_or_expression");
             Token (Name "bitwise_xor_expression");
             Token (Name "shift_expression");
             Token (Name "type_cast_expression");
             Token (Name "type_test_expression");
             Token (Name "unary_expression");
           |]) );
    ( "relational_expression",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "real_expression");
                 Token (Name "relational_operator");
                 Token (Name "real_expression");
               ];
             Seq
               [
                 Token (Name "super");
                 Token (Name "relational_operator");
                 Token (Name "real_expression");
               ];
           |]) );
    ( "return_statement",
      Some
        (Seq
           [
             Token (Literal "return");
             Opt (Token (Name "expression"));
             Token (Name "semicolon");
           ]) );
    ( "selector",
      Some
        (Alt
           [|
             Token (Name "exclamation_operator");
             Token (Name "assignable_selector");
             Token (Name "argument_part");
           |]) );
    ( "set_or_map_literal",
      Some
        (Seq
           [
             Opt (Token (Name "const_builtin"));
             Opt (Token (Name "type_arguments"));
             Token (Literal "{");
             Opt
               (Seq
                  [
                    Token (Name "element");
                    Repeat (Seq [ Token (Literal ","); Token (Name "element") ]);
                    Opt (Token (Literal ","));
                  ]);
             Token (Literal "}");
           ]) );
    ( "shift_expression",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "real_expression");
                 Repeat1
                   (Seq
                      [
                        Token (Name "shift_operator");
                        Token (Name "real_expression");
                      ]);
               ];
             Seq
               [
                 Token (Name "super");
                 Repeat1
                   (Seq
                      [
                        Token (Name "shift_operator");
                        Token (Name "real_expression");
                      ]);
               ];
           |]) );
    ( "simple_formal_parameter",
      Some
        (Alt
           [|
             Token (Name "declared_identifier");
             Seq [ Opt (Token (Name "covariant")); Token (Name "identifier") ];
           |]) );
    ( "spread_element",
      Some
        (Seq
           [
             Token (Literal "...");
             Opt (Token (Literal "?"));
             Token (Name "expression");
           ]) );
    ( "statement",
      Some
        (Alt
           [|
             Token (Name "block");
             Token (Name "local_function_declaration");
             Token (Name "local_variable_declaration");
             Token (Name "for_statement");
             Token (Name "while_statement");
             Token (Name "do_statement");
             Token (Name "switch_statement");
             Token (Name "if_statement");
             Token (Name "try_statement");
             Token (Name "break_statement");
             Token (Name "continue_statement");
             Token (Name "return_statement");
             Token (Name "yield_statement");
             Token (Name "yield_each_statement");
             Token (Name "expression_statement");
             Token (Name "assert_statement");
           |]) );
    ( "strict_formal_parameter_list",
      Some
        (Alt
           [|
             Seq [ Token (Literal "("); Token (Literal ")") ];
             Seq
               [
                 Token (Literal "(");
                 Token (Name "normal_formal_parameters");
                 Opt (Token (Literal ","));
                 Token (Literal ")");
               ];
             Seq
               [
                 Token (Literal "(");
                 Token (Name "normal_formal_parameters");
                 Token (Literal ",");
                 Token (Name "optional_formal_parameters");
                 Token (Literal ")");
               ];
             Seq
               [
                 Token (Literal "(");
                 Token (Name "optional_formal_parameters");
                 Token (Literal ")");
               ];
           |]) );
    ( "string_literal",
      Some
        (Repeat1
           (Alt
              [|
                Token (Name "string_literal_double_quotes");
                Token (Name "string_literal_single_quotes");
                Token (Name "string_literal_double_quotes_multiple");
                Token (Name "string_literal_single_quotes_multiple");
                Token (Name "raw_string_literal_double_quotes");
                Token (Name "raw_string_literal_single_quotes");
                Token (Name "raw_string_literal_double_quotes_multiple");
                Token (Name "raw_string_literal_single_quotes_multiple");
              |])) );
    ( "string_literal_double_quotes",
      Some
        (Seq
           [
             Token (Literal "\"");
             Repeat
               (Alt
                  [|
                    Token (Name "template_chars_double_single");
                    Token (Literal "'");
                    Token (Name "escape_sequence");
                    Token (Name "sub_string_test");
                    Token (Name "template_substitution");
                  |]);
             Token (Literal "\"");
           ]) );
    ( "string_literal_double_quotes_multiple",
      Some
        (Seq
           [
             Token (Literal "\"\"\"");
             Repeat
               (Alt
                  [|
                    Token (Name "template_chars_double");
                    Token (Literal "'");
                    Token (Literal "\"");
                    Token (Name "escape_sequence");
                    Token (Name "sub_string_test");
                    Token (Name "template_substitution");
                  |]);
             Token (Literal "\"\"\"");
           ]) );
    ( "string_literal_single_quotes",
      Some
        (Seq
           [
             Token (Literal "'");
             Repeat
               (Alt
                  [|
                    Token (Name "template_chars_single_single");
                    Token (Literal "\"");
                    Token (Name "escape_sequence");
                    Token (Name "sub_string_test");
                    Token (Name "template_substitution");
                  |]);
             Token (Literal "'");
           ]) );
    ( "string_literal_single_quotes_multiple",
      Some
        (Seq
           [
             Token (Literal "'''");
             Repeat
               (Alt
                  [|
                    Token (Name "template_chars_single");
                    Token (Literal "\"");
                    Token (Literal "'");
                    Token (Name "escape_sequence");
                    Token (Name "sub_string_test");
                    Token (Name "template_substitution");
                  |]);
             Token (Literal "'''");
           ]) );
    ( "super_formal_parameter",
      Some
        (Seq
           [
             Opt (Token (Name "final_const_var_or_type"));
             Token (Name "super");
             Token (Literal ".");
             Token (Name "identifier");
             Opt (Token (Name "formal_parameter_part"));
           ]) );
    ( "switch_block",
      Some
        (Seq
           [
             Token (Literal "{");
             Repeat
               (Alt [| Token (Name "switch_label"); Token (Name "statement") |]);
             Token (Literal "}");
           ]) );
    ( "switch_label",
      Some
        (Seq
           [
             Repeat (Token (Name "label"));
             Alt
               [|
                 Seq
                   [
                     Token (Name "case_builtin");
                     Token (Name "expression");
                     Token (Literal ":");
                   ];
                 Seq [ Token (Literal "default"); Token (Literal ":") ];
               |];
           ]) );
    ( "switch_statement",
      Some
        (Seq
           [
             Token (Literal "switch");
             Token (Name "parenthesized_expression");
             Token (Name "switch_block");
           ]) );
    ( "template_substitution",
      Some
        (Seq
           [
             Token (Literal "$");
             Alt
               [|
                 Seq
                   [
                     Token (Literal "{");
                     Token (Name "expression");
                     Token (Literal "}");
                   ];
                 Token (Name "identifier_dollar_escaped");
               |];
           ]) );
    ( "throw_expression",
      Some (Seq [ Token (Literal "throw"); Token (Name "expression") ]) );
    ( "throw_expression_without_cascade",
      Some
        (Seq
           [
             Token (Literal "throw"); Token (Name "expression_without_cascade");
           ]) );
    ("try_head", Some (Seq [ Token (Literal "try"); Token (Name "block") ]));
    ( "try_statement",
      Some
        (Seq
           [
             Token (Name "try_head");
             Alt
               [|
                 Token (Name "finally_clause");
                 Seq
                   [
                     Repeat1 (Token (Name "on_part"));
                     Opt (Token (Name "finally_clause"));
                   ];
               |];
           ]) );
    ( "type",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "function_type");
                 Opt (Token (Name "nullable_type"));
               ];
             Token (Name "type_not_function");
           |]) );
    ( "type_arguments",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Literal "<");
                 Opt
                   (Seq
                      [
                        Token (Name "type");
                        Repeat
                          (Seq [ Token (Literal ","); Token (Name "type") ]);
                      ]);
                 Token (Literal ">");
               ];
           |]) );
    ( "type_bound",
      Some (Seq [ Token (Literal "extends"); Token (Name "type_not_void") ]) );
    ( "type_cast",
      Some (Seq [ Token (Name "as_operator"); Token (Name "type_not_void") ]) );
    ( "type_cast_expression",
      Some (Seq [ Token (Name "real_expression"); Token (Name "type_cast") ]) );
    ( "type_not_function",
      Some
        (Alt
           [|
             Token (Name "type_not_void_not_function"); Token (Name "void_type");
           |]) );
    ( "type_not_void",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "function_type");
                 Opt (Token (Name "nullable_type"));
               ];
             Token (Name "type_not_void_not_function");
           |]) );
    ( "type_not_void_not_function",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "type_name");
                 Opt (Token (Name "type_arguments"));
                 Opt (Token (Name "nullable_type"));
               ];
             Seq
               [
                 Token (Name "function_builtin_identifier");
                 Opt (Token (Name "nullable_type"));
               ];
           |]) );
    ( "type_parameter",
      Some
        (Seq
           [
             Opt (Token (Name "metadata"));
             Token (Name "identifier");
             Opt (Token (Name "nullable_type"));
             Opt (Token (Name "type_bound"));
           ]) );
    ( "type_parameters",
      Some
        (Seq
           [
             Token (Literal "<");
             Token (Name "type_parameter");
             Repeat (Seq [ Token (Literal ","); Token (Name "type_parameter") ]);
             Token (Literal ">");
           ]) );
    ( "type_test",
      Some (Seq [ Token (Name "is_operator"); Token (Name "type_not_void") ]) );
    ( "type_test_expression",
      Some (Seq [ Token (Name "real_expression"); Token (Name "type_test") ]) );
    ( "typed_identifier",
      Some (Seq [ Token (Name "type"); Token (Name "identifier") ]) );
    ( "unary_expression",
      Some
        (Alt
           [|
             Token (Name "postfix_expression"); Token (Name "unary_expression_");
           |]) );
    ( "unary_expression_",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "prefix_operator"); Token (Name "unary_expression");
               ];
             Token (Name "await_expression");
             Seq
               [
                 Alt
                   [|
                     Token (Name "minus_operator");
                     Token (Name "tilde_operator");
                   |];
                 Token (Name "super");
               ];
             Seq
               [
                 Token (Name "increment_operator");
                 Token (Name "assignable_expression");
               ];
           |]) );
    ( "unconditional_assignable_selector",
      Some
        (Alt
           [|
             Seq
               [
                 Opt (Token (Name "nullable_type"));
                 Token (Literal "[");
                 Token (Name "expression");
                 Token (Literal "]");
               ];
             Seq [ Token (Literal "."); Token (Name "identifier") ];
           |]) );
    ( "var_or_type",
      Some
        (Alt
           [|
             Token (Name "type");
             Seq [ Token (Name "inferred_type"); Opt (Token (Name "type")) ];
           |]) );
    ( "while_statement",
      Some
        (Seq
           [
             Token (Literal "while");
             Token (Name "parenthesized_expression");
             Token (Name "statement");
           ]) );
    ( "yield_each_statement",
      Some
        (Seq
           [
             Token (Literal "yield");
             Token (Literal "*");
             Token (Name "expression");
             Token (Name "semicolon");
           ]) );
    ( "yield_statement",
      Some
        (Seq
           [
             Token (Literal "yield");
             Token (Name "expression");
             Token (Name "semicolon");
           ]) );
    ( "uri_test",
      Some
        (Seq
           [
             Token (Name "dotted_identifier_list");
             Opt (Seq [ Token (Literal "=="); Token (Name "string_literal") ]);
           ]) );
    ( "constant_constructor_signature",
      Some
        (Seq
           [
             Token (Name "const_builtin");
             Token (Name "qualified");
             Token (Name "formal_parameter_list");
           ]) );
    ( "getter_signature",
      Some
        (Seq
           [
             Opt (Token (Name "type"));
             Token (Name "get");
             Token (Name "identifier");
             Opt (Token (Name "native"));
           ]) );
    ( "library_name",
      Some
        (Seq
           [
             Opt (Token (Name "metadata"));
             Token (Literal "library");
             Token (Name "dotted_identifier_list");
             Token (Name "semicolon");
           ]) );
    ( "redirecting_factory_constructor_signature",
      Some
        (Seq
           [
             Opt (Token (Name "const_builtin"));
             Token (Name "factory");
             Token (Name "identifier");
             Repeat (Seq [ Token (Literal "."); Token (Name "identifier") ]);
             Token (Name "formal_parameter_list");
             Token (Literal "=");
             Token (Name "type_not_void");
             Opt (Seq [ Token (Literal "."); Token (Name "identifier") ]);
           ]) );
    ("uri", Some (Token (Name "string_literal")));
    ( "redirection",
      Some
        (Seq
           [
             Token (Literal ":");
             Token (Name "this");
             Opt (Seq [ Token (Literal "."); Token (Name "identifier") ]);
             Token (Name "arguments");
           ]) );
    ( "field_initializer",
      Some
        (Seq
           [
             Opt (Seq [ Token (Name "this"); Token (Literal ".") ]);
             Token (Name "identifier");
             Token (Literal "=");
             Token (Name "real_expression");
             Repeat (Token (Name "cascade_section"));
           ]) );
    ( "setter_signature",
      Some
        (Seq
           [
             Opt (Token (Name "type"));
             Token (Name "set");
             Token (Name "identifier");
             Token (Name "formal_parameter_part");
             Opt (Token (Name "native"));
           ]) );
    ( "constructor_signature",
      Some
        (Seq
           [
             Token (Name "identifier");
             Opt (Seq [ Token (Literal "."); Token (Name "identifier") ]);
             Token (Name "formal_parameter_list");
           ]) );
    ( "semgrep_expression",
      Some
        (Seq
           [ Token (Literal "__SEMGREP_EXPRESSION"); Token (Name "expression") ])
    );
    ( "static_final_declaration",
      Some
        (Seq
           [
             Token (Name "identifier");
             Token (Literal "=");
             Token (Name "expression");
           ]) );
    ( "factory_constructor_signature",
      Some
        (Seq
           [
             Token (Name "factory");
             Token (Name "identifier");
             Repeat (Seq [ Token (Literal "."); Token (Name "identifier") ]);
             Token (Name "formal_parameter_list");
           ]) );
    ( "type_not_void_list",
      Some
        (Seq
           [
             Token (Name "type_not_void");
             Repeat (Seq [ Token (Literal ","); Token (Name "type_not_void") ]);
           ]) );
    ( "enum_constant",
      Some (Seq [ Opt (Token (Name "metadata")); Token (Name "identifier") ]) );
    ( "type_alias",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "typedef");
                 Token (Name "type_name");
                 Opt (Token (Name "type_parameters"));
                 Token (Literal "=");
                 Token (Name "function_type");
                 Token (Literal ";");
               ];
             Seq
               [
                 Token (Name "typedef");
                 Opt (Token (Name "type"));
                 Token (Name "type_name");
                 Token (Name "formal_parameter_part");
                 Token (Literal ";");
               ];
           |]) );
    ( "operator_signature",
      Some
        (Seq
           [
             Opt (Token (Name "type"));
             Token (Name "operator");
             Alt
               [|
                 Token (Literal "~");
                 Token (Name "binary_operator");
                 Token (Literal "[]");
                 Token (Literal "[]=");
               |];
             Token (Name "formal_parameter_list");
             Opt (Token (Name "native"));
           ]) );
    ( "initialized_identifier_list",
      Some
        (Seq
           [
             Token (Name "initialized_identifier");
             Repeat
               (Seq
                  [ Token (Literal ","); Token (Name "initialized_identifier") ]);
           ]) );
    ( "part_of_directive",
      Some
        (Seq
           [
             Opt (Token (Name "metadata"));
             Token (Literal "part");
             Token (Literal "of");
             Alt [| Token (Name "dotted_identifier_list"); Token (Name "uri") |];
             Token (Name "semicolon");
           ]) );
    ( "part_directive",
      Some
        (Seq
           [
             Opt (Token (Name "metadata"));
             Token (Literal "part");
             Token (Name "uri");
             Token (Name "semicolon");
           ]) );
    ( "configuration_uri",
      Some
        (Seq
           [
             Token (Literal "if");
             Token (Literal "(");
             Token (Name "uri_test");
             Token (Literal ")");
             Token (Name "uri");
           ]) );
    ( "initializer_list_entry",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Literal "super");
                 Opt (Seq [ Token (Literal "."); Token (Name "qualified") ]);
                 Token (Name "arguments");
               ];
             Token (Name "field_initializer");
             Token (Name "assertion");
           |]) );
    ( "static_final_declaration_list",
      Some
        (Seq
           [
             Token (Name "static_final_declaration");
             Repeat
               (Seq
                  [
                    Token (Literal ","); Token (Name "static_final_declaration");
                  ]);
           ]) );
    ( "mixins",
      Some (Seq [ Token (Literal "with"); Token (Name "type_not_void_list") ])
    );
    ( "interfaces",
      Some
        (Seq [ Token (Name "implements"); Token (Name "type_not_void_list") ])
    );
    ( "enum_body",
      Some
        (Seq
           [
             Token (Literal "{");
             Token (Name "enum_constant");
             Repeat (Seq [ Token (Literal ","); Token (Name "enum_constant") ]);
             Opt (Token (Literal ","));
             Token (Literal "}");
           ]) );
    ( "configurable_uri",
      Some
        (Seq [ Token (Name "uri"); Repeat (Token (Name "configuration_uri")) ])
    );
    ( "initializers",
      Some
        (Seq
           [
             Token (Literal ":");
             Token (Name "initializer_list_entry");
             Repeat
               (Seq
                  [ Token (Literal ","); Token (Name "initializer_list_entry") ]);
           ]) );
    ( "superclass",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Literal "extends");
                 Token (Name "type_not_void");
                 Opt (Token (Name "mixins"));
               ];
             Token (Name "mixins");
           |]) );
    ( "mixin_application",
      Some
        (Seq
           [
             Token (Name "type_not_void");
             Token (Name "mixins");
             Opt (Token (Name "interfaces"));
           ]) );
    ( "enum_declaration",
      Some
        (Seq
           [
             Token (Literal "enum");
             Token (Name "identifier");
             Token (Name "enum_body");
           ]) );
    ( "import_specification",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "import");
                 Token (Name "configurable_uri");
                 Opt (Seq [ Token (Name "as"); Token (Name "identifier") ]);
                 Repeat (Token (Name "combinator"));
                 Token (Name "semicolon");
               ];
             Seq
               [
                 Token (Name "import");
                 Token (Name "uri");
                 Token (Name "deferred");
                 Token (Name "as");
                 Token (Name "identifier");
                 Repeat (Token (Name "combinator"));
                 Token (Name "semicolon");
               ];
           |]) );
    ( "library_export",
      Some
        (Seq
           [
             Opt (Token (Name "metadata"));
             Token (Name "export");
             Token (Name "configurable_uri");
             Repeat (Token (Name "combinator"));
             Token (Name "semicolon");
           ]) );
    ( "method_signature",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "constructor_signature");
                 Opt (Token (Name "initializers"));
               ];
             Token (Name "factory_constructor_signature");
             Seq
               [
                 Opt (Token (Name "static"));
                 Alt
                   [|
                     Token (Name "function_signature");
                     Token (Name "getter_signature");
                     Token (Name "setter_signature");
                   |];
               ];
             Token (Name "operator_signature");
           |]) );
    ( "declaration_",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Name "constant_constructor_signature");
                 Opt
                   (Alt
                      [|
                        Token (Name "redirection"); Token (Name "initializers");
                      |]);
               ];
             Seq
               [
                 Token (Name "constructor_signature");
                 Opt
                   (Alt
                      [|
                        Token (Name "redirection"); Token (Name "initializers");
                      |]);
               ];
             Seq
               [
                 Token (Name "external");
                 Opt (Token (Name "const_builtin"));
                 Token (Name "factory_constructor_signature");
               ];
             Seq
               [
                 Opt (Token (Name "const_builtin"));
                 Token (Name "factory_constructor_signature");
                 Token (Name "native");
               ];
             Seq
               [
                 Token (Name "external");
                 Token (Name "constant_constructor_signature");
               ];
             Token (Name "redirecting_factory_constructor_signature");
             Seq
               [ Token (Name "external"); Token (Name "constructor_signature") ];
             Seq
               [
                 Opt (Token (Name "external_builtin"));
                 Opt (Token (Name "static"));
                 Token (Name "getter_signature");
               ];
             Seq
               [
                 Opt (Token (Name "external_and_static"));
                 Token (Name "setter_signature");
               ];
             Seq
               [
                 Opt (Token (Name "external"));
                 Token (Name "operator_signature");
               ];
             Seq
               [
                 Opt (Token (Name "external_and_static"));
                 Token (Name "function_signature");
               ];
             Seq [ Token (Name "static"); Token (Name "function_signature") ];
             Seq
               [
                 Token (Name "static");
                 Alt
                   [|
                     Seq
                       [
                         Token (Name "final_or_const");
                         Opt (Token (Name "type"));
                         Token (Name "static_final_declaration_list");
                       ];
                     Seq
                       [
                         Token (Name "late_builtin");
                         Alt
                           [|
                             Seq
                               [
                                 Token (Name "final_builtin");
                                 Opt (Token (Name "type"));
                                 Token (Name "initialized_identifier_list");
                               ];
                             Seq
                               [
                                 Alt
                                   [|
                                     Token (Name "type");
                                     Token (Name "inferred_type");
                                   |];
                                 Token (Name "initialized_identifier_list");
                               ];
                           |];
                       ];
                     Seq
                       [
                         Alt
                           [|
                             Token (Name "type"); Token (Name "inferred_type");
                           |];
                         Token (Name "initialized_identifier_list");
                       ];
                   |];
               ];
             Seq
               [
                 Token (Name "covariant");
                 Alt
                   [|
                     Seq
                       [
                         Token (Name "late_builtin");
                         Alt
                           [|
                             Seq
                               [
                                 Token (Name "final_builtin");
                                 Opt (Token (Name "type"));
                                 Token (Name "identifier_list_");
                               ];
                             Seq
                               [
                                 Alt
                                   [|
                                     Token (Name "type");
                                     Token (Name "inferred_type");
                                   |];
                                 Token (Name "initialized_identifier_list");
                               ];
                           |];
                       ];
                     Seq
                       [
                         Alt
                           [|
                             Token (Name "type"); Token (Name "inferred_type");
                           |];
                         Token (Name "initialized_identifier_list");
                       ];
                   |];
               ];
             Seq
               [
                 Opt (Token (Name "late_builtin"));
                 Token (Name "final_builtin");
                 Opt (Token (Name "type"));
                 Token (Name "initialized_identifier_list");
               ];
             Seq
               [
                 Opt (Token (Name "late_builtin"));
                 Token (Name "var_or_type");
                 Token (Name "initialized_identifier_list");
               ];
           |]) );
    ( "mixin_application_class",
      Some
        (Seq
           [
             Token (Name "identifier");
             Opt (Token (Name "type_parameters"));
             Token (Literal "=");
             Token (Name "mixin_application");
             Token (Name "semicolon");
           ]) );
    ( "library_import",
      Some
        (Seq
           [
             Opt (Token (Name "metadata")); Token (Name "import_specification");
           ]) );
    ( "extension_body",
      Some
        (Seq
           [
             Token (Literal "{");
             Repeat
               (Alt
                  [|
                    Seq
                      [
                        Opt (Token (Name "metadata"));
                        Token (Name "declaration_");
                        Token (Name "semicolon");
                      ];
                    Seq
                      [
                        Opt (Token (Name "metadata"));
                        Token (Name "method_signature");
                        Token (Name "function_body");
                      ];
                  |]);
             Token (Literal "}");
           ]) );
    ( "class_body",
      Some
        (Seq
           [
             Token (Literal "{");
             Repeat
               (Seq
                  [
                    Opt (Token (Name "metadata"));
                    Alt
                      [|
                        Seq
                          [
                            Token (Name "declaration_");
                            Token (Name "semicolon");
                          ];
                        Seq
                          [
                            Token (Name "method_signature");
                            Token (Name "function_body");
                          ];
                      |];
                  ]);
             Token (Literal "}");
           ]) );
    ( "import_or_export",
      Some
        (Alt [| Token (Name "library_import"); Token (Name "library_export") |])
    );
    ( "extension_declaration",
      Some
        (Alt
           [|
             Seq
               [
                 Token (Literal "extension");
                 Opt (Token (Name "identifier"));
                 Opt (Token (Name "type_parameters"));
                 Token (Literal "on");
                 Token (Name "type");
                 Token (Name "extension_body");
               ];
           |]) );
    ( "class_definition",
      Some
        (Alt
           [|
             Seq
               [
                 Opt (Token (Literal "abstract"));
                 Token (Literal "class");
                 Token (Name "identifier");
                 Opt (Token (Name "type_parameters"));
                 Opt (Token (Name "superclass"));
                 Opt (Token (Name "interfaces"));
                 Token (Name "class_body");
               ];
             Seq
               [
                 Opt (Token (Name "metadata"));
                 Opt (Token (Literal "abstract"));
                 Token (Literal "class");
                 Token (Name "mixin_application_class");
               ];
           |]) );
    ( "mixin_declaration",
      Some
        (Seq
           [
             Token (Name "mixin");
             Token (Name "identifier");
             Opt (Token (Name "type_parameters"));
             Opt
               (Seq [ Token (Literal "on"); Token (Name "type_not_void_list") ]);
             Opt (Token (Name "interfaces"));
             Token (Name "class_body");
           ]) );
    ( "top_level_definition",
      Some
        (Alt
           [|
             Token (Name "class_definition");
             Token (Name "enum_declaration");
             Token (Name "extension_declaration");
             Token (Name "mixin_declaration");
             Token (Name "type_alias");
             Seq
               [
                 Opt (Token (Name "external_builtin"));
                 Token (Name "function_signature");
                 Token (Name "semicolon");
               ];
             Seq
               [
                 Opt (Token (Name "external_builtin"));
                 Token (Name "getter_signature");
                 Token (Name "semicolon");
               ];
             Seq
               [
                 Opt (Token (Name "external_builtin"));
                 Token (Name "setter_signature");
                 Token (Name "semicolon");
               ];
             Seq
               [
                 Token (Name "function_signature"); Token (Name "function_body");
               ];
             Seq
               [ Token (Name "getter_signature"); Token (Name "function_body") ];
             Seq
               [ Token (Name "setter_signature"); Token (Name "function_body") ];
             Seq
               [
                 Alt
                   [|
                     Token (Name "final_builtin"); Token (Name "const_builtin");
                   |];
                 Opt (Token (Name "type"));
                 Token (Name "static_final_declaration_list");
                 Token (Name "semicolon");
               ];
             Seq
               [
                 Token (Name "late_builtin");
                 Token (Name "final_builtin");
                 Opt (Token (Name "type"));
                 Token (Name "initialized_identifier_list");
                 Token (Name "semicolon");
               ];
             Seq
               [
                 Opt (Token (Name "late_builtin"));
                 Alt
                   [|
                     Token (Name "type");
                     Seq
                       [
                         Token (Name "inferred_type"); Opt (Token (Name "type"));
                       ];
                   |];
                 Token (Name "initialized_identifier_list");
                 Token (Name "semicolon");
               ];
           |]) );
    ( "program",
      Some
        (Alt
           [|
             Seq
               [
                 Opt (Token (Name "script_tag"));
                 Opt (Token (Name "library_name"));
                 Repeat (Token (Name "import_or_export"));
                 Repeat (Token (Name "part_directive"));
                 Repeat (Token (Name "part_of_directive"));
                 Repeat
                   (Seq
                      [
                        Opt (Token (Name "metadata"));
                        Token (Name "top_level_definition");
                      ]);
                 Repeat (Token (Name "statement"));
               ];
             Token (Name "semgrep_expression");
           |]) );
  ]

let trans_equality_operator ((kind, body) : mt) : CST.equality_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_increment_operator ((kind, body) : mt) : CST.increment_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_this ((kind, body) : mt) : CST.this =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_exclamation_operator ((kind, body) : mt) : CST.exclamation_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_as_ ((kind, body) : mt) : CST.as_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_mixin ((kind, body) : mt) : CST.mixin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_new_builtin ((kind, body) : mt) : CST.new_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_set ((kind, body) : mt) : CST.set =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_break_builtin ((kind, body) : mt) : CST.break_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_inferred_type ((kind, body) : mt) : CST.inferred_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_unused_escape_sequence ((kind, body) : mt) :
    CST.unused_escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_single ((kind, body) : mt) : CST.template_chars_single
    =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_ellipsis ((kind, body) : mt) : CST.semgrep_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_minus_operator ((kind, body) : mt) : CST.minus_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_export ((kind, body) : mt) : CST.export =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_import ((kind, body) : mt) : CST.import =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_hex_integer_literal ((kind, body) : mt) : CST.hex_integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_multiplicative_operator_ ((kind, body) : mt) :
    CST.multiplicative_operator_ =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `STAR (Run.trans_token (Run.matcher_token v))
      | Alt (1, v) -> `SLASH (Run.trans_token (Run.matcher_token v))
      | Alt (2, v) -> `PERC (Run.trans_token (Run.matcher_token v))
      | Alt (3, v) -> `TILDESLASH (Run.trans_token (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_decimal_integer_literal ((kind, body) : mt) :
    CST.decimal_integer_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_implements ((kind, body) : mt) : CST.implements =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_get ((kind, body) : mt) : CST.get =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_a3d33dc ((kind, body) : mt) : CST.pat_a3d33dc =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_bitwise_operator ((kind, body) : mt) : CST.bitwise_operator =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `AMP (Run.trans_token (Run.matcher_token v))
      | Alt (1, v) -> `HAT (Run.trans_token (Run.matcher_token v))
      | Alt (2, v) -> `BAR (Run.trans_token (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_semgrep_named_ellipsis ((kind, body) : mt) :
    CST.semgrep_named_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_case_builtin ((kind, body) : mt) : CST.case_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_deferred ((kind, body) : mt) : CST.deferred =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_function_builtin_identifier ((kind, body) : mt) :
    CST.function_builtin_identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_factory ((kind, body) : mt) : CST.factory =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_static ((kind, body) : mt) : CST.static =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_external_builtin ((kind, body) : mt) : CST.external_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_single_single ((kind, body) : mt) :
    CST.template_chars_single_single =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_double ((kind, body) : mt) : CST.template_chars_double
    =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_assert_builtin ((kind, body) : mt) : CST.assert_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semicolon ((kind, body) : mt) : CST.semicolon =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0 ] -> Run.trans_token (Run.matcher_token v0)
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_required ((kind, body) : mt) : CST.required =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_super ((kind, body) : mt) : CST.super =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_nullable_type ((kind, body) : mt) : CST.nullable_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tok_is ((kind, body) : mt) : CST.tok_is =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_covariant ((kind, body) : mt) : CST.covariant =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_null_literal ((kind, body) : mt) : CST.null_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_tilde_operator ((kind, body) : mt) : CST.tilde_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_shift_operator_ ((kind, body) : mt) : CST.shift_operator_ =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `LTLT (Run.trans_token (Run.matcher_token v))
      | Alt (1, v) -> `GTGT (Run.trans_token (Run.matcher_token v))
      | Alt (2, v) -> `GTGTGT (Run.trans_token (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_as_operator ((kind, body) : mt) : CST.as_operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_void_type ((kind, body) : mt) : CST.void_type =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_double_single ((kind, body) : mt) :
    CST.template_chars_double_single =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_template_chars_raw_slash ((kind, body) : mt) :
    CST.template_chars_raw_slash =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier_dollar_escaped ((kind, body) : mt) :
    CST.identifier_dollar_escaped =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_operator ((kind, body) : mt) : CST.operator =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_final_builtin ((kind, body) : mt) : CST.final_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_pat_0017fb0 ((kind, body) : mt) : CST.pat_0017fb0 =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_late_builtin ((kind, body) : mt) : CST.late_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_relational_operator ((kind, body) : mt) : CST.relational_operator =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `LT (Run.trans_token (Run.matcher_token v))
      | Alt (1, v) -> `GT (Run.trans_token (Run.matcher_token v))
      | Alt (2, v) -> `LTEQ (Run.trans_token (Run.matcher_token v))
      | Alt (3, v) -> `GTEQ (Run.trans_token (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_assignment_operator ((kind, body) : mt) : CST.assignment_operator =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `EQ (Run.trans_token (Run.matcher_token v))
      | Alt (1, v) -> `PLUSEQ (Run.trans_token (Run.matcher_token v))
      | Alt (2, v) -> `DASHEQ (Run.trans_token (Run.matcher_token v))
      | Alt (3, v) -> `STAREQ (Run.trans_token (Run.matcher_token v))
      | Alt (4, v) -> `SLASHEQ (Run.trans_token (Run.matcher_token v))
      | Alt (5, v) -> `PERCEQ (Run.trans_token (Run.matcher_token v))
      | Alt (6, v) -> `TILDESLASHEQ (Run.trans_token (Run.matcher_token v))
      | Alt (7, v) -> `LTLTEQ (Run.trans_token (Run.matcher_token v))
      | Alt (8, v) -> `GTGTEQ (Run.trans_token (Run.matcher_token v))
      | Alt (9, v) -> `GTGTGTEQ (Run.trans_token (Run.matcher_token v))
      | Alt (10, v) -> `AMPEQ (Run.trans_token (Run.matcher_token v))
      | Alt (11, v) -> `HATEQ (Run.trans_token (Run.matcher_token v))
      | Alt (12, v) -> `BAREQ (Run.trans_token (Run.matcher_token v))
      | Alt (13, v) -> `QMARKQMARKEQ (Run.trans_token (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_decimal_floating_point_literal ((kind, body) : mt) :
    CST.decimal_floating_point_literal =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_const_builtin ((kind, body) : mt) : CST.const_builtin =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_typedef ((kind, body) : mt) : CST.typedef =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_additive_operator_ ((kind, body) : mt) : CST.additive_operator_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_postfix_operator ((kind, body) : mt) : CST.postfix_operator =
  match body with
  | Children v -> trans_increment_operator (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_negation_operator ((kind, body) : mt) : CST.negation_operator =
  match body with
  | Children v -> trans_exclamation_operator (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Children v -> trans_unused_escape_sequence (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_multiplicative_operator ((kind, body) : mt) :
    CST.multiplicative_operator =
  match body with
  | Children v -> trans_multiplicative_operator_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_sub_string_test ((kind, body) : mt) : CST.sub_string_test =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_pat_a3d33dc (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_bitwise_operator_ ((kind, body) : mt) : CST.bitwise_operator_ =
  match body with
  | Children v -> trans_bitwise_operator (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_external_ ((kind, body) : mt) : CST.external_ =
  match body with
  | Children v -> trans_external_builtin (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_is_operator ((kind, body) : mt) : CST.is_operator =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_tok_is (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_exclamation_operator (Run.matcher_token v))
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_catch_clause ((kind, body) : mt) : CST.catch_clause =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v3,
            Run.trans_token (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_symbol_literal ((kind, body) : mt) : CST.symbol_literal =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_dotted_identifier_list ((kind, body) : mt) :
    CST.dotted_identifier_list =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_qualified ((kind, body) : mt) : CST.qualified =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_break_statement ((kind, body) : mt) : CST.break_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( trans_break_builtin (Run.matcher_token v0),
            Run.opt (fun v -> trans_identifier (Run.matcher_token v)) v1,
            trans_semicolon (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_conditional_assignable_selector ((kind, body) : mt) :
    CST.conditional_assignable_selector =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_type_dot_identifier ((kind, body) : mt) : CST.type_dot_identifier =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_label ((kind, body) : mt) : CST.label =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_identifier_list_ ((kind, body) : mt) : CST.identifier_list_ =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let rec trans_scoped_identifier ((kind, body) : mt) : CST.scoped_identifier =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( (match v0 with
            | Alt (0, v) -> `Id (trans_identifier (Run.matcher_token v))
            | Alt (1, v) ->
                `Scoped_id (trans_scoped_identifier (Run.matcher_token v))
            | _ -> assert false),
            Run.trans_token (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_identifier_list ((kind, body) : mt) : CST.identifier_list =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_dot_identifier ((kind, body) : mt) : CST.dot_identifier =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_continue_statement ((kind, body) : mt) : CST.continue_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.opt (fun v -> trans_identifier (Run.matcher_token v)) v1,
            trans_semicolon (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_shift_operator ((kind, body) : mt) : CST.shift_operator =
  match body with
  | Children v -> trans_shift_operator_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_script_tag ((kind, body) : mt) : CST.script_tag =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_pat_0017fb0 (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_final_or_const ((kind, body) : mt) : CST.final_or_const =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Final_buil (trans_final_builtin (Run.matcher_token v))
      | Alt (1, v) -> `Const_buil (trans_const_builtin (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_additive_operator ((kind, body) : mt) : CST.additive_operator =
  match body with
  | Children v -> trans_additive_operator_ (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_prefix_operator ((kind, body) : mt) : CST.prefix_operator =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Minus_op (trans_minus_operator (Run.matcher_token v))
      | Alt (1, v) -> `Nega_op (trans_negation_operator (Run.matcher_token v))
      | Alt (2, v) -> `Tilde_op (trans_tilde_operator (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_raw_string_literal_double_quotes ((kind, body) : mt) :
    CST.raw_string_literal_double_quotes =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Temp_chars_double_single
                      (trans_template_chars_double_single (Run.matcher_token v))
                | Alt (1, v) -> `SQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (2, v) ->
                    `Temp_chars_raw_slash
                      (trans_template_chars_raw_slash (Run.matcher_token v))
                | Alt (3, v) ->
                    `Unused_esc_seq
                      (trans_unused_escape_sequence (Run.matcher_token v))
                | Alt (4, v) ->
                    `Sub_str_test (trans_sub_string_test (Run.matcher_token v))
                | Alt (5, v) -> `DOLLAR (Run.trans_token (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_raw_string_literal_double_quotes_multiple ((kind, body) : mt) :
    CST.raw_string_literal_double_quotes_multiple =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Temp_chars_double
                      (trans_template_chars_double (Run.matcher_token v))
                | Alt (1, v) -> `SQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (2, v) ->
                    `Temp_chars_raw_slash
                      (trans_template_chars_raw_slash (Run.matcher_token v))
                | Alt (3, v) -> `DQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (4, v) ->
                    `Unused_esc_seq
                      (trans_unused_escape_sequence (Run.matcher_token v))
                | Alt (5, v) ->
                    `Sub_str_test (trans_sub_string_test (Run.matcher_token v))
                | Alt (6, v) -> `DOLLAR (Run.trans_token (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_raw_string_literal_single_quotes ((kind, body) : mt) :
    CST.raw_string_literal_single_quotes =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Temp_chars_single_single
                      (trans_template_chars_single_single (Run.matcher_token v))
                | Alt (1, v) -> `DQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (2, v) ->
                    `Temp_chars_raw_slash
                      (trans_template_chars_raw_slash (Run.matcher_token v))
                | Alt (3, v) ->
                    `Unused_esc_seq
                      (trans_unused_escape_sequence (Run.matcher_token v))
                | Alt (4, v) ->
                    `Sub_str_test (trans_sub_string_test (Run.matcher_token v))
                | Alt (5, v) -> `DOLLAR (Run.trans_token (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_raw_string_literal_single_quotes_multiple ((kind, body) : mt) :
    CST.raw_string_literal_single_quotes_multiple =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Temp_chars_single
                      (trans_template_chars_single (Run.matcher_token v))
                | Alt (1, v) -> `DQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (2, v) -> `SQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (3, v) ->
                    `Temp_chars_raw_slash
                      (trans_template_chars_raw_slash (Run.matcher_token v))
                | Alt (4, v) ->
                    `Unused_esc_seq
                      (trans_unused_escape_sequence (Run.matcher_token v))
                | Alt (5, v) ->
                    `Sub_str_test (trans_sub_string_test (Run.matcher_token v))
                | Alt (6, v) -> `DOLLAR (Run.trans_token (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_external_and_static ((kind, body) : mt) : CST.external_and_static =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_external_ (Run.matcher_token v0),
            Run.opt (fun v -> trans_static (Run.matcher_token v)) v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_type_name ((kind, body) : mt) : CST.type_name =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v -> trans_type_dot_identifier (Run.matcher_token v))
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_marker_annotation ((kind, body) : mt) : CST.marker_annotation =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] -> (
          ( Run.trans_token (Run.matcher_token v0),
            match v1 with
            | Alt (0, v) -> `Id (trans_identifier (Run.matcher_token v))
            | Alt (1, v) ->
                `Scoped_id (trans_scoped_identifier (Run.matcher_token v))
            | _ -> assert false ))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_combinator ((kind, body) : mt) : CST.combinator =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Show_id_list
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  trans_identifier_list (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Hide_id_list
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  trans_identifier_list (Run.matcher_token v1) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_binary_operator ((kind, body) : mt) : CST.binary_operator =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Mult_op (trans_multiplicative_operator (Run.matcher_token v))
      | Alt (1, v) -> `Addi_op (trans_additive_operator (Run.matcher_token v))
      | Alt (2, v) -> `Shift_op (trans_shift_operator (Run.matcher_token v))
      | Alt (3, v) -> `Rela_op (trans_relational_operator (Run.matcher_token v))
      | Alt (4, v) -> `EQEQ (Run.trans_token (Run.matcher_token v))
      | Alt (5, v) -> `Bitw_op_ (trans_bitwise_operator_ (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let rec trans_additive_expression ((kind, body) : mt) : CST.additive_expression
    =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Real_exp_rep1_addi_op_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( trans_additive_operator (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Super_rep1_addi_op_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( trans_additive_operator (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_annotation ((kind, body) : mt) : CST.annotation =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            (match v1 with
            | Alt (0, v) -> `Id (trans_identifier (Run.matcher_token v))
            | Alt (1, v) ->
                `Scoped_id (trans_scoped_identifier (Run.matcher_token v))
            | _ -> assert false),
            trans_arguments (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_annotation_ ((kind, body) : mt) : CST.annotation_ =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Marker_anno (trans_marker_annotation (Run.matcher_token v))
      | Alt (1, v) -> `Anno (trans_annotation (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_argument ((kind, body) : mt) : CST.argument =
  match body with
  | Children v -> trans_expression (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_argument_list ((kind, body) : mt) : CST.argument_list =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Named_arg_rep_COMMA_named_arg
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_named_argument (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_named_argument (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Arg_rep_COMMA_arg_rep_COMMA_named_arg_rep_COMMA_named_arg
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( trans_argument (Run.matcher_token v0),
                  Run.repeat
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_argument (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1,
                  Run.repeat
                    (fun v ->
                      match v with
                      | Seq [ v0; v1; v2 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_named_argument (Run.matcher_token v1),
                            Run.repeat
                              (fun v ->
                                match v with
                                | Seq [ v0; v1 ] ->
                                    ( Run.trans_token (Run.matcher_token v0),
                                      trans_named_argument
                                        (Run.matcher_token v1) )
                                | _ -> assert false)
                              v2 )
                      | _ -> assert false)
                    v2 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_argument_part ((kind, body) : mt) : CST.argument_part =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.opt (fun v -> trans_type_arguments (Run.matcher_token v)) v0,
            trans_arguments (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_arguments ((kind, body) : mt) : CST.arguments =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( trans_argument_list (Run.matcher_token v0),
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v1 )
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_assert_statement ((kind, body) : mt) : CST.assert_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_assertion (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_assertion ((kind, body) : mt) : CST.assertion =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4; v5 ] ->
          ( trans_assert_builtin (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1) )
                | _ -> assert false)
              v3,
            Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v4,
            Run.trans_token (Run.matcher_token v5) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_assignable_expression ((kind, body) : mt) : CST.assignable_expression
    =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Prim_assi_sele_part
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_primary (Run.matcher_token v0),
                  trans_assignable_selector_part (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Super_unco_assi_sele
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_super (Run.matcher_token v0),
                  trans_unconditional_assignable_selector (Run.matcher_token v1)
                )
            | _ -> assert false)
      | Alt (2, v) ->
          `Cons_invo_assi_sele_part
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_constructor_invocation (Run.matcher_token v0),
                  trans_assignable_selector_part (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (3, v) -> `Id (trans_identifier (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_assignable_selector ((kind, body) : mt) : CST.assignable_selector =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Unco_assi_sele
            (trans_unconditional_assignable_selector (Run.matcher_token v))
      | Alt (1, v) ->
          `Cond_assi_sele
            (trans_conditional_assignable_selector (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_assignable_selector_part ((kind, body) : mt) :
    CST.assignable_selector_part =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.repeat (fun v -> trans_selector (Run.matcher_token v)) v0,
            trans_assignable_selector (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_assignment_expression ((kind, body) : mt) : CST.assignment_expression
    =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( trans_assignable_expression (Run.matcher_token v0),
            trans_assignment_operator (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_assignment_expression_without_cascade ((kind, body) : mt) :
    CST.assignment_expression_without_cascade =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( trans_assignable_expression (Run.matcher_token v0),
            trans_assignment_operator (Run.matcher_token v1),
            trans_expression_without_cascade (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_await_expression ((kind, body) : mt) : CST.await_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_unary_expression (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_bitwise_and_expression ((kind, body) : mt) :
    CST.bitwise_and_expression =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Real_exp_rep1_AMP_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Super_rep1_AMP_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_bitwise_or_expression ((kind, body) : mt) : CST.bitwise_or_expression
    =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Real_exp_rep1_BAR_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Super_rep1_BAR_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_bitwise_xor_expression ((kind, body) : mt) :
    CST.bitwise_xor_expression =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Real_exp_rep1_HAT_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Super_rep1_HAT_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_block ((kind, body) : mt) : CST.block =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat (fun v -> trans_statement (Run.matcher_token v)) v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_cascade_assignment_section ((kind, body) : mt) :
    CST.cascade_assignment_section =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_assignment_operator (Run.matcher_token v0),
            trans_expression_without_cascade (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_cascade_section ((kind, body) : mt) : CST.cascade_section =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( (match v0 with
            | Alt (0, v) -> `DOTDOT (Run.trans_token (Run.matcher_token v))
            | Alt (1, v) -> `QMARKDOTDOT (Run.trans_token (Run.matcher_token v))
            | _ -> assert false),
            trans_cascade_selector (Run.matcher_token v1),
            Run.repeat (fun v -> trans_argument_part (Run.matcher_token v)) v2,
            Run.repeat
              (fun v -> trans_cascade_subsection (Run.matcher_token v))
              v3,
            Run.opt
              (fun v -> trans_cascade_assignment_section (Run.matcher_token v))
              v4 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_cascade_selector ((kind, body) : mt) : CST.cascade_selector =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_null_type_LBRACK_exp_RBRACK
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( Run.opt (fun v -> trans_nullable_type (Run.matcher_token v)) v0,
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3) )
            | _ -> assert false)
      | Alt (1, v) -> `Id (trans_identifier (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_cascade_subsection ((kind, body) : mt) : CST.cascade_subsection =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_assignable_selector (Run.matcher_token v0),
            Run.repeat (fun v -> trans_argument_part (Run.matcher_token v)) v1
          )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_conditional_expression ((kind, body) : mt) :
    CST.conditional_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( trans_real_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression_without_cascade (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_expression_without_cascade (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_const_object_expression ((kind, body) : mt) :
    CST.const_object_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( trans_const_builtin (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1),
            Run.opt (fun v -> trans_dot_identifier (Run.matcher_token v)) v2,
            trans_arguments (Run.matcher_token v3) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_constructor_invocation ((kind, body) : mt) :
    CST.constructor_invocation =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( trans_type_name (Run.matcher_token v0),
            trans_type_arguments (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            trans_arguments (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_constructor_param ((kind, body) : mt) : CST.constructor_param =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt
              (fun v -> trans_final_const_var_or_type (Run.matcher_token v))
              v0,
            trans_this (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_formal_parameter_part (Run.matcher_token v))
              v4 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_declared_identifier ((kind, body) : mt) : CST.declared_identifier =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            Run.opt (fun v -> trans_covariant (Run.matcher_token v)) v1,
            trans_final_const_var_or_type (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_deep_ellipsis ((kind, body) : mt) : CST.deep_ellipsis =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_default_formal_parameter ((kind, body) : mt) :
    CST.default_formal_parameter =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_formal_parameter (Run.matcher_token v0),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_default_named_parameter ((kind, body) : mt) :
    CST.default_named_parameter =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_requ_formal_param_opt_EQ_exp
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt (fun v -> trans_required (Run.matcher_token v)) v0,
                  trans_formal_parameter (Run.matcher_token v1),
                  Run.opt
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v2 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Opt_requ_formal_param_opt_COLON_exp
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt (fun v -> trans_required (Run.matcher_token v)) v0,
                  trans_formal_parameter (Run.matcher_token v1),
                  Run.opt
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v2 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_do_statement ((kind, body) : mt) : CST.do_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_statement (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_parenthesized_expression (Run.matcher_token v3),
            trans_semicolon (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_element ((kind, body) : mt) : CST.element =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Exp (trans_expression (Run.matcher_token v))
      | Alt (1, v) -> `Pair (trans_pair (Run.matcher_token v))
      | Alt (2, v) -> `Spread_elem (trans_spread_element (Run.matcher_token v))
      | Alt (3, v) -> `If_elem (trans_if_element (Run.matcher_token v))
      | Alt (4, v) -> `For_elem (trans_for_element (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_equality_expression ((kind, body) : mt) : CST.equality_expression =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Real_exp_equa_op_real_exp
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( trans_real_expression (Run.matcher_token v0),
                  trans_equality_operator (Run.matcher_token v1),
                  trans_real_expression (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Super_equa_op_real_exp
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( trans_super (Run.matcher_token v0),
                  trans_equality_operator (Run.matcher_token v1),
                  trans_real_expression (Run.matcher_token v2) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_expression ((kind, body) : mt) : CST.expression =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Choice_assign_exp
            (match v with
            | Alt (0, v) ->
                `Assign_exp (trans_assignment_expression (Run.matcher_token v))
            | Alt (1, v) ->
                `Throw_exp (trans_throw_expression (Run.matcher_token v))
            | Alt (2, v) ->
                `Real_exp_rep_casc_sect
                  (match v with
                  | Seq [ v0; v1 ] ->
                      ( trans_real_expression (Run.matcher_token v0),
                        Run.repeat
                          (fun v -> trans_cascade_section (Run.matcher_token v))
                          v1 )
                  | _ -> assert false)
            | _ -> assert false)
      | Alt (1, v) ->
          `Semg_ellips (trans_semgrep_ellipsis (Run.matcher_token v))
      | Alt (2, v) ->
          `Semg_named_ellips
            (trans_semgrep_named_ellipsis (Run.matcher_token v))
      | Alt (3, v) -> `Deep_ellips (trans_deep_ellipsis (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_expression_statement ((kind, body) : mt) : CST.expression_statement =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Exp_semi
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_expression (Run.matcher_token v0),
                  trans_semicolon (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Semg_ellips (trans_semgrep_ellipsis (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_expression_without_cascade ((kind, body) : mt) :
    CST.expression_without_cascade =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Assign_exp_with_casc
            (trans_assignment_expression_without_cascade (Run.matcher_token v))
      | Alt (1, v) -> `Real_exp (trans_real_expression (Run.matcher_token v))
      | Alt (2, v) ->
          `Throw_exp_with_casc
            (trans_throw_expression_without_cascade (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_final_const_var_or_type ((kind, body) : mt) :
    CST.final_const_var_or_type =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_late_buil_final_buil_opt_type
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt (fun v -> trans_late_builtin (Run.matcher_token v)) v0,
                  trans_final_builtin (Run.matcher_token v1),
                  Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v2 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Const_buil_opt_type
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_const_builtin (Run.matcher_token v0),
                  Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v1 )
            | _ -> assert false)
      | Alt (2, v) ->
          `Opt_late_buil_var_or_type
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.opt (fun v -> trans_late_builtin (Run.matcher_token v)) v0,
                  trans_var_or_type (Run.matcher_token v1) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_finally_clause ((kind, body) : mt) : CST.finally_clause =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_for_element ((kind, body) : mt) : CST.for_element =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4; v5 ] ->
          ( Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v0,
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_for_loop_parts (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_element (Run.matcher_token v5) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_for_loop_parts ((kind, body) : mt) : CST.for_loop_parts =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Choice_decl_id_in_exp
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( (match v0 with
                  | Alt (0, v) ->
                      `Decl_id (trans_declared_identifier (Run.matcher_token v))
                  | Alt (1, v) -> `Id (trans_identifier (Run.matcher_token v))
                  | _ -> assert false),
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Opt_choice_local_var_decl_opt_exp_semi_opt_exp_rep_COMMA_exp
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( Run.opt
                    (fun v ->
                      match v with
                      | Alt (0, v) ->
                          `Local_var_decl
                            (trans_local_variable_declaration
                               (Run.matcher_token v))
                      | Alt (1, v) ->
                          `Opt_exp_rep_COMMA_exp_semi
                            (match v with
                            | Seq [ v0; v1 ] ->
                                ( Run.opt
                                    (fun v ->
                                      match v with
                                      | Seq [ v0; v1 ] ->
                                          ( trans_expression
                                              (Run.matcher_token v0),
                                            Run.repeat
                                              (fun v ->
                                                match v with
                                                | Seq [ v0; v1 ] ->
                                                    ( Run.trans_token
                                                        (Run.matcher_token v0),
                                                      trans_expression
                                                        (Run.matcher_token v1)
                                                    )
                                                | _ -> assert false)
                                              v1 )
                                      | _ -> assert false)
                                    v0,
                                  trans_semicolon (Run.matcher_token v1) )
                            | _ -> assert false)
                      | _ -> assert false)
                    v0,
                  Run.opt (fun v -> trans_expression (Run.matcher_token v)) v1,
                  trans_semicolon (Run.matcher_token v2),
                  Run.opt
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( trans_expression (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                match v with
                                | Seq [ v0; v1 ] ->
                                    ( Run.trans_token (Run.matcher_token v0),
                                      trans_expression (Run.matcher_token v1) )
                                | _ -> assert false)
                              v1 )
                      | _ -> assert false)
                    v3 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_for_statement ((kind, body) : mt) : CST.for_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4; v5 ] ->
          ( Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v0,
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_for_loop_parts (Run.matcher_token v3),
            Run.trans_token (Run.matcher_token v4),
            trans_statement (Run.matcher_token v5) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_formal_parameter ((kind, body) : mt) : CST.formal_parameter =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Semg_ellips (trans_semgrep_ellipsis (Run.matcher_token v))
      | Alt (1, v) ->
          `Normal_formal_param
            (trans_normal_formal_parameter (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_formal_parameter_list ((kind, body) : mt) : CST.formal_parameter_list
    =
  match body with
  | Children v -> trans_strict_formal_parameter_list (Run.matcher_token v)
  | Leaf _ -> assert false

and trans_formal_parameter_part ((kind, body) : mt) : CST.formal_parameter_part
    =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.opt (fun v -> trans_type_parameters (Run.matcher_token v)) v0,
            trans_formal_parameter_list (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_function_body ((kind, body) : mt) : CST.function_body =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_async_EQGT_exp_semi
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v0,
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2),
                  trans_semicolon (Run.matcher_token v3) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Opt_choice_async_blk
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.opt
                    (fun v ->
                      match v with
                      | Alt (0, v) ->
                          `Async (Run.trans_token (Run.matcher_token v))
                      | Alt (1, v) ->
                          `Asyn (Run.trans_token (Run.matcher_token v))
                      | Alt (2, v) ->
                          `Sync (Run.trans_token (Run.matcher_token v))
                      | _ -> assert false)
                    v0,
                  trans_block (Run.matcher_token v1) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_function_expression ((kind, body) : mt) : CST.function_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_formal_parameter_part (Run.matcher_token v0),
            trans_function_expression_body (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_function_expression_body ((kind, body) : mt) :
    CST.function_expression_body =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_async_EQGT_exp
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v0,
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Opt_choice_async_blk
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.opt
                    (fun v ->
                      match v with
                      | Alt (0, v) ->
                          `Async (Run.trans_token (Run.matcher_token v))
                      | Alt (1, v) ->
                          `Asyn (Run.trans_token (Run.matcher_token v))
                      | Alt (2, v) ->
                          `Sync (Run.trans_token (Run.matcher_token v))
                      | _ -> assert false)
                    v0,
                  trans_block (Run.matcher_token v1) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_function_formal_parameter ((kind, body) : mt) :
    CST.function_formal_parameter =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt (fun v -> trans_covariant (Run.matcher_token v)) v0,
            Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v1,
            trans_identifier (Run.matcher_token v2),
            trans_formal_parameter_part (Run.matcher_token v3),
            Run.opt (fun v -> trans_nullable_type (Run.matcher_token v)) v4 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_function_signature ((kind, body) : mt) : CST.function_signature =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v0,
            (match v1 with
            | Alt (0, v) -> `Get (trans_get (Run.matcher_token v))
            | Alt (1, v) -> `Set (trans_set (Run.matcher_token v))
            | Alt (2, v) -> `Id (trans_identifier (Run.matcher_token v))
            | _ -> assert false),
            trans_formal_parameter_part (Run.matcher_token v2),
            Run.opt (fun v -> trans_native (Run.matcher_token v)) v3 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_function_type ((kind, body) : mt) : CST.function_type =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Func_type_tails (trans_function_type_tails (Run.matcher_token v))
      | Alt (1, v) ->
          `Type_not_func_func_type_tails
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_type_not_function (Run.matcher_token v0),
                  trans_function_type_tails (Run.matcher_token v1) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_function_type_tail ((kind, body) : mt) : CST.function_type_tail =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( trans_function_builtin_identifier (Run.matcher_token v0),
            Run.opt (fun v -> trans_type_parameters (Run.matcher_token v)) v1,
            Run.opt (fun v -> trans_nullable_type (Run.matcher_token v)) v2,
            Run.opt
              (fun v -> trans_parameter_type_list (Run.matcher_token v))
              v3,
            Run.opt (fun v -> trans_nullable_type (Run.matcher_token v)) v4 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_function_type_tails ((kind, body) : mt) : CST.function_type_tails =
  match body with
  | Children v ->
      Run.repeat1 (fun v -> trans_function_type_tail (Run.matcher_token v)) v
  | Leaf _ -> assert false

and trans_if_element ((kind, body) : mt) : CST.if_element =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_element (Run.matcher_token v2),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_element (Run.matcher_token v1) )
                | _ -> assert false)
              v3 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_if_null_expression ((kind, body) : mt) : CST.if_null_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_real_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_real_expression (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_if_statement ((kind, body) : mt) : CST.if_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_statement (Run.matcher_token v1) )
                | _ -> assert false)
              v3 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_initialized_identifier ((kind, body) : mt) :
    CST.initialized_identifier =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_initialized_variable_definition ((kind, body) : mt) :
    CST.initialized_variable_definition =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( trans_declared_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_expression (Run.matcher_token v1) )
                | _ -> assert false)
              v1,
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_initialized_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v2 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_lambda_expression ((kind, body) : mt) : CST.lambda_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_function_signature (Run.matcher_token v0),
            trans_function_body (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_list_literal ((kind, body) : mt) : CST.list_literal =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt (fun v -> trans_const_builtin (Run.matcher_token v)) v0,
            Run.opt (fun v -> trans_type_arguments (Run.matcher_token v)) v1,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1; v2 ] ->
                    ( trans_element (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          match v with
                          | Seq [ v0; v1 ] ->
                              ( Run.trans_token (Run.matcher_token v0),
                                trans_element (Run.matcher_token v1) )
                          | _ -> assert false)
                        v1,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2 )
                | _ -> assert false)
              v3,
            Run.trans_token (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_literal ((kind, body) : mt) : CST.literal =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Deci_int_lit (trans_decimal_integer_literal (Run.matcher_token v))
      | Alt (1, v) ->
          `Hex_int_lit (trans_hex_integer_literal (Run.matcher_token v))
      | Alt (2, v) ->
          `Deci_floa_point_lit
            (trans_decimal_floating_point_literal (Run.matcher_token v))
      | Alt (3, v) -> `True (trans_true_ (Run.matcher_token v))
      | Alt (4, v) -> `False (trans_false_ (Run.matcher_token v))
      | Alt (5, v) -> `Str_lit (trans_string_literal (Run.matcher_token v))
      | Alt (6, v) -> `Null_lit (trans_null_literal (Run.matcher_token v))
      | Alt (7, v) -> `Symb_lit (trans_symbol_literal (Run.matcher_token v))
      | Alt (8, v) -> `List_lit (trans_list_literal (Run.matcher_token v))
      | Alt (9, v) ->
          `Set_or_map_lit (trans_set_or_map_literal (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_local_function_declaration ((kind, body) : mt) :
    CST.local_function_declaration =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            trans_lambda_expression (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_local_variable_declaration ((kind, body) : mt) :
    CST.local_variable_declaration =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_initialized_variable_definition (Run.matcher_token v0),
            trans_semicolon (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_logical_and_expression ((kind, body) : mt) :
    CST.logical_and_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_real_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_real_expression (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_logical_or_expression ((kind, body) : mt) : CST.logical_or_expression
    =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_real_expression (Run.matcher_token v0),
            Run.repeat1
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_real_expression (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_metadata ((kind, body) : mt) : CST.metadata =
  match body with
  | Children v ->
      Run.repeat1 (fun v -> trans_annotation_ (Run.matcher_token v)) v
  | Leaf _ -> assert false

and trans_multiplicative_expression ((kind, body) : mt) :
    CST.multiplicative_expression =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Un_exp_rep1_mult_op_un_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_unary_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( trans_multiplicative_operator (Run.matcher_token v0),
                            trans_unary_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Super_rep1_mult_op_un_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( trans_multiplicative_operator (Run.matcher_token v0),
                            trans_unary_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_named_argument ((kind, body) : mt) : CST.named_argument =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_label (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_named_formal_parameters ((kind, body) : mt) :
    CST.named_formal_parameters =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_default_named_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_default_named_parameter (Run.matcher_token v1) )
                | _ -> assert false)
              v2,
            Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v3,
            Run.trans_token (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_named_parameter_type ((kind, body) : mt) : CST.named_parameter_type =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            Run.opt (fun v -> trans_required (Run.matcher_token v)) v1,
            trans_typed_identifier (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_named_parameter_types ((kind, body) : mt) : CST.named_parameter_types
    =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_named_parameter_type (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_named_parameter_type (Run.matcher_token v1) )
                | _ -> assert false)
              v2,
            Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v3,
            Run.trans_token (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_native ((kind, body) : mt) : CST.native =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.opt (fun v -> trans_string_literal (Run.matcher_token v)) v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_new_expression ((kind, body) : mt) : CST.new_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( trans_new_builtin (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1),
            Run.opt (fun v -> trans_dot_identifier (Run.matcher_token v)) v2,
            trans_arguments (Run.matcher_token v3) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_normal_formal_parameter ((kind, body) : mt) :
    CST.normal_formal_parameter =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] -> (
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            match v1 with
            | Alt (0, v) ->
                `Func_formal_param
                  (trans_function_formal_parameter (Run.matcher_token v))
            | Alt (1, v) ->
                `Simple_formal_param
                  (trans_simple_formal_parameter (Run.matcher_token v))
            | Alt (2, v) ->
                `Cons_param (trans_constructor_param (Run.matcher_token v))
            | Alt (3, v) ->
                `Super_formal_param
                  (trans_super_formal_parameter (Run.matcher_token v))
            | _ -> assert false ))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_normal_formal_parameters ((kind, body) : mt) :
    CST.normal_formal_parameters =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_formal_parameter (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_formal_parameter (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_normal_parameter_type ((kind, body) : mt) : CST.normal_parameter_type
    =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] -> (
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            match v1 with
            | Alt (0, v) ->
                `Typed_id (trans_typed_identifier (Run.matcher_token v))
            | Alt (1, v) -> `Type (trans_type_ (Run.matcher_token v))
            | _ -> assert false ))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_on_part ((kind, body) : mt) : CST.on_part =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Catch_clause_blk
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_catch_clause (Run.matcher_token v0),
                  trans_block (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (1, v) ->
          `On_type_not_void_opt_catch_clause_blk
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  trans_type_not_void (Run.matcher_token v1),
                  Run.opt (fun v -> trans_catch_clause (Run.matcher_token v)) v2,
                  trans_block (Run.matcher_token v3) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_optional_formal_parameters ((kind, body) : mt) :
    CST.optional_formal_parameters =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_post_formal_params
            (trans_optional_postional_formal_parameters (Run.matcher_token v))
      | Alt (1, v) ->
          `Named_formal_params
            (trans_named_formal_parameters (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_optional_parameter_types ((kind, body) : mt) :
    CST.optional_parameter_types =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_posi_param_types
            (trans_optional_positional_parameter_types (Run.matcher_token v))
      | Alt (1, v) ->
          `Named_param_types (trans_named_parameter_types (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_optional_positional_parameter_types ((kind, body) : mt) :
    CST.optional_positional_parameter_types =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_normal_parameter_type (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_normal_parameter_type (Run.matcher_token v1) )
                | _ -> assert false)
              v2,
            Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v3,
            Run.trans_token (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_optional_postional_formal_parameters ((kind, body) : mt) :
    CST.optional_postional_formal_parameters =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_default_formal_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_default_formal_parameter (Run.matcher_token v1) )
                | _ -> assert false)
              v2,
            Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v3,
            Run.trans_token (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_pair ((kind, body) : mt) : CST.pair =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( trans_expression (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_parameter_type_list ((kind, body) : mt) : CST.parameter_type_list =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Normal_param_type_rep_COMMA_normal_param_type_opt_COMMA
                      (match v with
                      | Seq [ v0; v1; v2 ] ->
                          ( trans_normal_parameter_type (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                match v with
                                | Seq [ v0; v1 ] ->
                                    ( Run.trans_token (Run.matcher_token v0),
                                      trans_normal_parameter_type
                                        (Run.matcher_token v1) )
                                | _ -> assert false)
                              v1,
                            Run.opt
                              (fun v -> Run.trans_token (Run.matcher_token v))
                              v2 )
                      | _ -> assert false)
                | Alt (1, v) ->
                    `Normal_param_type_rep_COMMA_normal_param_type_COMMA_opt_param_types
                      (match v with
                      | Seq [ v0; v1; v2; v3 ] ->
                          ( trans_normal_parameter_type (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                match v with
                                | Seq [ v0; v1 ] ->
                                    ( Run.trans_token (Run.matcher_token v0),
                                      trans_normal_parameter_type
                                        (Run.matcher_token v1) )
                                | _ -> assert false)
                              v1,
                            Run.trans_token (Run.matcher_token v2),
                            trans_optional_parameter_types
                              (Run.matcher_token v3) )
                      | _ -> assert false)
                | Alt (2, v) ->
                    `Opt_param_types
                      (trans_optional_parameter_types (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_parenthesized_expression ((kind, body) : mt) :
    CST.parenthesized_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_postfix_expression ((kind, body) : mt) : CST.postfix_expression =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Prim_rep_sele
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_primary (Run.matcher_token v0),
                  Run.repeat (fun v -> trans_selector (Run.matcher_token v)) v1
                )
            | _ -> assert false)
      | Alt (1, v) ->
          `Post_exp_ (trans_postfix_expression_ (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_postfix_expression_ ((kind, body) : mt) : CST.postfix_expression_ =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Assi_exp_post_op
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_assignable_expression (Run.matcher_token v0),
                  trans_postfix_operator (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Cons_invo_rep_sele
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_constructor_invocation (Run.matcher_token v0),
                  Run.repeat (fun v -> trans_selector (Run.matcher_token v)) v1
                )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_primary ((kind, body) : mt) : CST.primary =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Lit (trans_literal (Run.matcher_token v))
      | Alt (1, v) ->
          `Func_exp (trans_function_expression (Run.matcher_token v))
      | Alt (2, v) -> `Id (trans_identifier (Run.matcher_token v))
      | Alt (3, v) -> `New_exp (trans_new_expression (Run.matcher_token v))
      | Alt (4, v) ->
          `Const_obj_exp (trans_const_object_expression (Run.matcher_token v))
      | Alt (5, v) ->
          `LPAR_exp_RPAR
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  trans_expression (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (6, v) -> `This (trans_this (Run.matcher_token v))
      | Alt (7, v) ->
          `Super_unco_assi_sele
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_super (Run.matcher_token v0),
                  trans_unconditional_assignable_selector (Run.matcher_token v1)
                )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_real_expression ((kind, body) : mt) : CST.real_expression =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Cond_exp (trans_conditional_expression (Run.matcher_token v))
      | Alt (1, v) ->
          `Logi_or_exp (trans_logical_or_expression (Run.matcher_token v))
      | Alt (2, v) ->
          `If_null_exp (trans_if_null_expression (Run.matcher_token v))
      | Alt (3, v) ->
          `Addi_exp (trans_additive_expression (Run.matcher_token v))
      | Alt (4, v) ->
          `Mult_exp (trans_multiplicative_expression (Run.matcher_token v))
      | Alt (5, v) ->
          `Rela_exp (trans_relational_expression (Run.matcher_token v))
      | Alt (6, v) ->
          `Equa_exp (trans_equality_expression (Run.matcher_token v))
      | Alt (7, v) ->
          `Logi_and_exp (trans_logical_and_expression (Run.matcher_token v))
      | Alt (8, v) ->
          `Bitw_and_exp (trans_bitwise_and_expression (Run.matcher_token v))
      | Alt (9, v) ->
          `Bitw_or_exp (trans_bitwise_or_expression (Run.matcher_token v))
      | Alt (10, v) ->
          `Bitw_xor_exp (trans_bitwise_xor_expression (Run.matcher_token v))
      | Alt (11, v) -> `Shift_exp (trans_shift_expression (Run.matcher_token v))
      | Alt (12, v) ->
          `Type_cast_exp (trans_type_cast_expression (Run.matcher_token v))
      | Alt (13, v) ->
          `Type_test_exp (trans_type_test_expression (Run.matcher_token v))
      | Alt (14, v) -> `Un_exp (trans_unary_expression (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_relational_expression ((kind, body) : mt) : CST.relational_expression
    =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Real_exp_rela_op_real_exp
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( trans_real_expression (Run.matcher_token v0),
                  trans_relational_operator (Run.matcher_token v1),
                  trans_real_expression (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Super_rela_op_real_exp
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( trans_super (Run.matcher_token v0),
                  trans_relational_operator (Run.matcher_token v1),
                  trans_real_expression (Run.matcher_token v2) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_return_statement ((kind, body) : mt) : CST.return_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.opt (fun v -> trans_expression (Run.matcher_token v)) v1,
            trans_semicolon (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_selector ((kind, body) : mt) : CST.selector =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Excl_op (trans_exclamation_operator (Run.matcher_token v))
      | Alt (1, v) ->
          `Assi_sele (trans_assignable_selector (Run.matcher_token v))
      | Alt (2, v) -> `Arg_part (trans_argument_part (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_set_or_map_literal ((kind, body) : mt) : CST.set_or_map_literal =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt (fun v -> trans_const_builtin (Run.matcher_token v)) v0,
            Run.opt (fun v -> trans_type_arguments (Run.matcher_token v)) v1,
            Run.trans_token (Run.matcher_token v2),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1; v2 ] ->
                    ( trans_element (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          match v with
                          | Seq [ v0; v1 ] ->
                              ( Run.trans_token (Run.matcher_token v0),
                                trans_element (Run.matcher_token v1) )
                          | _ -> assert false)
                        v1,
                      Run.opt
                        (fun v -> Run.trans_token (Run.matcher_token v))
                        v2 )
                | _ -> assert false)
              v3,
            Run.trans_token (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_shift_expression ((kind, body) : mt) : CST.shift_expression =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Real_exp_rep1_shift_op_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_real_expression (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( trans_shift_operator (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Super_rep1_shift_op_real_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_super (Run.matcher_token v0),
                  Run.repeat1
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( trans_shift_operator (Run.matcher_token v0),
                            trans_real_expression (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_simple_formal_parameter ((kind, body) : mt) :
    CST.simple_formal_parameter =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Decl_id (trans_declared_identifier (Run.matcher_token v))
      | Alt (1, v) ->
          `Opt_cova_id
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.opt (fun v -> trans_covariant (Run.matcher_token v)) v0,
                  trans_identifier (Run.matcher_token v1) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_spread_element ((kind, body) : mt) : CST.spread_element =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v1,
            trans_expression (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_statement ((kind, body) : mt) : CST.statement =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Blk (trans_block (Run.matcher_token v))
      | Alt (1, v) ->
          `Local_func_decl
            (trans_local_function_declaration (Run.matcher_token v))
      | Alt (2, v) ->
          `Local_var_decl
            (trans_local_variable_declaration (Run.matcher_token v))
      | Alt (3, v) -> `For_stmt (trans_for_statement (Run.matcher_token v))
      | Alt (4, v) -> `While_stmt (trans_while_statement (Run.matcher_token v))
      | Alt (5, v) -> `Do_stmt (trans_do_statement (Run.matcher_token v))
      | Alt (6, v) ->
          `Switch_stmt (trans_switch_statement (Run.matcher_token v))
      | Alt (7, v) -> `If_stmt (trans_if_statement (Run.matcher_token v))
      | Alt (8, v) -> `Try_stmt (trans_try_statement (Run.matcher_token v))
      | Alt (9, v) -> `Brk_stmt (trans_break_statement (Run.matcher_token v))
      | Alt (10, v) ->
          `Cont_stmt (trans_continue_statement (Run.matcher_token v))
      | Alt (11, v) -> `Ret_stmt (trans_return_statement (Run.matcher_token v))
      | Alt (12, v) -> `Yield_stmt (trans_yield_statement (Run.matcher_token v))
      | Alt (13, v) ->
          `Yield_each_stmt (trans_yield_each_statement (Run.matcher_token v))
      | Alt (14, v) ->
          `Exp_stmt (trans_expression_statement (Run.matcher_token v))
      | Alt (15, v) ->
          `Assert_stmt (trans_assert_statement (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_strict_formal_parameter_list ((kind, body) : mt) :
    CST.strict_formal_parameter_list =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `LPAR_RPAR
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (1, v) ->
          `LPAR_normal_formal_params_opt_COMMA_RPAR
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  trans_normal_formal_parameters (Run.matcher_token v1),
                  Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v2,
                  Run.trans_token (Run.matcher_token v3) )
            | _ -> assert false)
      | Alt (2, v) ->
          `LPAR_normal_formal_params_COMMA_opt_formal_params_RPAR
            (match v with
            | Seq [ v0; v1; v2; v3; v4 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  trans_normal_formal_parameters (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2),
                  trans_optional_formal_parameters (Run.matcher_token v3),
                  Run.trans_token (Run.matcher_token v4) )
            | _ -> assert false)
      | Alt (3, v) ->
          `LPAR_opt_formal_params_RPAR
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  trans_optional_formal_parameters (Run.matcher_token v1),
                  Run.trans_token (Run.matcher_token v2) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_string_literal ((kind, body) : mt) : CST.string_literal =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          match v with
          | Alt (0, v) ->
              `Str_lit_double_quotes
                (trans_string_literal_double_quotes (Run.matcher_token v))
          | Alt (1, v) ->
              `Str_lit_single_quotes
                (trans_string_literal_single_quotes (Run.matcher_token v))
          | Alt (2, v) ->
              `Str_lit_double_quotes_mult
                (trans_string_literal_double_quotes_multiple
                   (Run.matcher_token v))
          | Alt (3, v) ->
              `Str_lit_single_quotes_mult
                (trans_string_literal_single_quotes_multiple
                   (Run.matcher_token v))
          | Alt (4, v) ->
              `Raw_str_lit_double_quotes
                (trans_raw_string_literal_double_quotes (Run.matcher_token v))
          | Alt (5, v) ->
              `Raw_str_lit_single_quotes
                (trans_raw_string_literal_single_quotes (Run.matcher_token v))
          | Alt (6, v) ->
              `Raw_str_lit_double_quotes_mult
                (trans_raw_string_literal_double_quotes_multiple
                   (Run.matcher_token v))
          | Alt (7, v) ->
              `Raw_str_lit_single_quotes_mult
                (trans_raw_string_literal_single_quotes_multiple
                   (Run.matcher_token v))
          | _ -> assert false)
        v
  | Leaf _ -> assert false

and trans_string_literal_double_quotes ((kind, body) : mt) :
    CST.string_literal_double_quotes =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Temp_chars_double_single
                      (trans_template_chars_double_single (Run.matcher_token v))
                | Alt (1, v) -> `SQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (2, v) ->
                    `Esc_seq (trans_escape_sequence (Run.matcher_token v))
                | Alt (3, v) ->
                    `Sub_str_test (trans_sub_string_test (Run.matcher_token v))
                | Alt (4, v) ->
                    `Temp_subs
                      (trans_template_substitution (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_string_literal_double_quotes_multiple ((kind, body) : mt) :
    CST.string_literal_double_quotes_multiple =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Temp_chars_double
                      (trans_template_chars_double (Run.matcher_token v))
                | Alt (1, v) -> `SQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (2, v) -> `DQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (3, v) ->
                    `Esc_seq (trans_escape_sequence (Run.matcher_token v))
                | Alt (4, v) ->
                    `Sub_str_test (trans_sub_string_test (Run.matcher_token v))
                | Alt (5, v) ->
                    `Temp_subs
                      (trans_template_substitution (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_string_literal_single_quotes ((kind, body) : mt) :
    CST.string_literal_single_quotes =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Temp_chars_single_single
                      (trans_template_chars_single_single (Run.matcher_token v))
                | Alt (1, v) -> `DQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (2, v) ->
                    `Esc_seq (trans_escape_sequence (Run.matcher_token v))
                | Alt (3, v) ->
                    `Sub_str_test (trans_sub_string_test (Run.matcher_token v))
                | Alt (4, v) ->
                    `Temp_subs
                      (trans_template_substitution (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_string_literal_single_quotes_multiple ((kind, body) : mt) :
    CST.string_literal_single_quotes_multiple =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Temp_chars_single
                      (trans_template_chars_single (Run.matcher_token v))
                | Alt (1, v) -> `DQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (2, v) -> `SQUOT (Run.trans_token (Run.matcher_token v))
                | Alt (3, v) ->
                    `Esc_seq (trans_escape_sequence (Run.matcher_token v))
                | Alt (4, v) ->
                    `Sub_str_test (trans_sub_string_test (Run.matcher_token v))
                | Alt (5, v) ->
                    `Temp_subs
                      (trans_template_substitution (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_super_formal_parameter ((kind, body) : mt) :
    CST.super_formal_parameter =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt
              (fun v -> trans_final_const_var_or_type (Run.matcher_token v))
              v0,
            trans_super (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_identifier (Run.matcher_token v3),
            Run.opt
              (fun v -> trans_formal_parameter_part (Run.matcher_token v))
              v4 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_switch_block ((kind, body) : mt) : CST.switch_block =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Switch_label (trans_switch_label (Run.matcher_token v))
                | Alt (1, v) -> `Stmt (trans_statement (Run.matcher_token v))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_switch_label ((kind, body) : mt) : CST.switch_label =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] -> (
          ( Run.repeat (fun v -> trans_label (Run.matcher_token v)) v0,
            match v1 with
            | Alt (0, v) ->
                `Case_buil_exp_COLON
                  (match v with
                  | Seq [ v0; v1; v2 ] ->
                      ( trans_case_builtin (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2) )
                  | _ -> assert false)
            | Alt (1, v) ->
                `Defa_COLON
                  (match v with
                  | Seq [ v0; v1 ] ->
                      ( Run.trans_token (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1) )
                  | _ -> assert false)
            | _ -> assert false ))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_switch_statement ((kind, body) : mt) : CST.switch_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_switch_block (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_template_substitution ((kind, body) : mt) : CST.template_substitution
    =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] -> (
          ( Run.trans_token (Run.matcher_token v0),
            match v1 with
            | Alt (0, v) ->
                `LCURL_exp_RCURL
                  (match v with
                  | Seq [ v0; v1; v2 ] ->
                      ( Run.trans_token (Run.matcher_token v0),
                        trans_expression (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2) )
                  | _ -> assert false)
            | Alt (1, v) ->
                `Id_dollar_esca
                  (trans_identifier_dollar_escaped (Run.matcher_token v))
            | _ -> assert false ))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_throw_expression ((kind, body) : mt) : CST.throw_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_throw_expression_without_cascade ((kind, body) : mt) :
    CST.throw_expression_without_cascade =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_expression_without_cascade (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_try_head ((kind, body) : mt) : CST.try_head =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_block (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_try_statement ((kind, body) : mt) : CST.try_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] -> (
          ( trans_try_head (Run.matcher_token v0),
            match v1 with
            | Alt (0, v) ->
                `Fina_clause (trans_finally_clause (Run.matcher_token v))
            | Alt (1, v) ->
                `Rep1_on_part_opt_fina_clause
                  (match v with
                  | Seq [ v0; v1 ] ->
                      ( Run.repeat1
                          (fun v -> trans_on_part (Run.matcher_token v))
                          v0,
                        Run.opt
                          (fun v -> trans_finally_clause (Run.matcher_token v))
                          v1 )
                  | _ -> assert false)
            | _ -> assert false ))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_ ((kind, body) : mt) : CST.type_ =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Func_type_opt_null_type
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_function_type (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Type_not_func (trans_type_not_function (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_arguments ((kind, body) : mt) : CST.type_arguments =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `LT_opt_type_rep_COMMA_type_GT
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( trans_type_ (Run.matcher_token v0),
                            Run.repeat
                              (fun v ->
                                match v with
                                | Seq [ v0; v1 ] ->
                                    ( Run.trans_token (Run.matcher_token v0),
                                      trans_type_ (Run.matcher_token v1) )
                                | _ -> assert false)
                              v1 )
                      | _ -> assert false)
                    v1,
                  Run.trans_token (Run.matcher_token v2) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_bound ((kind, body) : mt) : CST.type_bound =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_cast ((kind, body) : mt) : CST.type_cast =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_as_operator (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_cast_expression ((kind, body) : mt) : CST.type_cast_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_real_expression (Run.matcher_token v0),
            trans_type_cast (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_not_function ((kind, body) : mt) : CST.type_not_function =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Type_not_void_not_func
            (trans_type_not_void_not_function (Run.matcher_token v))
      | Alt (1, v) -> `Void_type (trans_void_type (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_not_void ((kind, body) : mt) : CST.type_not_void =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Func_type_opt_null_type
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_function_type (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Type_not_void_not_func
            (trans_type_not_void_not_function (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_not_void_not_function ((kind, body) : mt) :
    CST.type_not_void_not_function =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Type_name_opt_type_args_opt_null_type
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( trans_type_name (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_type_arguments (Run.matcher_token v))
                    v1,
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v2 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Func_buil_id_opt_null_type
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_function_builtin_identifier (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_nullable_type (Run.matcher_token v))
                    v1 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_parameter ((kind, body) : mt) : CST.type_parameter =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            trans_identifier (Run.matcher_token v1),
            Run.opt (fun v -> trans_nullable_type (Run.matcher_token v)) v2,
            Run.opt (fun v -> trans_type_bound (Run.matcher_token v)) v3 )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_parameters ((kind, body) : mt) : CST.type_parameters =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_type_parameter (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_type_parameter (Run.matcher_token v1) )
                | _ -> assert false)
              v2,
            Run.trans_token (Run.matcher_token v3) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_test ((kind, body) : mt) : CST.type_test =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_is_operator (Run.matcher_token v0),
            trans_type_not_void (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_type_test_expression ((kind, body) : mt) : CST.type_test_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_real_expression (Run.matcher_token v0),
            trans_type_test (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_typed_identifier ((kind, body) : mt) : CST.typed_identifier =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_type_ (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_unary_expression ((kind, body) : mt) : CST.unary_expression =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Post_exp (trans_postfix_expression (Run.matcher_token v))
      | Alt (1, v) -> `Un_exp_ (trans_unary_expression_ (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_unary_expression_ ((kind, body) : mt) : CST.unary_expression_ =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Prefix_op_un_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_prefix_operator (Run.matcher_token v0),
                  trans_unary_expression (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (1, v) -> `Await_exp (trans_await_expression (Run.matcher_token v))
      | Alt (2, v) ->
          `Choice_minus_op_super
            (match v with
            | Seq [ v0; v1 ] ->
                ( (match v0 with
                  | Alt (0, v) ->
                      `Minus_op (trans_minus_operator (Run.matcher_token v))
                  | Alt (1, v) ->
                      `Tilde_op (trans_tilde_operator (Run.matcher_token v))
                  | _ -> assert false),
                  trans_super (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (3, v) ->
          `Incr_op_assi_exp
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_increment_operator (Run.matcher_token v0),
                  trans_assignable_expression (Run.matcher_token v1) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_unconditional_assignable_selector ((kind, body) : mt) :
    CST.unconditional_assignable_selector =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_null_type_LBRACK_exp_RBRACK
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( Run.opt (fun v -> trans_nullable_type (Run.matcher_token v)) v0,
                  Run.trans_token (Run.matcher_token v1),
                  trans_expression (Run.matcher_token v2),
                  Run.trans_token (Run.matcher_token v3) )
            | _ -> assert false)
      | Alt (1, v) ->
          `DOT_id
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  trans_identifier (Run.matcher_token v1) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_var_or_type ((kind, body) : mt) : CST.var_or_type =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Type (trans_type_ (Run.matcher_token v))
      | Alt (1, v) ->
          `Infe_type_opt_type
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_inferred_type (Run.matcher_token v0),
                  Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v1 )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_while_statement ((kind, body) : mt) : CST.while_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_parenthesized_expression (Run.matcher_token v1),
            trans_statement (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_yield_each_statement ((kind, body) : mt) : CST.yield_each_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3) )
      | _ -> assert false)
  | Leaf _ -> assert false

and trans_yield_statement ((kind, body) : mt) : CST.yield_statement =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1),
            trans_semicolon (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_uri_test ((kind, body) : mt) : CST.uri_test =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_dotted_identifier_list (Run.matcher_token v0),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_string_literal (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_constant_constructor_signature ((kind, body) : mt) :
    CST.constant_constructor_signature =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( trans_const_builtin (Run.matcher_token v0),
            trans_qualified (Run.matcher_token v1),
            trans_formal_parameter_list (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_getter_signature ((kind, body) : mt) : CST.getter_signature =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v0,
            trans_get (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.opt (fun v -> trans_native (Run.matcher_token v)) v3 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_library_name ((kind, body) : mt) : CST.library_name =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            Run.trans_token (Run.matcher_token v1),
            trans_dotted_identifier_list (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_redirecting_factory_constructor_signature ((kind, body) : mt) :
    CST.redirecting_factory_constructor_signature =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4; v5; v6; v7 ] ->
          ( Run.opt (fun v -> trans_const_builtin (Run.matcher_token v)) v0,
            trans_factory (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v3,
            trans_formal_parameter_list (Run.matcher_token v4),
            Run.trans_token (Run.matcher_token v5),
            trans_type_not_void (Run.matcher_token v6),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v7 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_uri ((kind, body) : mt) : CST.uri =
  match body with
  | Children v -> trans_string_literal (Run.matcher_token v)
  | Leaf _ -> assert false

let trans_redirection ((kind, body) : mt) : CST.redirection =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_this (Run.matcher_token v1),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v2,
            trans_arguments (Run.matcher_token v3) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_field_initializer ((kind, body) : mt) : CST.field_initializer =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( trans_this (Run.matcher_token v0),
                      Run.trans_token (Run.matcher_token v1) )
                | _ -> assert false)
              v0,
            trans_identifier (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            trans_real_expression (Run.matcher_token v3),
            Run.repeat (fun v -> trans_cascade_section (Run.matcher_token v)) v4
          )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_setter_signature ((kind, body) : mt) : CST.setter_signature =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v0,
            trans_set (Run.matcher_token v1),
            trans_identifier (Run.matcher_token v2),
            trans_formal_parameter_part (Run.matcher_token v3),
            Run.opt (fun v -> trans_native (Run.matcher_token v)) v4 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_constructor_signature ((kind, body) : mt) : CST.constructor_signature
    =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v1,
            trans_formal_parameter_list (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_semgrep_expression ((kind, body) : mt) : CST.semgrep_expression =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_expression (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_static_final_declaration ((kind, body) : mt) :
    CST.static_final_declaration =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_expression (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_factory_constructor_signature ((kind, body) : mt) :
    CST.factory_constructor_signature =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( trans_factory (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v2,
            trans_formal_parameter_list (Run.matcher_token v3) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_type_not_void_list ((kind, body) : mt) : CST.type_not_void_list =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_type_not_void (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_type_not_void (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_enum_constant ((kind, body) : mt) : CST.enum_constant =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            trans_identifier (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_type_alias ((kind, body) : mt) : CST.type_alias =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Type_type_name_opt_type_params_EQ_func_type_SEMI
            (match v with
            | Seq [ v0; v1; v2; v3; v4; v5 ] ->
                ( trans_typedef (Run.matcher_token v0),
                  trans_type_name (Run.matcher_token v1),
                  Run.opt
                    (fun v -> trans_type_parameters (Run.matcher_token v))
                    v2,
                  Run.trans_token (Run.matcher_token v3),
                  trans_function_type (Run.matcher_token v4),
                  Run.trans_token (Run.matcher_token v5) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Type_opt_type_type_name_formal_param_part_SEMI
            (match v with
            | Seq [ v0; v1; v2; v3; v4 ] ->
                ( trans_typedef (Run.matcher_token v0),
                  Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v1,
                  trans_type_name (Run.matcher_token v2),
                  trans_formal_parameter_part (Run.matcher_token v3),
                  Run.trans_token (Run.matcher_token v4) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_operator_signature ((kind, body) : mt) : CST.operator_signature =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v0,
            trans_operator (Run.matcher_token v1),
            (match v2 with
            | Alt (0, v) -> `TILDE (Run.trans_token (Run.matcher_token v))
            | Alt (1, v) ->
                `Bin_op (trans_binary_operator (Run.matcher_token v))
            | Alt (2, v) ->
                `LBRACKRBRACK (Run.trans_token (Run.matcher_token v))
            | Alt (3, v) ->
                `LBRACKRBRACKEQ (Run.trans_token (Run.matcher_token v))
            | _ -> assert false),
            trans_formal_parameter_list (Run.matcher_token v3),
            Run.opt (fun v -> trans_native (Run.matcher_token v)) v4 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_initialized_identifier_list ((kind, body) : mt) :
    CST.initialized_identifier_list =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_initialized_identifier (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_initialized_identifier (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_part_of_directive ((kind, body) : mt) : CST.part_of_directive =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            Run.trans_token (Run.matcher_token v1),
            Run.trans_token (Run.matcher_token v2),
            (match v3 with
            | Alt (0, v) ->
                `Dotted_id_list
                  (trans_dotted_identifier_list (Run.matcher_token v))
            | Alt (1, v) -> `Uri (trans_uri (Run.matcher_token v))
            | _ -> assert false),
            trans_semicolon (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_part_directive ((kind, body) : mt) : CST.part_directive =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            Run.trans_token (Run.matcher_token v1),
            trans_uri (Run.matcher_token v2),
            trans_semicolon (Run.matcher_token v3) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_configuration_uri ((kind, body) : mt) : CST.configuration_uri =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.trans_token (Run.matcher_token v1),
            trans_uri_test (Run.matcher_token v2),
            Run.trans_token (Run.matcher_token v3),
            trans_uri (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_initializer_list_entry ((kind, body) : mt) :
    CST.initializer_list_entry =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Super_opt_DOT_qual_args
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.trans_token (Run.matcher_token v0),
                            trans_qualified (Run.matcher_token v1) )
                      | _ -> assert false)
                    v1,
                  trans_arguments (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Field_init (trans_field_initializer (Run.matcher_token v))
      | Alt (2, v) -> `Asse (trans_assertion (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_static_final_declaration_list ((kind, body) : mt) :
    CST.static_final_declaration_list =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_static_final_declaration (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_static_final_declaration (Run.matcher_token v1) )
                | _ -> assert false)
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_mixins ((kind, body) : mt) : CST.mixins =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_type_not_void_list (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_interfaces ((kind, body) : mt) : CST.interfaces =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_implements (Run.matcher_token v0),
            trans_type_not_void_list (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_enum_body ((kind, body) : mt) : CST.enum_body =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_enum_constant (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_enum_constant (Run.matcher_token v1) )
                | _ -> assert false)
              v2,
            Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v3,
            Run.trans_token (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_configurable_uri ((kind, body) : mt) : CST.configurable_uri =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( trans_uri (Run.matcher_token v0),
            Run.repeat
              (fun v -> trans_configuration_uri (Run.matcher_token v))
              v1 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_initializers ((kind, body) : mt) : CST.initializers =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_initializer_list_entry (Run.matcher_token v1),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_initializer_list_entry (Run.matcher_token v1) )
                | _ -> assert false)
              v2 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_superclass ((kind, body) : mt) : CST.superclass =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Extends_type_not_void_opt_mixins
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  trans_type_not_void (Run.matcher_token v1),
                  Run.opt (fun v -> trans_mixins (Run.matcher_token v)) v2 )
            | _ -> assert false)
      | Alt (1, v) -> `Mixins (trans_mixins (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_mixin_application ((kind, body) : mt) : CST.mixin_application =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( trans_type_not_void (Run.matcher_token v0),
            trans_mixins (Run.matcher_token v1),
            Run.opt (fun v -> trans_interfaces (Run.matcher_token v)) v2 )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_enum_declaration ((kind, body) : mt) : CST.enum_declaration =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            trans_enum_body (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_import_specification ((kind, body) : mt) : CST.import_specification =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Import_conf_uri_opt_as_id_rep_comb_semi
            (match v with
            | Seq [ v0; v1; v2; v3; v4 ] ->
                ( trans_import (Run.matcher_token v0),
                  trans_configurable_uri (Run.matcher_token v1),
                  Run.opt
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( trans_as_ (Run.matcher_token v0),
                            trans_identifier (Run.matcher_token v1) )
                      | _ -> assert false)
                    v2,
                  Run.repeat
                    (fun v -> trans_combinator (Run.matcher_token v))
                    v3,
                  trans_semicolon (Run.matcher_token v4) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Import_uri_defe_as_id_rep_comb_semi
            (match v with
            | Seq [ v0; v1; v2; v3; v4; v5; v6 ] ->
                ( trans_import (Run.matcher_token v0),
                  trans_uri (Run.matcher_token v1),
                  trans_deferred (Run.matcher_token v2),
                  trans_as_ (Run.matcher_token v3),
                  trans_identifier (Run.matcher_token v4),
                  Run.repeat
                    (fun v -> trans_combinator (Run.matcher_token v))
                    v5,
                  trans_semicolon (Run.matcher_token v6) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_library_export ((kind, body) : mt) : CST.library_export =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            trans_export (Run.matcher_token v1),
            trans_configurable_uri (Run.matcher_token v2),
            Run.repeat (fun v -> trans_combinator (Run.matcher_token v)) v3,
            trans_semicolon (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_method_signature ((kind, body) : mt) : CST.method_signature =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Cons_sign_opt_initis
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_constructor_signature (Run.matcher_token v0),
                  Run.opt (fun v -> trans_initializers (Run.matcher_token v)) v1
                )
            | _ -> assert false)
      | Alt (1, v) ->
          `Fact_cons_sign
            (trans_factory_constructor_signature (Run.matcher_token v))
      | Alt (2, v) ->
          `Opt_static_choice_func_sign
            (match v with
            | Seq [ v0; v1 ] -> (
                ( Run.opt (fun v -> trans_static (Run.matcher_token v)) v0,
                  match v1 with
                  | Alt (0, v) ->
                      `Func_sign
                        (trans_function_signature (Run.matcher_token v))
                  | Alt (1, v) ->
                      `Getter_sign
                        (trans_getter_signature (Run.matcher_token v))
                  | Alt (2, v) ->
                      `Setter_sign
                        (trans_setter_signature (Run.matcher_token v))
                  | _ -> assert false ))
            | _ -> assert false)
      | Alt (3, v) -> `Op_sign (trans_operator_signature (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_declaration_ ((kind, body) : mt) : CST.declaration_ =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Cst_cons_sign_opt_choice_redi
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_constant_constructor_signature (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      match v with
                      | Alt (0, v) ->
                          `Redi (trans_redirection (Run.matcher_token v))
                      | Alt (1, v) ->
                          `Initis (trans_initializers (Run.matcher_token v))
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | Alt (1, v) ->
          `Cons_sign_opt_choice_redi
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_constructor_signature (Run.matcher_token v0),
                  Run.opt
                    (fun v ->
                      match v with
                      | Alt (0, v) ->
                          `Redi (trans_redirection (Run.matcher_token v))
                      | Alt (1, v) ->
                          `Initis (trans_initializers (Run.matcher_token v))
                      | _ -> assert false)
                    v1 )
            | _ -> assert false)
      | Alt (2, v) ->
          `Exte_opt_const_buil_fact_cons_sign
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( trans_external_ (Run.matcher_token v0),
                  Run.opt
                    (fun v -> trans_const_builtin (Run.matcher_token v))
                    v1,
                  trans_factory_constructor_signature (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (3, v) ->
          `Opt_const_buil_fact_cons_sign_native
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt (fun v -> trans_const_builtin (Run.matcher_token v)) v0,
                  trans_factory_constructor_signature (Run.matcher_token v1),
                  trans_native (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (4, v) ->
          `Exte_cst_cons_sign
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_external_ (Run.matcher_token v0),
                  trans_constant_constructor_signature (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (5, v) ->
          `Redi_fact_cons_sign
            (trans_redirecting_factory_constructor_signature
               (Run.matcher_token v))
      | Alt (6, v) ->
          `Exte_cons_sign
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_external_ (Run.matcher_token v0),
                  trans_constructor_signature (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (7, v) ->
          `Opt_exte_buil_opt_static_getter_sign
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt
                    (fun v -> trans_external_builtin (Run.matcher_token v))
                    v0,
                  Run.opt (fun v -> trans_static (Run.matcher_token v)) v1,
                  trans_getter_signature (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (8, v) ->
          `Opt_exte_and_static_setter_sign
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.opt
                    (fun v -> trans_external_and_static (Run.matcher_token v))
                    v0,
                  trans_setter_signature (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (9, v) ->
          `Opt_exte_op_sign
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.opt (fun v -> trans_external_ (Run.matcher_token v)) v0,
                  trans_operator_signature (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (10, v) ->
          `Opt_exte_and_static_func_sign
            (match v with
            | Seq [ v0; v1 ] ->
                ( Run.opt
                    (fun v -> trans_external_and_static (Run.matcher_token v))
                    v0,
                  trans_function_signature (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (11, v) ->
          `Static_func_sign
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_static (Run.matcher_token v0),
                  trans_function_signature (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (12, v) ->
          `Static_choice_final_or_const_opt_type_static_final_decl_list
            (match v with
            | Seq [ v0; v1 ] -> (
                ( trans_static (Run.matcher_token v0),
                  match v1 with
                  | Alt (0, v) ->
                      `Final_or_const_opt_type_static_final_decl_list
                        (match v with
                        | Seq [ v0; v1; v2 ] ->
                            ( trans_final_or_const (Run.matcher_token v0),
                              Run.opt
                                (fun v -> trans_type_ (Run.matcher_token v))
                                v1,
                              trans_static_final_declaration_list
                                (Run.matcher_token v2) )
                        | _ -> assert false)
                  | Alt (1, v) ->
                      `Late_buil_choice_final_buil_opt_type_init_id_list
                        (match v with
                        | Seq [ v0; v1 ] -> (
                            ( trans_late_builtin (Run.matcher_token v0),
                              match v1 with
                              | Alt (0, v) ->
                                  `Final_buil_opt_type_init_id_list
                                    (match v with
                                    | Seq [ v0; v1; v2 ] ->
                                        ( trans_final_builtin
                                            (Run.matcher_token v0),
                                          Run.opt
                                            (fun v ->
                                              trans_type_ (Run.matcher_token v))
                                            v1,
                                          trans_initialized_identifier_list
                                            (Run.matcher_token v2) )
                                    | _ -> assert false)
                              | Alt (1, v) ->
                                  `Choice_type_init_id_list
                                    (match v with
                                    | Seq [ v0; v1 ] ->
                                        ( (match v0 with
                                          | Alt (0, v) ->
                                              `Type
                                                (trans_type_
                                                   (Run.matcher_token v))
                                          | Alt (1, v) ->
                                              `Infe_type
                                                (trans_inferred_type
                                                   (Run.matcher_token v))
                                          | _ -> assert false),
                                          trans_initialized_identifier_list
                                            (Run.matcher_token v1) )
                                    | _ -> assert false)
                              | _ -> assert false ))
                        | _ -> assert false)
                  | Alt (2, v) ->
                      `Choice_type_init_id_list
                        (match v with
                        | Seq [ v0; v1 ] ->
                            ( (match v0 with
                              | Alt (0, v) ->
                                  `Type (trans_type_ (Run.matcher_token v))
                              | Alt (1, v) ->
                                  `Infe_type
                                    (trans_inferred_type (Run.matcher_token v))
                              | _ -> assert false),
                              trans_initialized_identifier_list
                                (Run.matcher_token v1) )
                        | _ -> assert false)
                  | _ -> assert false ))
            | _ -> assert false)
      | Alt (13, v) ->
          `Cova_choice_late_buil_choice_final_buil_opt_type_id_list_
            (match v with
            | Seq [ v0; v1 ] -> (
                ( trans_covariant (Run.matcher_token v0),
                  match v1 with
                  | Alt (0, v) ->
                      `Late_buil_choice_final_buil_opt_type_id_list_
                        (match v with
                        | Seq [ v0; v1 ] -> (
                            ( trans_late_builtin (Run.matcher_token v0),
                              match v1 with
                              | Alt (0, v) ->
                                  `Final_buil_opt_type_id_list_
                                    (match v with
                                    | Seq [ v0; v1; v2 ] ->
                                        ( trans_final_builtin
                                            (Run.matcher_token v0),
                                          Run.opt
                                            (fun v ->
                                              trans_type_ (Run.matcher_token v))
                                            v1,
                                          trans_identifier_list_
                                            (Run.matcher_token v2) )
                                    | _ -> assert false)
                              | Alt (1, v) ->
                                  `Choice_type_init_id_list
                                    (match v with
                                    | Seq [ v0; v1 ] ->
                                        ( (match v0 with
                                          | Alt (0, v) ->
                                              `Type
                                                (trans_type_
                                                   (Run.matcher_token v))
                                          | Alt (1, v) ->
                                              `Infe_type
                                                (trans_inferred_type
                                                   (Run.matcher_token v))
                                          | _ -> assert false),
                                          trans_initialized_identifier_list
                                            (Run.matcher_token v1) )
                                    | _ -> assert false)
                              | _ -> assert false ))
                        | _ -> assert false)
                  | Alt (1, v) ->
                      `Choice_type_init_id_list
                        (match v with
                        | Seq [ v0; v1 ] ->
                            ( (match v0 with
                              | Alt (0, v) ->
                                  `Type (trans_type_ (Run.matcher_token v))
                              | Alt (1, v) ->
                                  `Infe_type
                                    (trans_inferred_type (Run.matcher_token v))
                              | _ -> assert false),
                              trans_initialized_identifier_list
                                (Run.matcher_token v1) )
                        | _ -> assert false)
                  | _ -> assert false ))
            | _ -> assert false)
      | Alt (14, v) ->
          `Opt_late_buil_final_buil_opt_type_init_id_list
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( Run.opt (fun v -> trans_late_builtin (Run.matcher_token v)) v0,
                  trans_final_builtin (Run.matcher_token v1),
                  Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v2,
                  trans_initialized_identifier_list (Run.matcher_token v3) )
            | _ -> assert false)
      | Alt (15, v) ->
          `Opt_late_buil_var_or_type_init_id_list
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt (fun v -> trans_late_builtin (Run.matcher_token v)) v0,
                  trans_var_or_type (Run.matcher_token v1),
                  trans_initialized_identifier_list (Run.matcher_token v2) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_mixin_application_class ((kind, body) : mt) :
    CST.mixin_application_class =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4 ] ->
          ( trans_identifier (Run.matcher_token v0),
            Run.opt (fun v -> trans_type_parameters (Run.matcher_token v)) v1,
            Run.trans_token (Run.matcher_token v2),
            trans_mixin_application (Run.matcher_token v3),
            trans_semicolon (Run.matcher_token v4) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_library_import ((kind, body) : mt) : CST.library_import =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1 ] ->
          ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
            trans_import_specification (Run.matcher_token v1) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_extension_body ((kind, body) : mt) : CST.extension_body =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Alt (0, v) ->
                    `Opt_meta_decl__semi
                      (match v with
                      | Seq [ v0; v1; v2 ] ->
                          ( Run.opt
                              (fun v -> trans_metadata (Run.matcher_token v))
                              v0,
                            trans_declaration_ (Run.matcher_token v1),
                            trans_semicolon (Run.matcher_token v2) )
                      | _ -> assert false)
                | Alt (1, v) ->
                    `Opt_meta_meth_sign_func_body
                      (match v with
                      | Seq [ v0; v1; v2 ] ->
                          ( Run.opt
                              (fun v -> trans_metadata (Run.matcher_token v))
                              v0,
                            trans_method_signature (Run.matcher_token v1),
                            trans_function_body (Run.matcher_token v2) )
                      | _ -> assert false)
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_class_body ((kind, body) : mt) : CST.class_body =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2 ] ->
          ( Run.trans_token (Run.matcher_token v0),
            Run.repeat
              (fun v ->
                match v with
                | Seq [ v0; v1 ] -> (
                    ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
                      match v1 with
                      | Alt (0, v) ->
                          `Decl__semi
                            (match v with
                            | Seq [ v0; v1 ] ->
                                ( trans_declaration_ (Run.matcher_token v0),
                                  trans_semicolon (Run.matcher_token v1) )
                            | _ -> assert false)
                      | Alt (1, v) ->
                          `Meth_sign_func_body
                            (match v with
                            | Seq [ v0; v1 ] ->
                                ( trans_method_signature (Run.matcher_token v0),
                                  trans_function_body (Run.matcher_token v1) )
                            | _ -> assert false)
                      | _ -> assert false ))
                | _ -> assert false)
              v1,
            Run.trans_token (Run.matcher_token v2) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_import_or_export ((kind, body) : mt) : CST.import_or_export =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Libr_import (trans_library_import (Run.matcher_token v))
      | Alt (1, v) -> `Libr_export (trans_library_export (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_extension_declaration ((kind, body) : mt) : CST.extension_declaration
    =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Exte_opt_id_opt_type_params_on_type_exte_body
            (match v with
            | Seq [ v0; v1; v2; v3; v4; v5 ] ->
                ( Run.trans_token (Run.matcher_token v0),
                  Run.opt (fun v -> trans_identifier (Run.matcher_token v)) v1,
                  Run.opt
                    (fun v -> trans_type_parameters (Run.matcher_token v))
                    v2,
                  Run.trans_token (Run.matcher_token v3),
                  trans_type_ (Run.matcher_token v4),
                  trans_extension_body (Run.matcher_token v5) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_class_definition ((kind, body) : mt) : CST.class_definition =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_abst_class_id_opt_type_params_opt_supe_opt_inters_class_body
            (match v with
            | Seq [ v0; v1; v2; v3; v4; v5; v6 ] ->
                ( Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v0,
                  Run.trans_token (Run.matcher_token v1),
                  trans_identifier (Run.matcher_token v2),
                  Run.opt
                    (fun v -> trans_type_parameters (Run.matcher_token v))
                    v3,
                  Run.opt (fun v -> trans_superclass (Run.matcher_token v)) v4,
                  Run.opt (fun v -> trans_interfaces (Run.matcher_token v)) v5,
                  trans_class_body (Run.matcher_token v6) )
            | _ -> assert false)
      | Alt (1, v) ->
          `Opt_meta_opt_abst_class_mixin_app_class
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( Run.opt (fun v -> trans_metadata (Run.matcher_token v)) v0,
                  Run.opt (fun v -> Run.trans_token (Run.matcher_token v)) v1,
                  Run.trans_token (Run.matcher_token v2),
                  trans_mixin_application_class (Run.matcher_token v3) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_mixin_declaration ((kind, body) : mt) : CST.mixin_declaration =
  match body with
  | Children v -> (
      match v with
      | Seq [ v0; v1; v2; v3; v4; v5 ] ->
          ( trans_mixin (Run.matcher_token v0),
            trans_identifier (Run.matcher_token v1),
            Run.opt (fun v -> trans_type_parameters (Run.matcher_token v)) v2,
            Run.opt
              (fun v ->
                match v with
                | Seq [ v0; v1 ] ->
                    ( Run.trans_token (Run.matcher_token v0),
                      trans_type_not_void_list (Run.matcher_token v1) )
                | _ -> assert false)
              v3,
            Run.opt (fun v -> trans_interfaces (Run.matcher_token v)) v4,
            trans_class_body (Run.matcher_token v5) )
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_top_level_definition ((kind, body) : mt) : CST.top_level_definition =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) -> `Class_defi (trans_class_definition (Run.matcher_token v))
      | Alt (1, v) -> `Enum_decl (trans_enum_declaration (Run.matcher_token v))
      | Alt (2, v) ->
          `Exte_decl (trans_extension_declaration (Run.matcher_token v))
      | Alt (3, v) ->
          `Mixin_decl (trans_mixin_declaration (Run.matcher_token v))
      | Alt (4, v) -> `Type_alias (trans_type_alias (Run.matcher_token v))
      | Alt (5, v) ->
          `Opt_exte_buil_func_sign_semi
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt
                    (fun v -> trans_external_builtin (Run.matcher_token v))
                    v0,
                  trans_function_signature (Run.matcher_token v1),
                  trans_semicolon (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (6, v) ->
          `Opt_exte_buil_getter_sign_semi
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt
                    (fun v -> trans_external_builtin (Run.matcher_token v))
                    v0,
                  trans_getter_signature (Run.matcher_token v1),
                  trans_semicolon (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (7, v) ->
          `Opt_exte_buil_setter_sign_semi
            (match v with
            | Seq [ v0; v1; v2 ] ->
                ( Run.opt
                    (fun v -> trans_external_builtin (Run.matcher_token v))
                    v0,
                  trans_setter_signature (Run.matcher_token v1),
                  trans_semicolon (Run.matcher_token v2) )
            | _ -> assert false)
      | Alt (8, v) ->
          `Func_sign_func_body
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_function_signature (Run.matcher_token v0),
                  trans_function_body (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (9, v) ->
          `Getter_sign_func_body
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_getter_signature (Run.matcher_token v0),
                  trans_function_body (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (10, v) ->
          `Setter_sign_func_body
            (match v with
            | Seq [ v0; v1 ] ->
                ( trans_setter_signature (Run.matcher_token v0),
                  trans_function_body (Run.matcher_token v1) )
            | _ -> assert false)
      | Alt (11, v) ->
          `Choice_final_buil_opt_type_static_final_decl_list_semi
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( (match v0 with
                  | Alt (0, v) ->
                      `Final_buil (trans_final_builtin (Run.matcher_token v))
                  | Alt (1, v) ->
                      `Const_buil (trans_const_builtin (Run.matcher_token v))
                  | _ -> assert false),
                  Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v1,
                  trans_static_final_declaration_list (Run.matcher_token v2),
                  trans_semicolon (Run.matcher_token v3) )
            | _ -> assert false)
      | Alt (12, v) ->
          `Late_buil_final_buil_opt_type_init_id_list_semi
            (match v with
            | Seq [ v0; v1; v2; v3; v4 ] ->
                ( trans_late_builtin (Run.matcher_token v0),
                  trans_final_builtin (Run.matcher_token v1),
                  Run.opt (fun v -> trans_type_ (Run.matcher_token v)) v2,
                  trans_initialized_identifier_list (Run.matcher_token v3),
                  trans_semicolon (Run.matcher_token v4) )
            | _ -> assert false)
      | Alt (13, v) ->
          `Opt_late_buil_choice_type_init_id_list_semi
            (match v with
            | Seq [ v0; v1; v2; v3 ] ->
                ( Run.opt (fun v -> trans_late_builtin (Run.matcher_token v)) v0,
                  (match v1 with
                  | Alt (0, v) -> `Type (trans_type_ (Run.matcher_token v))
                  | Alt (1, v) ->
                      `Infe_type_opt_type
                        (match v with
                        | Seq [ v0; v1 ] ->
                            ( trans_inferred_type (Run.matcher_token v0),
                              Run.opt
                                (fun v -> trans_type_ (Run.matcher_token v))
                                v1 )
                        | _ -> assert false)
                  | _ -> assert false),
                  trans_initialized_identifier_list (Run.matcher_token v2),
                  trans_semicolon (Run.matcher_token v3) )
            | _ -> assert false)
      | _ -> assert false)
  | Leaf _ -> assert false

let trans_program ((kind, body) : mt) : CST.program =
  match body with
  | Children v -> (
      match v with
      | Alt (0, v) ->
          `Opt_script_tag_opt_libr_name_rep_import_or_export_rep_part_dire_rep_part_of_dire_rep_opt_meta_top_level_defi_rep_stmt
            (match v with
            | Seq [ v0; v1; v2; v3; v4; v5; v6 ] ->
                ( Run.opt (fun v -> trans_script_tag (Run.matcher_token v)) v0,
                  Run.opt (fun v -> trans_library_name (Run.matcher_token v)) v1,
                  Run.repeat
                    (fun v -> trans_import_or_export (Run.matcher_token v))
                    v2,
                  Run.repeat
                    (fun v -> trans_part_directive (Run.matcher_token v))
                    v3,
                  Run.repeat
                    (fun v -> trans_part_of_directive (Run.matcher_token v))
                    v4,
                  Run.repeat
                    (fun v ->
                      match v with
                      | Seq [ v0; v1 ] ->
                          ( Run.opt
                              (fun v -> trans_metadata (Run.matcher_token v))
                              v0,
                            trans_top_level_definition (Run.matcher_token v1) )
                      | _ -> assert false)
                    v5,
                  Run.repeat (fun v -> trans_statement (Run.matcher_token v)) v6
                )
            | _ -> assert false)
      | Alt (1, v) -> `Semg_exp (trans_semgrep_expression (Run.matcher_token v))
      | _ -> assert false)
  | Leaf _ -> assert false

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let root_node = Run.remove_extras ~extras orig_root_node in
  let matched_tree = Run.match_tree children_regexps src root_node in
  let opt_program = Option.map trans_program matched_tree in
  Parsing_result.create src opt_program errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree
