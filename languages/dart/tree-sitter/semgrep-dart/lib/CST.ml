(* Generated by ocaml-tree-sitter. *)
(*
   dart grammar

   entrypoint: program
*)

open! Sexplib.Conv
open Tree_sitter_run

type break_builtin = Token.t

type anon_choice_async_725f72f =
  [ `Async of Token.t (* "async" *)
  | `Asyn of Token.t (* "async*" *)
  | `Sync of Token.t (* "sync*" *) ]

type bitwise_operator =
  [ `AMP of Token.t (* "&" *)
  | `HAT of Token.t (* "^" *)
  | `BAR of Token.t (* "|" *) ]

type increment_operator = Token.t
type unused_escape_sequence = Token.t
type template_chars_single = Token.t
type pat_05bf793 = Token.t (* pattern [^*]*\*+([^/*][^*]*\*+)* *)
type as_operator = Token.t
type documentation_block_comment = Token.t
type pat_d6c261f = Token.t
(* pattern ([^/\n].*\
   )? *)

type block_comment = Token.t
type pat_4fd4a56 = Token.t (* pattern .* *)
type assert_builtin = Token.t
type semgrep_named_ellipsis = Token.t (* pattern \$\.\.\.[A-Z_][A-Z_0-9]* *)
type const_builtin = Token.t
type final_builtin = Token.t

type multiplicative_operator_ =
  [ `STAR of Token.t (* "*" *)
  | `SLASH of Token.t (* "/" *)
  | `PERC of Token.t (* "%" *)
  | `TILDESLASH of Token.t (* "~/" *) ]

type template_chars_single_single = Token.t
type template_chars_double = Token.t
type semicolon = Token.t (* ";" *)

type relational_operator =
  [ `LT of Token.t (* "<" *)
  | `GT of Token.t (* ">" *)
  | `LTEQ of Token.t (* "<=" *)
  | `GTEQ of Token.t (* ">=" *) ]

type decimal_floating_point_literal = Token.t
type tok_is = Token.t
type void_type = Token.t
type identifier = Token.t (* pattern [a-zA-Z_$][\w$]* *)

type identifier_dollar_escaped =
  Token.t (* pattern ([a-zA-Z_]|(\\\$))([\w]|(\\\$))* *)

type pat_a3d33dc = Token.t (* pattern [^a-zA-Z_{] *)
type equality_operator = Token.t

type shift_operator_ =
  [ `LTLT of Token.t (* "<<" *)
  | `GTGT of Token.t (* ">>" *)
  | `GTGTGT of Token.t (* ">>>" *) ]

type hex_integer_literal = Token.t
type pat_0017fb0 = Token.t (* pattern .+ *)
type template_chars_double_single = Token.t
type template_chars_raw_slash = Token.t

type assignment_operator =
  [ `EQ of Token.t (* "=" *)
  | `PLUSEQ of Token.t (* "+=" *)
  | `DASHEQ of Token.t (* "-=" *)
  | `STAREQ of Token.t (* "*=" *)
  | `SLASHEQ of Token.t (* "/=" *)
  | `PERCEQ of Token.t (* "%=" *)
  | `TILDESLASHEQ of Token.t (* "~/=" *)
  | `LTLTEQ of Token.t (* "<<=" *)
  | `GTGTEQ of Token.t (* ">>=" *)
  | `GTGTGTEQ of Token.t (* ">>>=" *)
  | `AMPEQ of Token.t (* "&=" *)
  | `HATEQ of Token.t (* "^=" *)
  | `BAREQ of Token.t (* "|=" *)
  | `QMARKQMARKEQ of Token.t (* "??=" *) ]

type decimal_integer_literal = Token.t
type additive_operator_ = Token.t
type case_builtin = Token.t
type bitwise_operator_ = bitwise_operator

type final_or_const =
  [ `Final_buil of final_builtin (*tok*) | `Const_buil of const_builtin (*tok*) ]

type multiplicative_operator = multiplicative_operator_

type module_name =
  [ `Id of identifier (*tok*)
  | `Module_name_DOT_id of module_name * Token.t (* "." *) * identifier (*tok*)
  ]

type identifier_list_ =
  identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)

type ambiguous_name =
  [ `Id of identifier (*tok*)
  | `Scoped_id of ambiguous_name * Token.t (* "." *) * identifier (*tok*) ]

type catch_clause =
  Token.t (* "catch" *)
  * Token.t (* "(" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) option
  * Token.t (* ")" *)

type identifier_list =
  identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)

type type_dot_identifier = Token.t (* "." *) * identifier (*tok*)
type dot_identifier = Token.t (* "." *) * identifier (*tok*)
type label = identifier (*tok*) * Token.t (* ":" *)
type sub_string_test = Token.t (* "$" *) * pat_a3d33dc
type shift_operator = shift_operator_
type script_tag = Token.t (* "#!" *) * pat_0017fb0 * Token.t (* "\n" *)

type external_and_static =
  Token.t (* "external" *) * Token.t (* "static" *) option

type is_operator = tok_is (*tok*) * Token.t (* "!" *) option

type prefix_operator =
  [ `Minus_op of Token.t (* "-" *)
  | `Nega_op of Token.t (* "!" *)
  | `Tilde_op of Token.t (* "~" *) ]

type combinator =
  [ `Show_id_list of Token.t (* "show" *) * identifier_list
  | `Hide_id_list of Token.t (* "hide" *) * identifier_list ]

type type_name = identifier (*tok*) * type_dot_identifier option
type qualified = identifier (*tok*) * dot_identifier option

type dotted_identifier_list =
  identifier (*tok*) * dot_identifier list (* zero or more *)

type raw_string_literal_double_quotes =
  Token.t (* "r\"" *)
  * [ `Temp_chars_double_single of template_chars_double_single (*tok*)
    | `SQUOT of Token.t (* "'" *)
    | `Temp_chars_raw_slash of template_chars_raw_slash (*tok*)
    | `Unused_esc_seq of unused_escape_sequence (*tok*)
    | `Sub_str_test of sub_string_test
    | `DOLLAR of Token.t (* "$" *) ]
    list
  (* zero or more *)
  * Token.t (* "\"" *)

type raw_string_literal_single_quotes_multiple =
  Token.t (* "r'''" *)
  * [ `Temp_chars_single of template_chars_single (*tok*)
    | `DQUOT of Token.t (* "\"" *)
    | `SQUOT of Token.t (* "'" *)
    | `Temp_chars_raw_slash of template_chars_raw_slash (*tok*)
    | `Unused_esc_seq of unused_escape_sequence (*tok*)
    | `Sub_str_test of sub_string_test
    | `DOLLAR of Token.t (* "$" *) ]
    list
  (* zero or more *)
  * Token.t (* "'''" *)

type raw_string_literal_double_quotes_multiple =
  Token.t (* "r\"\"\"" *)
  * [ `Temp_chars_double of template_chars_double (*tok*)
    | `SQUOT of Token.t (* "'" *)
    | `Temp_chars_raw_slash of template_chars_raw_slash (*tok*)
    | `DQUOT of Token.t (* "\"" *)
    | `Unused_esc_seq of unused_escape_sequence (*tok*)
    | `Sub_str_test of sub_string_test
    | `DOLLAR of Token.t (* "$" *) ]
    list
  (* zero or more *)
  * Token.t (* "\"\"\"" *)

type raw_string_literal_single_quotes =
  Token.t (* "r'" *)
  * [ `Temp_chars_single_single of template_chars_single_single (*tok*)
    | `DQUOT of Token.t (* "\"" *)
    | `Temp_chars_raw_slash of template_chars_raw_slash (*tok*)
    | `Unused_esc_seq of unused_escape_sequence (*tok*)
    | `Sub_str_test of sub_string_test
    | `DOLLAR of Token.t (* "$" *) ]
    list
  (* zero or more *)
  * Token.t (* "'" *)

type binary_operator =
  [ `Mult_op of multiplicative_operator
  | `Addi_op of additive_operator_ (*tok*)
  | `Shift_op of shift_operator
  | `Rela_op of relational_operator
  | `EQEQ of Token.t (* "==" *)
  | `Bitw_op_ of bitwise_operator_ ]

type additive_expression =
  [ `Real_exp_rep1_addi_op_real_exp of
    real_expression
    * (additive_operator_ (*tok*) * real_expression) list (* one or more *)
  | `Super_rep1_addi_op_real_exp of
    Token.t (* "super" *)
    * (additive_operator_ (*tok*) * real_expression) list (* one or more *) ]

and annotation_ =
  [ `Marker_anno of Token.t (* "@" *) * ambiguous_name
  | `Anno of Token.t (* "@" *) * ambiguous_name * arguments ]

and anon_arg_rep_COMMA_arg_eb223b2 =
  argument * (Token.t (* "," *) * argument) list (* zero or more *)

and anon_elem_rep_COMMA_elem_opt_COMMA_4ec364f =
  element
  * (Token.t (* "," *) * element) list (* zero or more *)
  * Token.t (* "," *) option

and argument = expression

and argument_list =
  [ `Named_arg_rep_COMMA_named_arg of
    named_argument
    * (Token.t (* "," *) * named_argument) list (* zero or more *)
  | `Arg_rep_COMMA_arg_rep_COMMA_named_arg_rep_COMMA_named_arg of
    argument
    * (Token.t (* "," *) * argument) list (* zero or more *)
    * (Token.t (* "," *)
      * named_argument
      * (Token.t (* "," *) * named_argument) list (* zero or more *))
      list
    (* zero or more *) ]

and argument_part = type_arguments option * arguments

and arguments =
  Token.t (* "(" *)
  * (argument_list * Token.t (* "," *) option) option
  * Token.t (* ")" *)

and assertion =
  assert_builtin (*tok*)
  * Token.t (* "(" *)
  * argument
  * (Token.t (* "," *) * argument) option
  * Token.t (* "," *) option
  * Token.t (* ")" *)

and assignable_expression =
  [ `Prim_assi_sele_part of primary * assignable_selector_part
  | `Super_unco_assi_sele of
    Token.t (* "super" *) * unconditional_assignable_selector
  | `Cons_invo_assi_sele_part of
    constructor_invocation * assignable_selector_part
  | `Id of identifier (*tok*) ]

and assignable_selector =
  [ `Unco_assi_sele of unconditional_assignable_selector
  | `Cond_assi_sele of Token.t (* "?." *) * identifier (*tok*) ]

and assignable_selector_part =
  selector list (* zero or more *) * assignable_selector

and assignment_expression =
  assignable_expression * assignment_operator * argument

and bitwise_and_expression =
  [ `Real_exp_rep1_AMP_real_exp of
    real_expression
    * (Token.t (* "&" *) * real_expression) list (* one or more *)
  | `Super_rep1_AMP_real_exp of
    Token.t (* "super" *)
    * (Token.t (* "&" *) * real_expression) list (* one or more *) ]

and bitwise_or_expression =
  [ `Real_exp_rep1_BAR_real_exp of
    real_expression
    * (Token.t (* "|" *) * real_expression) list (* one or more *)
  | `Super_rep1_BAR_real_exp of
    Token.t (* "super" *)
    * (Token.t (* "|" *) * real_expression) list (* one or more *) ]

and bitwise_xor_expression =
  [ `Real_exp_rep1_HAT_real_exp of
    real_expression
    * (Token.t (* "^" *) * real_expression) list (* one or more *)
  | `Super_rep1_HAT_real_exp of
    Token.t (* "super" *)
    * (Token.t (* "^" *) * real_expression) list (* one or more *) ]

and block =
  Token.t (* "{" *) * statement list (* zero or more *) * Token.t (* "}" *)

and cascade_assignment_section =
  assignment_operator * expression_without_cascade

and cascade_section =
  [ `DOTDOT of Token.t (* ".." *) | `QMARKDOTDOT of Token.t (* "?.." *) ]
  * cascade_selector
  * argument_part list (* zero or more *)
  * cascade_subsection list (* zero or more *)
  * cascade_assignment_section option

and cascade_selector =
  [ `Opt_null_type_LBRACK_exp_RBRACK of
    Token.t (* "?" *) option * Token.t (* "[" *) * argument * Token.t (* "]" *)
  | `Id of identifier (*tok*) ]

and cascade_subsection =
  assignable_selector * argument_part list (* zero or more *)

and constructor_invocation =
  type_name
  * type_arguments
  * Token.t (* "." *)
  * identifier (*tok*)
  * arguments

and constructor_param =
  final_const_var_or_type option
  * Token.t (* "this" *)
  * Token.t (* "." *)
  * identifier (*tok*)
  * formal_parameter_part option

and declared_identifier =
  metadata option
  * Token.t (* "covariant" *) option
  * final_const_var_or_type
  * identifier (*tok*)

and default_formal_parameter =
  formal_parameter * (Token.t (* "=" *) * argument) option

and default_named_parameter =
  [ `Opt_requ_formal_param_opt_EQ_exp of
    Token.t (* "required" *) option
    * formal_parameter
    * (Token.t (* "=" *) * argument) option
  | `Opt_requ_formal_param_opt_COLON_exp of
    Token.t (* "required" *) option
    * formal_parameter
    * (Token.t (* ":" *) * argument) option ]

and element =
  [ `Exp of argument
  | `Pair of argument * Token.t (* ":" *) * argument
  | `Spread_elem of Token.t (* "..." *) * Token.t (* "?" *) option * argument
  | `If_elem of
    Token.t (* "if" *)
    * parenthesized_expression
    * element
    * (Token.t (* "else" *) * element) option
  | `For_elem of
    Token.t (* "await" *) option
    * Token.t (* "for" *)
    * Token.t (* "(" *)
    * for_loop_parts
    * Token.t (* ")" *)
    * element ]

and equality_expression =
  [ `Real_exp_equa_op_real_exp of
    real_expression * equality_operator (*tok*) * real_expression
  | `Super_equa_op_real_exp of
    Token.t (* "super" *) * equality_operator (*tok*) * real_expression ]

and expression =
  [ `Choice_assign_exp of
    [ `Assign_exp of assignment_expression
    | `Throw_exp of throw_expression
    | `Real_exp_rep_casc_sect of
      real_expression * cascade_section list (* zero or more *) ]
  | `Semg_ellips of Token.t (* "..." *)
  | `Semg_named_ellips of semgrep_named_ellipsis (*tok*)
  | `Deep_ellips of Token.t (* "<..." *) * argument * Token.t (* "...>" *) ]

and expression_statement =
  [ `Exp_semi of argument * semicolon | `Semg_ellips of Token.t (* "..." *) ]

and expression_without_cascade =
  [ `Assign_exp_with_casc of
    assignable_expression * assignment_operator * expression_without_cascade
  | `Real_exp of real_expression
  | `Throw_exp_with_casc of Token.t (* "throw" *) * expression_without_cascade
  ]

and final_const_var_or_type =
  [ `Opt_late_buil_final_buil_opt_type of
    Token.t (* "late" *) option * final_builtin (*tok*) * type_ option
  | `Const_buil_opt_type of const_builtin (*tok*) * type_ option
  | `Opt_late_buil_var_or_type of Token.t (* "late" *) option * var_or_type ]

and finally_clause = Token.t (* "finally" *) * block

and for_loop_parts =
  [ `Choice_decl_id_in_exp of
    [ `Decl_id of declared_identifier | `Id of identifier (*tok*) ]
    * Token.t (* "in" *)
    * argument
  | `Opt_choice_local_var_decl_opt_exp_semi_opt_exp_rep_COMMA_exp of
    [ `Local_var_decl of local_variable_declaration
    | `Opt_exp_rep_COMMA_exp_semi of
      anon_arg_rep_COMMA_arg_eb223b2 option * semicolon ]
    option
    * argument option
    * semicolon
    * anon_arg_rep_COMMA_arg_eb223b2 option ]

and formal_parameter =
  [ `Semg_ellips of Token.t (* "..." *)
  | `Normal_formal_param of
    metadata option
    * [ `Func_formal_param of function_formal_parameter
      | `Simple_formal_param of simple_formal_parameter
      | `Cons_param of constructor_param
      | `Super_formal_param of super_formal_parameter ] ]

and formal_parameter_list = strict_formal_parameter_list
and formal_parameter_part = type_parameters option * formal_parameter_list

and function_body =
  [ `Opt_async_EQGT_exp_semi of
    Token.t (* "async" *) option * Token.t (* "=>" *) * argument * semicolon
  | `Opt_choice_async_blk of anon_choice_async_725f72f option * block ]

and function_expression_body =
  [ `Opt_async_EQGT_exp of
    Token.t (* "async" *) option * Token.t (* "=>" *) * argument
  | `Opt_choice_async_blk of anon_choice_async_725f72f option * block ]

and function_formal_parameter =
  Token.t (* "covariant" *) option
  * type_ option
  * identifier (*tok*)
  * formal_parameter_part
  * Token.t (* "?" *) option

and function_signature =
  type_ option
  * [ `Get of Token.t (* "get" *)
    | `Set of Token.t (* "set" *)
    | `Id of identifier (*tok*) ]
  * formal_parameter_part
  * native option

and function_type =
  [ `Func_type_tails of function_type_tails
  | `Type_not_func_func_type_tails of type_not_function * function_type_tails
  ]

and function_type_tail =
  Token.t (* "Function" *)
  * type_parameters option
  * Token.t (* "?" *) option
  * parameter_type_list option
  * Token.t (* "?" *) option

and function_type_tails = function_type_tail list (* one or more *)

and if_null_expression_ =
  (Token.t (* "??" *) * real_expression) list (* one or more *)

and initialized_identifier =
  identifier (*tok*) * (Token.t (* "=" *) * argument) option

and initialized_variable_definition =
  declared_identifier
  * (Token.t (* "=" *) * argument) option
  * (Token.t (* "," *) * initialized_identifier) list (* zero or more *)

and interface_type_list =
  type_ * (Token.t (* "," *) * type_) list (* zero or more *)

and lambda_expression = function_signature * function_body

and literal =
  [ `Deci_int_lit of decimal_integer_literal (*tok*)
  | `Hex_int_lit of hex_integer_literal (*tok*)
  | `Deci_floa_point_lit of decimal_floating_point_literal (*tok*)
  | `True of Token.t (* "true" *)
  | `False of Token.t (* "false" *)
  | `Str_lit of uri
  | `Null_lit of Token.t (* "null" *)
  | `Symb_lit of Token.t (* "#" *) * identifier (*tok*)
  | `List_lit of
    const_builtin (*tok*) option
    * type_arguments option
    * Token.t (* "[" *)
    * anon_elem_rep_COMMA_elem_opt_COMMA_4ec364f option
    * Token.t (* "]" *)
  | `Set_or_map_lit of
    const_builtin (*tok*) option
    * type_arguments option
    * Token.t (* "{" *)
    * anon_elem_rep_COMMA_elem_opt_COMMA_4ec364f option
    * Token.t (* "}" *) ]

and local_variable_declaration = initialized_variable_definition * semicolon
and metadata = annotation_ list (* one or more *)

and multiplicative_expression =
  [ `Un_exp_rep1_mult_op_un_exp of
    unary_expression
    * (multiplicative_operator * unary_expression) list (* one or more *)
  | `Super_rep1_mult_op_un_exp of
    Token.t (* "super" *)
    * (multiplicative_operator * unary_expression) list (* one or more *) ]

and named_argument = label * argument

and named_parameter_type =
  metadata option * Token.t (* "required" *) option * typed_identifier

and native = Token.t (* "native" *) * uri option

and normal_formal_parameters =
  formal_parameter
  * (Token.t (* "," *) * formal_parameter) list (* zero or more *)

and normal_parameter_type =
  metadata option * [ `Typed_id of typed_identifier | `Type of type_ ]

and on_part =
  [ `Catch_clause_blk of catch_clause * block
  | `On_type_not_void_opt_catch_clause_blk of
    Token.t (* "on" *) * type_not_void * catch_clause option * block ]

and optional_formal_parameters =
  [ `Opt_post_formal_params of
    Token.t (* "[" *)
    * default_formal_parameter
    * (Token.t (* "," *) * default_formal_parameter) list (* zero or more *)
    * Token.t (* "," *) option
    * Token.t (* "]" *)
  | `Named_formal_params of
    Token.t (* "{" *)
    * default_named_parameter
    * (Token.t (* "," *) * default_named_parameter) list (* zero or more *)
    * Token.t (* "," *) option
    * Token.t (* "}" *) ]

and optional_parameter_types =
  [ `Opt_posi_param_types of
    Token.t (* "[" *)
    * normal_parameter_type
    * (Token.t (* "," *) * normal_parameter_type) list (* zero or more *)
    * Token.t (* "," *) option
    * Token.t (* "]" *)
  | `Named_param_types of
    Token.t (* "{" *)
    * named_parameter_type
    * (Token.t (* "," *) * named_parameter_type) list (* zero or more *)
    * Token.t (* "," *) option
    * Token.t (* "}" *) ]

and parameter_type_list =
  Token.t (* "(" *)
  * [ `Normal_param_type_rep_COMMA_normal_param_type_opt_COMMA of
      normal_parameter_type
      * (Token.t (* "," *) * normal_parameter_type) list (* zero or more *)
      * Token.t (* "," *) option
    | `Normal_param_type_rep_COMMA_normal_param_type_COMMA_opt_param_types of
      normal_parameter_type
      * (Token.t (* "," *) * normal_parameter_type) list (* zero or more *)
      * Token.t (* "," *)
      * optional_parameter_types
    | `Opt_param_types of optional_parameter_types ]
    option
  * Token.t (* ")" *)

and parenthesized_expression = Token.t (* "(" *) * argument * Token.t (* ")" *)

and postfix_expression =
  [ `Prim_rep_sele of primary * selector list (* zero or more *)
  | `Post_exp_ of postfix_expression_ ]

and postfix_expression_ =
  [ `Assi_exp_post_op of assignable_expression * increment_operator (*tok*)
  | `Cons_invo_rep_sele of
    constructor_invocation * selector list (* zero or more *) ]

and primary =
  [ `Lit of literal
  | `Func_exp of formal_parameter_part * function_expression_body
  | `Id of identifier (*tok*)
  | `New_exp of
    Token.t (* "new" *) * type_not_void * dot_identifier option * arguments
  | `Const_obj_exp of
    const_builtin (*tok*) * type_not_void * dot_identifier option * arguments
  | `LPAR_exp_RPAR of parenthesized_expression
  | `This of Token.t (* "this" *)
  | `Super_unco_assi_sele of
    Token.t (* "super" *) * unconditional_assignable_selector ]

and real_expression =
  [ `Cond_exp of
    real_expression
    * Token.t (* "?" *)
    * expression_without_cascade
    * Token.t (* ":" *)
    * expression_without_cascade
  | `Logi_or_exp of
    real_expression
    * (Token.t (* "||" *) * real_expression) list (* one or more *)
  | `If_null_exp of real_expression * if_null_expression_
  | `Addi_exp of additive_expression
  | `Mult_exp of multiplicative_expression
  | `Rela_exp of relational_expression
  | `Equa_exp of equality_expression
  | `Logi_and_exp of
    real_expression
    * (Token.t (* "&&" *) * real_expression) list (* one or more *)
  | `Bitw_and_exp of bitwise_and_expression
  | `Bitw_or_exp of bitwise_or_expression
  | `Bitw_xor_exp of bitwise_xor_expression
  | `Shift_exp of shift_expression
  | `Type_cast_exp of real_expression * type_cast
  | `Type_test_exp of real_expression * type_test
  | `Un_exp of unary_expression ]

and relational_expression =
  [ `Real_exp_rela_op_real_exp of
    real_expression * relational_operator * real_expression
  | `Super_rela_op_real_exp of
    Token.t (* "super" *) * relational_operator * real_expression ]

and selector =
  [ `Excl_op of Token.t (* "!" *)
  | `Assi_sele of assignable_selector
  | `Arg_part of argument_part ]

and shift_expression =
  [ `Real_exp_rep1_shift_op_real_exp of
    real_expression * (shift_operator * real_expression) list (* one or more *)
  | `Super_rep1_shift_op_real_exp of
    Token.t (* "super" *)
    * (shift_operator * real_expression) list (* one or more *) ]

and simple_formal_parameter =
  [ `Decl_id of declared_identifier
  | `Opt_cova_id of Token.t (* "covariant" *) option * identifier (*tok*) ]

and statement =
  [ `Blk of block
  | `Local_func_decl of metadata option * lambda_expression
  | `Local_var_decl of local_variable_declaration
  | `For_stmt of
    Token.t (* "await" *) option
    * Token.t (* "for" *)
    * Token.t (* "(" *)
    * for_loop_parts
    * Token.t (* ")" *)
    * statement
  | `While_stmt of Token.t (* "while" *) * parenthesized_expression * statement
  | `Do_stmt of
    Token.t (* "do" *)
    * statement
    * Token.t (* "while" *)
    * parenthesized_expression
    * semicolon
  | `Switch_stmt of
    Token.t (* "switch" *) * parenthesized_expression * switch_block
  | `If_stmt of
    Token.t (* "if" *)
    * parenthesized_expression
    * statement
    * (Token.t (* "else" *) * statement) option
  | `Try_stmt of
    try_head
    * [ `Fina_clause of finally_clause
      | `Rep1_on_part_opt_fina_clause of
        on_part list (* one or more *) * finally_clause option ]
  | `Brk_stmt of break_builtin (*tok*) * identifier (*tok*) option * semicolon
  | `Cont_stmt of
    Token.t (* "continue" *) * identifier (*tok*) option * semicolon
  | `Ret_stmt of Token.t (* "return" *) * argument option * semicolon
  | `Yield_stmt of Token.t (* "yield" *) * argument * semicolon
  | `Yield_each_stmt of
    Token.t (* "yield" *) * Token.t (* "*" *) * argument * semicolon
  | `Exp_stmt of expression_statement
  | `Assert_stmt of assertion * Token.t (* ";" *) ]

and strict_formal_parameter_list =
  [ `LPAR_RPAR of Token.t (* "(" *) * Token.t (* ")" *)
  | `LPAR_normal_formal_params_opt_COMMA_RPAR of
    Token.t (* "(" *)
    * normal_formal_parameters
    * Token.t (* "," *) option
    * Token.t (* ")" *)
  | `LPAR_normal_formal_params_COMMA_opt_formal_params_RPAR of
    Token.t (* "(" *)
    * normal_formal_parameters
    * Token.t (* "," *)
    * optional_formal_parameters
    * Token.t (* ")" *)
  | `LPAR_opt_formal_params_RPAR of
    Token.t (* "(" *) * optional_formal_parameters * Token.t (* ")" *) ]

and string_literal =
  [ `Str_lit_double_quotes of string_literal_double_quotes
  | `Str_lit_single_quotes of string_literal_single_quotes
  | `Str_lit_double_quotes_mult of string_literal_double_quotes_multiple
  | `Str_lit_single_quotes_mult of string_literal_single_quotes_multiple
  | `Raw_str_lit_double_quotes of raw_string_literal_double_quotes
  | `Raw_str_lit_single_quotes of raw_string_literal_single_quotes
  | `Raw_str_lit_double_quotes_mult of raw_string_literal_double_quotes_multiple
  | `Raw_str_lit_single_quotes_mult of raw_string_literal_single_quotes_multiple
  ]
  list
(* one or more *)

and string_literal_double_quotes =
  Token.t (* "\"" *)
  * [ `Temp_chars_double_single of template_chars_double_single (*tok*)
    | `SQUOT of Token.t (* "'" *)
    | `Esc_seq of unused_escape_sequence (*tok*)
    | `Sub_str_test of sub_string_test
    | `Temp_subs of template_substitution ]
    list
  (* zero or more *)
  * Token.t (* "\"" *)

and string_literal_double_quotes_multiple =
  Token.t (* "\"\"\"" *)
  * [ `Temp_chars_double of template_chars_double (*tok*)
    | `SQUOT of Token.t (* "'" *)
    | `DQUOT of Token.t (* "\"" *)
    | `Esc_seq of unused_escape_sequence (*tok*)
    | `Sub_str_test of sub_string_test
    | `Temp_subs of template_substitution ]
    list
  (* zero or more *)
  * Token.t (* "\"\"\"" *)

and string_literal_single_quotes =
  Token.t (* "'" *)
  * [ `Temp_chars_single_single of template_chars_single_single (*tok*)
    | `DQUOT of Token.t (* "\"" *)
    | `Esc_seq of unused_escape_sequence (*tok*)
    | `Sub_str_test of sub_string_test
    | `Temp_subs of template_substitution ]
    list
  (* zero or more *)
  * Token.t (* "'" *)

and string_literal_single_quotes_multiple =
  Token.t (* "'''" *)
  * [ `Temp_chars_single of template_chars_single (*tok*)
    | `DQUOT of Token.t (* "\"" *)
    | `SQUOT of Token.t (* "'" *)
    | `Esc_seq of unused_escape_sequence (*tok*)
    | `Sub_str_test of sub_string_test
    | `Temp_subs of template_substitution ]
    list
  (* zero or more *)
  * Token.t (* "'''" *)

and super_formal_parameter =
  final_const_var_or_type option
  * Token.t (* "super" *)
  * Token.t (* "." *)
  * identifier (*tok*)
  * formal_parameter_part option

and switch_block =
  Token.t (* "{" *)
  * [ `Switch_label of switch_label | `Stmt of statement ] list
  (* zero or more *)
  * Token.t (* "}" *)

and switch_label =
  label list (* zero or more *)
  * [ `Case_buil_exp_COLON of
      case_builtin (*tok*) * argument * Token.t (* ":" *)
    | `Defa_COLON of Token.t (* "default" *) * Token.t (* ":" *) ]

and template_substitution =
  Token.t (* "$" *)
  * [ `LCURL_exp_RCURL of Token.t (* "{" *) * argument * Token.t (* "}" *)
    | `Id_dollar_esca of identifier_dollar_escaped (*tok*) ]

and throw_expression = Token.t (* "throw" *) * argument
and try_head = Token.t (* "try" *) * block

and type_ =
  [ `Func_type_opt_null_type of function_type * Token.t (* "?" *) option
  | `Type_not_func of type_not_function ]

and type_arguments =
  [ `LT_opt_type_rep_COMMA_type_GT of
    Token.t (* "<" *) * interface_type_list option * Token.t (* ">" *) ]

and type_bound = Token.t (* "extends" *) * type_not_void
and type_cast = as_operator (*tok*) * type_not_void

and type_not_function =
  [ `Type_not_void_not_func of type_not_void_not_function
  | `Void_type of void_type (*tok*) ]

and type_not_void =
  [ `Func_type_opt_null_type of function_type * Token.t (* "?" *) option
  | `Type_not_void_not_func of type_not_void_not_function ]

and type_not_void_not_function =
  [ `Type_name_opt_type_args_opt_null_type of
    type_name * type_arguments option * Token.t (* "?" *) option
  | `Func_buil_id_opt_null_type of
    Token.t (* "Function" *) * Token.t (* "?" *) option ]

and type_parameter =
  metadata option
  * identifier (*tok*)
  * Token.t (* "?" *) option
  * type_bound option

and type_parameters =
  Token.t (* "<" *)
  * type_parameter
  * (Token.t (* "," *) * type_parameter) list (* zero or more *)
  * Token.t (* ">" *)

and type_test = is_operator * type_not_void
and typed_identifier = type_ * identifier (*tok*)

and unary_expression =
  [ `Post_exp of postfix_expression | `Un_exp_ of unary_expression_ ]

and unary_expression_ =
  [ `Prefix_op_un_exp of prefix_operator * unary_expression
  | `Await_exp of Token.t (* "await" *) * unary_expression
  | `Choice_minus_op_super of
    [ `Minus_op of Token.t (* "-" *) | `Tilde_op of Token.t (* "~" *) ]
    * Token.t (* "super" *)
  | `Incr_op_assi_exp of increment_operator (*tok*) * assignable_expression ]

and unconditional_assignable_selector =
  [ `Opt_null_type_LBRACK_exp_RBRACK of
    Token.t (* "?" *) option * Token.t (* "[" *) * argument * Token.t (* "]" *)
  | `DOT_id of dot_identifier ]

and uri = string_literal

and var_or_type =
  [ `Type of type_ | `Infe_type_opt_type of Token.t (* "var" *) * type_ option ]

type wildcard_bounds =
  [ `Extends_type of Token.t (* "extends" *) * type_
  | `Super_type of Token.t (* "super" *) * type_ ]

type explicit_constructor_invocation =
  [ `Opt_type_args_choice_this of
    type_arguments option
    * [ `This of Token.t (* "this" *) | `Super of Token.t (* "super" *) ]
  | `Choice_choice_id_DOT_opt_type_args_super of
    [ `Choice_id of ambiguous_name | `Prim of primary ]
    * Token.t (* "." *)
    * type_arguments option
    * Token.t (* "super" *) ]
  * arguments
  * semicolon

type throws =
  Token.t (* "throws" *)
  * type_
  * (Token.t (* "," *) * type_) list (* zero or more *)

type part_directive = metadata option * Token.t (* "part" *) * uri * semicolon
type uri_test = dotted_identifier_list * (Token.t (* "==" *) * uri) option

type initialized_identifier_list =
  initialized_identifier
  * (Token.t (* "," *) * initialized_identifier) list (* zero or more *)

type enum_constant = metadata option * identifier (*tok*)

type setter_signature =
  type_ option
  * Token.t (* "set" *)
  * identifier (*tok*)
  * formal_parameter_part
  * native option

type anon_choice_type_be0da33 =
  [ `Type of type_ | `Infe_type of Token.t (* "var" *) ]

type operator_signature =
  type_ option
  * Token.t (* "operator" *)
  * [ `TILDE of Token.t (* "~" *)
    | `Bin_op of binary_operator
    | `LBRACKRBRACK of Token.t (* "[]" *)
    | `LBRACKRBRACKEQ of Token.t (* "[]=" *) ]
  * formal_parameter_list
  * native option

type static_final_declaration =
  identifier (*tok*) * Token.t (* "=" *) * argument

type type_not_void_list =
  type_not_void * (Token.t (* "," *) * type_not_void) list (* zero or more *)

type dimensions = (metadata option * Token.t (* "[" *) * Token.t (* "]" *)) list
(* one or more *)

type library_name =
  metadata option * Token.t (* "library" *) * dotted_identifier_list * semicolon

type getter_signature =
  type_ option * Token.t (* "get" *) * identifier (*tok*) * native option

type constant_constructor_signature =
  const_builtin (*tok*) * qualified * formal_parameter_list

type factory_constructor_signature =
  Token.t (* "factory" *)
  * identifier (*tok*)
  * dot_identifier list (* zero or more *)
  * formal_parameter_list

type part_of_directive =
  metadata option
  * Token.t (* "part" *)
  * Token.t (* "of" *)
  * [ `Dotted_id_list of dotted_identifier_list | `Uri of uri ]
  * semicolon

type type_alias =
  [ `Type_type_name_opt_type_params_EQ_func_type_SEMI of
    Token.t (* "typedef" *)
    * type_name
    * type_parameters option
    * Token.t (* "=" *)
    * function_type
    * Token.t (* ";" *)
  | `Type_opt_type_type_name_formal_param_part_SEMI of
    Token.t (* "typedef" *)
    * type_ option
    * type_name
    * formal_parameter_part
    * Token.t (* ";" *) ]

type constructor_signature =
  identifier (*tok*) * dot_identifier option * formal_parameter_list

type configuration_uri =
  Token.t (* "if" *) * Token.t (* "(" *) * uri_test * Token.t (* ")" *) * uri

type enum_body =
  Token.t (* "{" *)
  * enum_constant
  * (Token.t (* "," *) * enum_constant) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "}" *)

type static_final_declaration_list =
  static_final_declaration
  * (Token.t (* "," *) * static_final_declaration) list (* zero or more *)

type interfaces = Token.t (* "implements" *) * type_not_void_list
type mixins = Token.t (* "with" *) * type_not_void_list

type method_declarator =
  identifier (*tok*) * formal_parameter_list * dimensions option

type initializer_list_entry =
  [ `Super_opt_DOT_qual_args of
    Token.t (* "super" *) * (Token.t (* "." *) * qualified) option * arguments
  | `Field_init of
    (Token.t (* "this" *) * Token.t (* "." *)) option
    * identifier (*tok*)
    * Token.t (* "=" *)
    * real_expression
    * cascade_section list (* zero or more *)
  | `Asse of assertion ]

type configurable_uri = uri * configuration_uri list (* zero or more *)
type enum_declaration = Token.t (* "enum" *) * identifier (*tok*) * enum_body
type mixin_application = type_not_void * mixins * interfaces option

type superclass =
  [ `Extends_type_not_void_opt_mixins of
    Token.t (* "extends" *) * type_not_void * mixins option
  | `Mixins of mixins ]

type initializers =
  Token.t (* ":" *)
  * initializer_list_entry
  * (Token.t (* "," *) * initializer_list_entry) list (* zero or more *)

type import_specification =
  [ `Import_conf_uri_opt_as_id_rep_comb_semi of
    Token.t (* "import" *)
    * configurable_uri
    * (Token.t (* "as" *) * identifier (*tok*)) option
    * combinator list (* zero or more *)
    * semicolon
  | `Import_uri_defe_as_id_rep_comb_semi of
    Token.t (* "import" *)
    * uri
    * Token.t (* "deferred" *)
    * Token.t (* "as" *)
    * identifier (*tok*)
    * combinator list (* zero or more *)
    * semicolon ]

type mixin_application_class =
  identifier (*tok*)
  * type_parameters option
  * Token.t (* "=" *)
  * mixin_application
  * semicolon

type method_signature =
  [ `Cons_sign_opt_initis of constructor_signature * initializers option
  | `Fact_cons_sign of factory_constructor_signature
  | `Opt_static_choice_func_sign of
    Token.t (* "static" *) option
    * [ `Func_sign of function_signature
      | `Getter_sign of getter_signature
      | `Setter_sign of setter_signature ]
  | `Op_sign of operator_signature ]

type anon_choice_redi_3f8cf96 =
  [ `Redi of
    Token.t (* ":" *) * Token.t (* "this" *) * dot_identifier option * arguments
  | `Initis of initializers ]

type declaration_ =
  [ `Cst_cons_sign_opt_choice_redi of
    constant_constructor_signature * anon_choice_redi_3f8cf96 option
  | `Cons_sign_opt_choice_redi of
    constructor_signature * anon_choice_redi_3f8cf96 option
  | `Exte_opt_const_buil_fact_cons_sign of
    Token.t (* "external" *)
    * const_builtin (*tok*) option
    * factory_constructor_signature
  | `Opt_const_buil_fact_cons_sign_native of
    const_builtin (*tok*) option * factory_constructor_signature * native
  | `Exte_cst_cons_sign of
    Token.t (* "external" *) * constant_constructor_signature
  | `Redi_fact_cons_sign of
    const_builtin (*tok*) option
    * Token.t (* "factory" *)
    * identifier (*tok*)
    * dot_identifier list (* zero or more *)
    * formal_parameter_list
    * Token.t (* "=" *)
    * type_not_void
    * dot_identifier option
  | `Exte_cons_sign of Token.t (* "external" *) * constructor_signature
  | `Opt_exte_buil_opt_static_getter_sign of
    Token.t (* "external" *) option
    * Token.t (* "static" *) option
    * getter_signature
  | `Opt_exte_and_static_setter_sign of
    external_and_static option * setter_signature
  | `Opt_exte_op_sign of Token.t (* "external" *) option * operator_signature
  | `Opt_exte_and_static_func_sign of
    external_and_static option * function_signature
  | `Static_func_sign of Token.t (* "static" *) * function_signature
  | `Static_choice_final_or_const_opt_type_static_final_decl_list of
    Token.t (* "static" *)
    * [ `Final_or_const_opt_type_static_final_decl_list of
        final_or_const * type_ option * static_final_declaration_list
      | `Late_buil_choice_final_buil_opt_type_init_id_list of
        Token.t (* "late" *)
        * [ `Final_buil_opt_type_init_id_list of
            final_builtin (*tok*) * type_ option * initialized_identifier_list
          | `Choice_type_init_id_list of
            anon_choice_type_be0da33 * initialized_identifier_list ]
      | `Choice_type_init_id_list of
        anon_choice_type_be0da33 * initialized_identifier_list ]
  | `Cova_choice_late_buil_choice_final_buil_opt_type_id_list_ of
    Token.t (* "covariant" *)
    * [ `Late_buil_choice_final_buil_opt_type_id_list_ of
        Token.t (* "late" *)
        * [ `Final_buil_opt_type_id_list_ of
            final_builtin (*tok*) * type_ option * identifier_list_
          | `Choice_type_init_id_list of
            anon_choice_type_be0da33 * initialized_identifier_list ]
      | `Choice_type_init_id_list of
        anon_choice_type_be0da33 * initialized_identifier_list ]
  | `Opt_late_buil_final_buil_opt_type_init_id_list of
    Token.t (* "late" *) option
    * final_builtin (*tok*)
    * type_ option
    * initialized_identifier_list
  | `Opt_late_buil_var_or_type_init_id_list of
    Token.t (* "late" *) option * var_or_type * initialized_identifier_list ]

type import_or_export =
  [ `Libr_import of metadata option * import_specification
  | `Libr_export of
    metadata option
    * Token.t (* "export" *)
    * configurable_uri
    * combinator list (* zero or more *)
    * semicolon ]

type class_member_definition =
  [ `Decl__semi of declaration_ * semicolon
  | `Meth_sign_func_body of method_signature * function_body ]

type extension_body =
  Token.t (* "{" *)
  * [ `Opt_meta_decl__semi of metadata option * declaration_ * semicolon
    | `Opt_meta_meth_sign_func_body of
      metadata option * method_signature * function_body ]
    list
  (* zero or more *)
  * Token.t (* "}" *)

type class_body =
  Token.t (* "{" *)
  * (metadata option * class_member_definition) list (* zero or more *)
  * Token.t (* "}" *)

type extension_declaration =
  [ `Exte_opt_id_opt_type_params_on_type_exte_body of
    Token.t (* "extension" *)
    * identifier (*tok*) option
    * type_parameters option
    * Token.t (* "on" *)
    * type_
    * extension_body ]

type class_definition =
  [ `Opt_abst_class_id_opt_type_params_opt_supe_opt_inters_class_body of
    Token.t (* "abstract" *) option
    * Token.t (* "class" *)
    * identifier (*tok*)
    * type_parameters option
    * superclass option
    * interfaces option
    * class_body
  | `Opt_meta_opt_abst_class_mixin_app_class of
    metadata option
    * Token.t (* "abstract" *) option
    * Token.t (* "class" *)
    * mixin_application_class ]

type top_level_definition =
  [ `Class_defi of class_definition
  | `Enum_decl of enum_declaration
  | `Exte_decl of extension_declaration
  | `Mixin_decl of
    Token.t (* "mixin" *)
    * identifier (*tok*)
    * type_parameters option
    * (Token.t (* "on" *) * type_not_void_list) option
    * interfaces option
    * class_body
  | `Type_alias of type_alias
  | `Opt_exte_buil_func_sign_semi of
    Token.t (* "external" *) option * function_signature * semicolon
  | `Opt_exte_buil_getter_sign_semi of
    Token.t (* "external" *) option * getter_signature * semicolon
  | `Opt_exte_buil_setter_sign_semi of
    Token.t (* "external" *) option * setter_signature * semicolon
  | `Func_sign_func_body of lambda_expression
  | `Getter_sign_func_body of getter_signature * function_body
  | `Setter_sign_func_body of setter_signature * function_body
  | `Choice_final_buil_opt_type_static_final_decl_list_semi of
    final_or_const * type_ option * static_final_declaration_list * semicolon
  | `Late_buil_final_buil_opt_type_init_id_list_semi of
    Token.t (* "late" *)
    * final_builtin (*tok*)
    * type_ option
    * initialized_identifier_list
    * semicolon
  | `Opt_late_buil_choice_type_init_id_list_semi of
    Token.t (* "late" *) option
    * var_or_type
    * initialized_identifier_list
    * semicolon ]

type program =
  [ `Opt_script_tag_opt_libr_name_rep_import_or_export_rep_part_dire_rep_part_of_dire_rep_opt_meta_top_level_defi_rep_stmt of
    script_tag option
    * library_name option
    * import_or_export list (* zero or more *)
    * part_directive list (* zero or more *)
    * part_of_directive list (* zero or more *)
    * (metadata option * top_level_definition) list (* zero or more *)
    * statement list (* zero or more *)
  | `Semg_exp of Token.t (* "__SEMGREP_EXPRESSION" *) * argument ]

type this = Token.t

(* "this" *)
(* inlined *)
type dynamic = Token.t

(* "dynamic" *)
(* inlined *)
type external_builtin = Token.t

(* "external" *)
(* inlined *)
type mixin = Token.t

(* "mixin" *)
(* inlined *)
type minus_operator = Token.t

(* "-" *)
(* inlined *)
type set = Token.t

(* "set" *)
(* inlined *)
type import = Token.t

(* "import" *)
(* inlined *)
type automatic_semicolon = Token.t (* inlined *)
type semgrep_ellipsis = Token.t

(* "..." *)
(* inlined *)
type floating_point_type = Token.t (* inlined *)
type implements = Token.t

(* "implements" *)
(* inlined *)
type function_builtin_identifier = Token.t

(* "Function" *)
(* inlined *)
type library = Token.t

(* "library" *)
(* inlined *)
type export = Token.t

(* "export" *)
(* inlined *)
type asterisk = Token.t

(* "*" *)
(* inlined *)
type factory = Token.t

(* "factory" *)
(* inlined *)
type boolean_type = Token.t

(* "bool" *)
(* inlined *)
type triple_double_quote_end = Token.t (* inlined *)
type exclamation_operator = Token.t

(* "!" *)
(* inlined *)
type part = Token.t

(* "part" *)
(* inlined *)
type static = Token.t

(* "static" *)
(* inlined *)
type string_interp = Token.t

(* pattern \$((\w+)|\{([^{}]+)\}) *)
(* inlined *)
type super = Token.t

(* "super" *)
(* inlined *)
type null_literal = Token.t

(* "null" *)
(* inlined *)
type required = Token.t

(* "required" *)
(* inlined *)
type inferred_type = Token.t

(* "var" *)
(* inlined *)
type new_builtin = Token.t

(* "new" *)
(* inlined *)
type tilde_operator = Token.t

(* "~" *)
(* inlined *)
type get = Token.t

(* "get" *)
(* inlined *)
type triple_quote_end = Token.t (* inlined *)

type compound_access =
  [ `DOT of Token.t (* "." *) | `QMARKDOT of Token.t (* "?." *) ]
(* inlined *)

type false_ = Token.t

(* "false" *)
(* inlined *)
type nullable_type = Token.t

(* "?" *)
(* inlined *)
type covariant = Token.t

(* "covariant" *)
(* inlined *)
type late_builtin = Token.t

(* "late" *)
(* inlined *)
type operator = Token.t

(* "operator" *)
(* inlined *)
type as_ = Token.t

(* "as" *)
(* inlined *)
type interface = Token.t

(* "interface" *)
(* inlined *)
type true_ = Token.t

(* "true" *)
(* inlined *)
type typedef = Token.t

(* "typedef" *)
(* inlined *)
type deferred = Token.t

(* "deferred" *)
(* inlined *)
type external_ = Token.t

(* "external" *)
(* inlined *)
type postfix_operator = increment_operator

(*tok*)
(* inlined *)
type escape_sequence = unused_escape_sequence
(*tok*)
(* inlined *)

type comment =
  [ `Blk_comm of block_comment (*tok*)
  | `SLASHSLASH_pat_d6c261f of Token.t (* "//" *) * pat_d6c261f
  | `SLASHSTAR_pat_05bf793_SLASH of
    Token.t (* "/*" *) * pat_05bf793 * Token.t (* "/" *) ]
(* inlined *)

type documentation_comment =
  [ `Docu_blk_comm of documentation_block_comment (*tok*)
  | `SLASHSLASHSLASH_pat_4fd4a56 of Token.t (* "///" *) * pat_4fd4a56 ]
(* inlined *)

type negation_operator = Token.t
(* "!" *)
(* inlined *)

type requires_modifier =
  [ `Tran of Token.t (* "transitive" *) | `Static of Token.t (* "static" *) ]
(* inlined *)

type symbol_literal = Token.t (* "#" *) * identifier

(*tok*)
(* inlined *)
type scoped_identifier = ambiguous_name * Token.t (* "." *) * identifier
(*tok*)
(* inlined *)

type continue_statement =
  Token.t (* "continue" *) * identifier (*tok*) option * semicolon
(* inlined *)

type break_statement =
  break_builtin (*tok*) * identifier (*tok*) option * semicolon
(* inlined *)

type inferred_parameters =
  Token.t (* "(" *)
  * identifier (*tok*)
  * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *)
  * Token.t
(* ")" *)
(* inlined *)

type conditional_assignable_selector = Token.t (* "?." *) * identifier
(*tok*)
(* inlined *)

type static_or_covariant =
  [ `Cova of Token.t (* "covariant" *) | `Static of Token.t (* "static" *) ]
(* inlined *)

type additive_operator = additive_operator_

(*tok*)
(* inlined *)
type marker_annotation = Token.t (* "@" *) * ambiguous_name (* inlined *)
type annotation = Token.t (* "@" *) * ambiguous_name * arguments (* inlined *)
type assert_statement = assertion * Token.t
(* ";" *)
(* inlined *)

type assignment_expression_without_cascade =
  assignable_expression * assignment_operator * expression_without_cascade
(* inlined *)

type await_expression = Token.t (* "await" *) * unary_expression (* inlined *)

type conditional_expression =
  real_expression
  * Token.t (* "?" *)
  * expression_without_cascade
  * Token.t (* ":" *)
  * expression_without_cascade
(* inlined *)

type const_object_expression =
  const_builtin (*tok*) * type_not_void * dot_identifier option * arguments
(* inlined *)

type deep_ellipsis = Token.t (* "<..." *) * argument * Token.t
(* "...>" *)
(* inlined *)

type do_statement =
  Token.t (* "do" *)
  * statement
  * Token.t (* "while" *)
  * parenthesized_expression
  * semicolon
(* inlined *)

type for_element =
  Token.t (* "await" *) option
  * Token.t (* "for" *)
  * Token.t (* "(" *)
  * for_loop_parts
  * Token.t (* ")" *)
  * element
(* inlined *)

type for_statement =
  Token.t (* "await" *) option
  * Token.t (* "for" *)
  * Token.t (* "(" *)
  * for_loop_parts
  * Token.t (* ")" *)
  * statement
(* inlined *)

type function_expression = formal_parameter_part * function_expression_body
(* inlined *)

type if_element =
  Token.t (* "if" *)
  * parenthesized_expression
  * element
  * (Token.t (* "else" *) * element) option
(* inlined *)

type if_null_expression = real_expression * if_null_expression_ (* inlined *)

type if_statement =
  Token.t (* "if" *)
  * parenthesized_expression
  * statement
  * (Token.t (* "else" *) * statement) option
(* inlined *)

type list_literal =
  const_builtin (*tok*) option
  * type_arguments option
  * Token.t (* "[" *)
  * anon_elem_rep_COMMA_elem_opt_COMMA_4ec364f option
  * Token.t
(* "]" *)
(* inlined *)

type local_function_declaration = metadata option * lambda_expression
(* inlined *)

type logical_and_expression =
  real_expression * (Token.t (* "&&" *) * real_expression) list
(* one or more *)
(* inlined *)

type logical_or_expression =
  real_expression * (Token.t (* "||" *) * real_expression) list
(* one or more *)
(* inlined *)

type named_formal_parameters =
  Token.t (* "{" *)
  * default_named_parameter
  * (Token.t (* "," *) * default_named_parameter) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t
(* "}" *)
(* inlined *)

type named_parameter_types =
  Token.t (* "{" *)
  * named_parameter_type
  * (Token.t (* "," *) * named_parameter_type) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t
(* "}" *)
(* inlined *)

type new_expression =
  Token.t (* "new" *) * type_not_void * dot_identifier option * arguments
(* inlined *)

type normal_formal_parameter =
  metadata option
  * [ `Func_formal_param of function_formal_parameter
    | `Simple_formal_param of simple_formal_parameter
    | `Cons_param of constructor_param
    | `Super_formal_param of super_formal_parameter ]
(* inlined *)

type optional_positional_parameter_types =
  Token.t (* "[" *)
  * normal_parameter_type
  * (Token.t (* "," *) * normal_parameter_type) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t
(* "]" *)
(* inlined *)

type optional_postional_formal_parameters =
  Token.t (* "[" *)
  * default_formal_parameter
  * (Token.t (* "," *) * default_formal_parameter) list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t
(* "]" *)
(* inlined *)

type pair = argument * Token.t (* ":" *) * argument (* inlined *)
type return_statement = Token.t (* "return" *) * argument option * semicolon
(* inlined *)

type set_or_map_literal =
  const_builtin (*tok*) option
  * type_arguments option
  * Token.t (* "{" *)
  * anon_elem_rep_COMMA_elem_opt_COMMA_4ec364f option
  * Token.t
(* "}" *)
(* inlined *)

type spread_element = Token.t (* "..." *) * Token.t (* "?" *) option * argument
(* inlined *)

type switch_statement =
  Token.t (* "switch" *) * parenthesized_expression * switch_block
(* inlined *)

type throw_expression_without_cascade =
  Token.t (* "throw" *) * expression_without_cascade
(* inlined *)

type try_statement =
  try_head
  * [ `Fina_clause of finally_clause
    | `Rep1_on_part_opt_fina_clause of
      on_part list (* one or more *) * finally_clause option ]
(* inlined *)

type type_cast_expression = real_expression * type_cast (* inlined *)
type type_test_expression = real_expression * type_test (* inlined *)

type while_statement =
  Token.t (* "while" *) * parenthesized_expression * statement
(* inlined *)

type yield_each_statement =
  Token.t (* "yield" *) * Token.t (* "*" *) * argument * semicolon
(* inlined *)

type yield_statement = Token.t (* "yield" *) * argument * semicolon
(* inlined *)

type variable_declaration =
  declared_identifier
  * (Token.t (* "," *)
    * identifier (*tok*)
    * (Token.t (* "," *) * identifier (*tok*)) list (* zero or more *))
    option
(* inlined *)

type switch_case =
  [ `Rep_label_case_buil_exp_COLON_rep1_stmt of
    label list (* zero or more *)
    * case_builtin (*tok*)
    * argument
    * Token.t (* ":" *)
    * statement list (* one or more *) ]
(* inlined *)

type receiver_parameter =
  metadata option
  * type_
  * (identifier (*tok*) * Token.t (* "." *)) option
  * Token.t
(* "this" *)
(* inlined *)

type throw_statement = Token.t (* "throw" *) * argument * semicolon
(* inlined *)

type redirecting_factory_constructor_signature =
  const_builtin (*tok*) option
  * Token.t (* "factory" *)
  * identifier (*tok*)
  * dot_identifier list (* zero or more *)
  * formal_parameter_list
  * Token.t (* "=" *)
  * type_not_void
  * dot_identifier option
(* inlined *)

type positional_parameters =
  Token.t (* "[" *)
  * default_formal_parameter
  * (Token.t (* "," *) * default_formal_parameter) list (* zero or more *)
  * Token.t
(* "]" *)
(* inlined *)

type semgrep_expression = Token.t (* "__SEMGREP_EXPRESSION" *) * argument
(* inlined *)

type catch_type = type_ * (Token.t (* "|" *) * type_) list
(* zero or more *)
(* inlined *)

type spread_parameter =
  metadata option * type_ * Token.t (* "..." *) * declared_identifier
(* inlined *)

type labeled_statement = identifier (*tok*) * Token.t (* ":" *) * statement
(* inlined *)

type default_case =
  [ `Rep_label_defa_COLON_rep1_stmt of
    label list (* zero or more *)
    * Token.t (* "default" *)
    * Token.t (* ":" *)
    * statement list (* one or more *) ]
(* inlined *)

type redirection =
  Token.t (* ":" *) * Token.t (* "this" *) * dot_identifier option * arguments
(* inlined *)

type static_initializer = Token.t (* "static" *) * block (* inlined *)

type field_initializer =
  (Token.t (* "this" *) * Token.t (* "." *)) option
  * identifier (*tok*)
  * Token.t (* "=" *)
  * real_expression
  * cascade_section list
(* zero or more *)
(* inlined *)

type wildcard = metadata option * Token.t (* "?" *) * wildcard_bounds option
(* inlined *)

type constructor_body =
  Token.t (* "{" *)
  * explicit_constructor_invocation option
  * statement list (* zero or more *)
  * Token.t
(* "}" *)
(* inlined *)

type method_header =
  (type_parameters * metadata option) option
  * type_
  * method_declarator
  * throws option
(* inlined *)

type library_export =
  metadata option
  * Token.t (* "export" *)
  * configurable_uri
  * combinator list (* zero or more *)
  * semicolon
(* inlined *)

type library_import = metadata option * import_specification (* inlined *)

type mixin_declaration =
  Token.t (* "mixin" *)
  * identifier (*tok*)
  * type_parameters option
  * (Token.t (* "on" *) * type_not_void_list) option
  * interfaces option
  * class_body
(* inlined *)

type declaration =
  [ `Import_spec of import_specification
  | `Class_defi of class_definition
  | `Enum_decl of enum_declaration ]
(* inlined *)
