(*
   Utilities for working with the types defined in Semgrep_output_v1.atd

   TODO: Ideally the compare boilerplate would be generated by a 'deriving ord'
   in Output_from_core.atd, but atdgen does not support yet such annotations.

   TODO: ideally once osemgrep is done we should get rid of this module
*)
open Output_from_core_t

(* pfff (and Emacs) have the first column at index 0, but not r2c *)
let adjust_column x = x + 1

let position_of_token_location loc =
  {
    line = loc.Tok.pos.line;
    col = adjust_column loc.Tok.pos.column;
    offset = loc.Tok.pos.charpos;
  }

let position_range min_loc max_loc =
  let end_line, end_col, end_charpos = Tok.end_pos_of_loc max_loc in
  (* alt: could call position_of_token_location but more symetric like that*)
  ( {
      line = min_loc.Tok.pos.line;
      col = adjust_column min_loc.Tok.pos.column;
      offset = min_loc.Tok.pos.charpos;
    },
    { line = end_line; col = adjust_column end_col; offset = end_charpos } )

let location_of_token_location loc =
  let start, end_ = position_range loc loc in
  { path = loc.Tok.pos.file; start; end_ }

(* compare boilerplate (=~ deriving ord) *)

let compare_position (a : position) b = Int.compare a.offset b.offset

let compare_location (a : location) (b : location) =
  let c = String.compare a.path b.path in
  if c <> 0 then c
  else
    let c = compare_position a.start b.start in
    if c <> 0 then c else compare_position a.end_ b.end_

let compare_metavar_value (a : metavar_value) (b : metavar_value) =
  let c = compare_position a.start b.start in
  if c <> 0 then c else compare_position a.end_ b.end_

(* Generic list comparison. The input lists must already be sorted according
   to 'compare_elt'.

   [1] < [2]
   [1] < [1; 2]
   [1; 2] < [2]
*)
let rec compare_sorted_list compare_elt a b =
  match (a, b) with
  | [], [] -> 0
  | [], _ :: _ -> -1
  | _ :: _, [] -> 1
  | a :: aa, b :: bb ->
      let c = compare_elt a b in
      if c <> 0 then c else compare_sorted_list compare_elt aa bb

(*
   Order the metavariable bindings by location first, then by name.
   (could go the other way too; feel free to change)
*)
let compare_metavar_binding (name1, mv1) (name2, mv2) =
  let c = compare_metavar_value mv1 mv2 in
  if c <> 0 then c else String.compare name1 name2

(* Assumes the metavariable captures within each match_extra are already
   sorted. *)
let compare_match_extra (a : core_match_extra) (b : core_match_extra) =
  let c = compare_sorted_list compare_metavar_binding a.metavars b.metavars in
  if c <> 0 then c else compare a.message b.message

(*
   While the locations of the matches are already in correct order, they
   come in a reverse order when looking at the metavariables that they
   match. This function makes a best a effort to return the results
   in a natural order.
*)
let compare_match (a : core_match) (b : core_match) =
  let c = compare_location a.location b.location in
  if c <> 0 then c else compare_match_extra a.extra b.extra

let sort_metavars (metavars : (string * metavar_value) list) =
  List.stable_sort compare_metavar_binding metavars

let sort_extra (extra : core_match_extra) =
  { extra with metavars = sort_metavars extra.metavars }

let sort_match_list (matches : core_match list) : core_match list =
  let matches =
    matches
    |> Common.map (fun (x : core_match) ->
           { x with extra = sort_extra x.extra })
  in
  List.stable_sort compare_match matches

let sort_match_results (res : core_match_results) : core_match_results =
  { res with matches = sort_match_list res.matches }
